<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>websocket 用途，例子，场景，什么时候用websocket</title>
    <url>/2021/01/24/websocket-%E7%94%A8%E9%80%94%EF%BC%8C%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%9C%BA%E6%99%AF%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8websocket/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.360doc.cn/outlink.html?url=https://java-er.com/blog/tag/websocket/" target="_blank" rel="noopener">websocket</a> 应用例子如下<br>先总结：高即时性服务，比如聊天室的群聊，server顺序收到了张三，李四的消息，立即就推送给王五，不能让王五等半天。<br>Ajax也可以一秒一刷，让王五去问张三说话没，如果张三10分钟没说话，王五要去问600次。 用<a href="http://www.360doc.cn/outlink.html?url=https://java-er.com/blog/tag/websocket/" target="_blank" rel="noopener">websocket</a> 王五不用刷，等着就好了，服务器有了消息会自动给王五的。</p>
<h1 id="1-websocket社交订阅"><a href="#1-websocket社交订阅" class="headerlink" title="1.websocket社交订阅"></a><strong>1.websocket社交订阅</strong></h1><p>对社交类的应用的一个裨益之处就是能够即时的知道你的朋友正在做什么。虽然听起来有点可怕，但是我们都喜欢这样做。你不会想要在数分钟之后才能知道一个家庭成员在馅饼制作大赛获胜或者一个朋友订婚的消息。你是在线的，所以你的订阅的更新应该是实时的。</p>
<a id="more"></a>
<h1 id="2-websocket多玩家游戏"><a href="#2-websocket多玩家游戏" class="headerlink" title="2.websocket多玩家游戏"></a><strong>2.websocket多玩家游戏</strong></h1><p>网络正在迅速转变为游戏平台。在不使用插件（我指的是Flash）的情况下，网络开发者现在可以在浏览器中实现和体验高性能的游戏。无论你是在处理DOM元素、CSS动画，HTML5的canvas或者尝试使用WebGL，玩家之间的互动效率是至关重要的。我不想在我扣动扳机之后，我的对手却已经移动位置。</p>
<h1 id="3-websocket协同编辑-编程"><a href="#3-websocket协同编辑-编程" class="headerlink" title="3.websocket协同编辑/编程"></a><strong>3.websocket协同编辑/编程</strong></h1><p>我们生活在分布式开发团队的时代。平时使用一个文档的副本就满足工作需求了，但是你最终需要有一个方式来合并所有的编辑副本。版本控制系统，比如Git能够帮助处理某些文件，但是当Git发现一个它不能解决的冲突时,你仍然需要去跟踪人们的修改历史。通过一个协同解决方案，比如WebSocket，我们能够工作在同一个文档，从而省去所有的合并版本。这样会很容易看出谁在编辑什么或者你在和谁同时在修改文档的同一部分。</p>
<h1 id="4-websocket收集点击流数据"><a href="#4-websocket收集点击流数据" class="headerlink" title="4.websocket收集点击流数据"></a><strong>4.websocket收集点击流数据</strong></h1><p>分析用户与你网站的互动是提升你的网站的关键。HTTP的开销让我们只能优先考虑和收集最重要的数据部分。然后，经过六个月的线下分析，我们意识到我们应该收集一个不同的判断标准——一个看起来不是那么重要但是现在却影响了一个关键的决定。与HTTP请求的开销方式相比，使用Websocket，你可以由客户端发送不受限制的数据。想要在除页面加载之外跟踪鼠标的移动？只需要通过WebSocket连接发送这些数据到服务器，并存储在你喜欢的NoSQL数据库中就可以了（MongoDB是适合记录这样的事件的）。现在你可以通过回放用户在页面的动作来清楚的知道发生了什么。</p>
<h1 id="5-股票基金报价"><a href="#5-股票基金报价" class="headerlink" title="5.股票基金报价"></a><strong>5.股票基金报价</strong></h1><p>金融界瞬息万变——几乎是每毫秒都在变化。我们人类的大脑不能持续以那样的速度处理那么多的数据，所以我们写了一些算法来帮我们处理这些事情。虽然你不一定是在处理高频的交易，但是，过时的信息也只能导致损失。当你有一个显示盘来跟踪你感兴趣的公司时，你肯定想要随时知道他们的价值，而不是10秒前的数据。使用WebSocket可以流式更新这些数据变化而不需要等待。</p>
<h1 id="6-体育实况更新"><a href="#6-体育实况更新" class="headerlink" title="6.体育实况更新"></a><strong>6.体育实况更新</strong></h1><p>现在我们开始讨论一个让人们激情澎湃的愚蠢的东西——体育。我不是运动爱好者，但是我知道运动迷们想要什么。当爱国者在打比赛的时候，我的妹夫将会沉浸于这场比赛中而不能自拔。那是一种疯狂痴迷的状态，完全发自内心的。我虽然不理解这个，但是我敬佩他们与运动之间的这种强烈的联系，所以，最后我能做的就是给他的体验中降低延迟。如果你在你的网站应用中包含了体育新闻，WebSocket能够助力你的用户获得实时的更新。</p>
<h1 id="7-多媒体聊天"><a href="#7-多媒体聊天" class="headerlink" title="7.多媒体聊天"></a><strong>7.多媒体聊天</strong></h1><p>视频会议并不能代替和真人相见，但当你不能在同一个屋子里见到你谈话的对象时，视频会议是个不错的选择。尽管视频会议私有化做的“不错”，但其使用还是很繁琐。我可是开放式网络的粉丝，所以用WebSockets getUserMedia API和HTML5音视频元素明显是个不错的选择。WebRTC的出现顺理成章的成为我刚才概括的组合体，它看起来很有希望，但其缺乏目前浏览器的支持，所以就取消了它成为候选人的资格。</p>
<h1 id="8-基于位置的应用"><a href="#8-基于位置的应用" class="headerlink" title="8.基于位置的应用"></a><strong>8.基于位置的应用</strong></h1><p>越来越多的开发者借用移动设备的GPS功能来实现他们基于位置的网络应用。如果你一直记录用户的位置(比如运行应用来记录运动轨迹)，你可以收集到更加细致化的数据。如果你想实时的更新网络数据仪表盘(可以说是一个监视运动员的教练)，HTTP协议显得有些笨拙。借用WebSocket TCP链接可以让数据飞起来。</p>
<h1 id="9-在线教育"><a href="#9-在线教育" class="headerlink" title="9.在线教育"></a><strong>9.在线教育</strong></h1><p>上学花费越来越贵了，但互联网变得更快和更便宜。在线教育是学习的不错方式，尤其是你可以和老师以及其他同学一起交流。很自然，WebSockets是个不错的选择，可以多媒体聊天、文字聊天以及其它优势如与别人合作一起在公共数字黑板上画画…</p>
<h1 id="10-论坛的消息广播"><a href="#10-论坛的消息广播" class="headerlink" title="10.论坛的消息广播"></a><strong>10.论坛的消息广播</strong></h1><p>早期的论坛消息通知，靠的都是JS轮询，现在有了websocket 可以改改了。</p>
<p><a href="http://www.360doc.cn/outlink.html?url=https://java-er.com/blog/websocket-where-when/" target="_blank" rel="noopener">https://java-er.com/blog/websocket-where-when/</a></p>
]]></content>
      <categories>
        <category>websocket</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>websocket</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 从入门到实践，万字详解！</title>
    <url>/2020/05/07/Nginx-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%8C%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3%EF%BC%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近越来越频繁地遇到需要配置反向代理的场景，在自己搭建博客的时候，也不可避免要用到 Nginx，所以这段时间集中学习了一下 Nginx，同时做了一些笔记，希望也可以帮助到大家～ 😜</p>
<p>这篇文章会在 CentOS 环境下安装和使用 Nginx，如果对 CentOS 基本操作还不太清楚的，可以先看看 &lt;半小时搞会 CentOS 入门必备基础知识&gt; 一文先做了解。</p>
<p>相信作为开发者，大家都知道 Nginx 的重要，废话不多说，一起来学习吧。</p>
<p>CentOS 版本：<code>7.6</code></p>
<p>Nginx 版本：<code>1.16.1</code></p>
<h2 id="1-Nginx-介绍"><a href="#1-Nginx-介绍" class="headerlink" title="1. Nginx 介绍"></a><strong>1. Nginx 介绍</strong></h2><p>传统的 Web 服务器，每个客户端连接作为一个单独的进程或线程处理，需在切换任务时将 CPU 切换到新的任务并创建一个新的运行时上下文，消耗额外的内存和 CPU 时间，当并发请求增加时，服务器响应变慢，从而对性能产生负面影响。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_56_26_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>Nginx<br><br>Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 Nginx 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是，Nginx 是免费的并可以商业化，配置使用也比较简单。<br><br>Nginx 的最重要的几个使用场景：<br><br>1. 静态资源服务，通过本地文件系统提供服务；<br>2. 反向代理服务，延伸出包括缓存、负载均衡等；<br>3. API 服务，OpenResty ；<br><br>对于前端来说 Node.js 不陌生了，Nginx 和 Node.js 的很多理念类似，HTTP 服务器、事件驱动、异步非阻塞等，且 Nginx 的大部分功能使用 Node.js 也可以实现，但 Nginx 和 Node.js 并不冲突，都有自己擅长的领域。Nginx 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等），Node.js 更擅长上层具体业务逻辑的处理，两者可以完美组合，共同助力前端开发。<br><br>下面我们着重学习一下 Nginx 的使用。<br><br><a id="more"></a>
<h2 id="2-相关概念"><a href="#2-相关概念" class="headerlink" title="2. 相关概念"></a><strong>2. 相关概念</strong></h2><h3 id="2-1-简单请求和非简单请求"><a href="#2-1-简单请求和非简单请求" class="headerlink" title="2.1 简单请求和非简单请求"></a>2.1 简单请求和非简单请求</h3><p>首先我们来了解一下简单请求和非简单请求，如果同时满足下面两个条件，就属于简单请求：</p>
<ol>
<li>请求方法是 <code>HEAD</code>、<code>GET</code>、<code>POST</code> 三种之一；</li>
<li>HTTP 头信息不超过右边着几个字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Last-Event-ID`</code>Content-Type<code>只限于三个值</code>application/x-www-form-urlencoded<code>、</code>multipart/form-data<code>、</code>text/plain`；</li>
</ol>
<p>凡是不同时满足这两个条件的，都属于非简单请求。</p>
<p>浏览器处理简单请求和非简单请求的方式不一样：</p>
<p><strong>简单请求</strong></p>
<p>对于简单请求，浏览器会在头信息中增加 <code>Origin</code> 字段后直接发出，<code>Origin</code> 字段用来说明，本次请求来自的哪个源（协议+域名+端口）。</p>
<p>如果服务器发现 <code>Origin</code> 指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应，浏览器取到回应之后发现回应的头信息中没有包含 <code>Access-Control-Allow-Origin</code> 字段，就抛出一个错误给 XHR 的 <code>error</code> 事件；</p>
<p>如果服务器发现 <code>Origin</code> 指定的域名在许可范围内，服务器返回的响应会多出几个 <code>Access-Control-</code> 开头的头信息字段。</p>
<p><strong>非简单请求</strong></p>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 <code>PUT</code> 或<code>DELETE</code>，或 <code>Content-Type</code> 值为 <code>application/json</code>。浏览器会在正式通信之前，发送一次 HTTP 预检 <code>OPTIONS</code> 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的 <code>XHR</code> 请求，否则报错。</p>
<h3 id="2-2-跨域"><a href="#2-2-跨域" class="headerlink" title="2.2 跨域"></a>2.2 跨域</h3><p>在浏览器上当前访问的网站向另一个网站发送请求获取数据的过程就是<strong>跨域请求</strong>。</p>
<p>跨域是浏览器的同源策略决定的，是一个重要的浏览器安全策略，用于限制一个 origin 的文档或者它加载的脚本与另一个源的资源进行交互，它能够帮助阻隔恶意文档，减少可能被攻击的媒介，可以使用 CORS 配置解除这个限制。</p>
<p>关于跨域网上已经有很多解释，这里就不啰嗦，也可以直接看 MDN 的 &lt;浏览器的同源策略&gt; 文档进一步了解，这里就列举几个同源和不同元的例子，相信程序员都能看得懂。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 同源的例子</span><br><span class="line">http://example.com/app1/index.html  # 只是路径不同</span><br><span class="line">http://example.com/app2/index.html</span><br><span class="line"></span><br><span class="line">http://Example.com:80  # 只是大小写差异</span><br><span class="line">http://example.com</span><br><span class="line"></span><br><span class="line"># 不同源的例子</span><br><span class="line">http://example.com/app1   # 协议不同</span><br><span class="line">https://example.com/app2</span><br><span class="line"></span><br><span class="line">http://example.com        # host 不同</span><br><span class="line">http://www.example.com</span><br><span class="line">http://myapp.example.com</span><br><span class="line"></span><br><span class="line">http://example.com        # 端口不同</span><br><span class="line">http://example.com:8080</span><br></pre></td></tr></table></figure>
<h3 id="2-3-正向代理和反向代理"><a href="#2-3-正向代理和反向代理" class="headerlink" title="2.3 正向代理和反向代理"></a>2.3 正向代理和反向代理</h3><p>反向代理（Reverse Proxy）对应的是正向代理（Forward Proxy），他们的区别：</p>
<p><strong>正向代理：</strong> 一般的访问流程是客户端直接向目标服务器发送请求并获取内容，使用正向代理后，客户端改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，使真实客户端对服务器不可见；</p>
<p>举个具体的例子 🌰，你的浏览器无法直接访问谷哥，这时候可以通过一个代理服务器来帮助你访问谷哥，那么这个服务器就叫正向代理。</p>
<p><strong>反向代理：</strong> 与一般访问流程相比，使用反向代理后，直接收到请求的服务器是代理服务器，然后将请求转发给内部网络上真正进行处理的服务器，得到的结果返回给客户端。反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。一般在处理跨域请求的时候比较常用。现在基本上所有的大型网站都设置了反向代理。</p>
<p>举个具体的例子 🌰，去饭店吃饭，可以点川菜、粤菜、江浙菜，饭店也分别有三个菜系的厨师 👨‍🍳，但是你作为顾客不用管哪个厨师给你做的菜，只用点菜即可，小二将你菜单中的菜分配给不同的厨师来具体处理，那么这个小二就是反向代理服务器。</p>
<p>简单的说，一般给客户端做代理的都是正向代理，给服务器做代理的就是反向代理。</p>
<p>正向代理和反向代理主要的原理区别可以参见下图：</p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>
<h3 id="2-4-负载均衡"><a href="#2-4-负载均衡" class="headerlink" title="2.4 负载均衡"></a>2.4 负载均衡</h3><p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p>
<p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p>
<p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p>
<p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是<strong>负载均衡</strong>，核心是「分摊压力」。Nginx 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p>
<p>举个具体的例子 🌰，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 B 口，B 口人少车空….”，这个工作人员的作用就是负载均衡。</p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>负载均衡<br><br>### 2.5 动静分离<br><br>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。<br><br><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_56_53_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>动静分离<br><br>一般来说，都需要将动态资源和静态资源分开，由于 Nginx 的高并发和静态资源缓存等特性，经常将静态资源部署在 Nginx 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。<br><br>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。<br><br>## <strong>3. Nginx 快速安装</strong><br><br>### 3.1 安装<br><br>我们可以先看看<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure>
<p>来看看</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_57_00_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure>
<p>来安装 Nginx，然后我们在命令行中 <code>nginx -v</code> 就可以看到具体的 Nginx 版本信息，也就安装完毕了。</p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>image-20200307180545816<br><br>### 3.2 相关文件夹<br><br>然后我们可以使用 <code>rpm -ql nginx</code> 来查看 Nginx 被安装到了什么地方，有哪些相关目录，其中位于 <code>/etc</code> 目录下的主要是配置文件，还有一些文件见下图：<br><br><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_57_12_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>主要关注的文件夹有两个：</p>
<ol>
<li><code>/etc/nginx/conf.d/</code> 文件夹，是我们进行子配置的配置项存放处，<code>/etc/nginx/nginx.conf</code> 主配置文件会默认把这个文件夹中所有子配置项都引入；</li>
<li><code>/usr/share/nginx/html/</code> 文件夹，通常静态文件都放在这个文件夹，也可以根据你自己的习惯放其他地方；</li>
</ol>
<h3 id="3-3-跑起来康康"><a href="#3-3-跑起来康康" class="headerlink" title="3.3 跑起来康康"></a>3.3 跑起来康康</h3><p>安装之后开启 Nginx，如果系统开启了防火墙，那么需要设置一下在防火墙中加入需要开放的端口，下面列举几个常用的防火墙操作（没开启的话不用管这个）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld  # 开启防火墙</span><br><span class="line">systemctl stop firewalld   # 关闭防火墙</span><br><span class="line">systemctl status firewalld # 查看防火墙开启状态，显示running则是正在运行</span><br><span class="line">firewall-cmd --reload      # 重启防火墙，永久打开端口需要reload一下</span><br><span class="line"></span><br><span class="line"># 添加开启端口，--permanent表示永久打开，不加是临时打开重启之后失效</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=8888/tcp</span><br><span class="line"></span><br><span class="line"># 查看防火墙，添加的端口也可以看到</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>
<p>然后设置 Nginx 的开机启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure>
<p>启动 Nginx （其他命令后面有详细讲解）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>
<p>然后访问你的 IP，这时候就可以看到 Nginx 的欢迎页面了～ <code>Welcome to nginx！</code> 👏</p>
<h3 id="3-4-安装-nvm-amp-node-amp-git"><a href="#3-4-安装-nvm-amp-node-amp-git" class="headerlink" title="3.4 安装 nvm &amp; node &amp; git"></a>3.4 安装 nvm &amp; node &amp; git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载 nvm，或者看官网的步骤 https://github.com/nvm-sh/nvm#install--update-script</span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash</span><br><span class="line"></span><br><span class="line">source   ~/.bashrc    # 安装完毕后，更新配置文件即可使用 nvm 命令</span><br><span class="line">nvm ls-remote         # 查看远程 node 版本</span><br><span class="line">nvm install v12.16.3  # 选一个你要安装的版本安装，我这里选择 12.16.3</span><br><span class="line">nvm list              # 安装完毕查看安装的 node 版本</span><br><span class="line">node -v               # 查看是否安装好了</span><br><span class="line"></span><br><span class="line">yum install git   # git 安装</span><br></pre></td></tr></table></figure>
<h2 id="4-Nginx-操作常用命令"><a href="#4-Nginx-操作常用命令" class="headerlink" title="4. Nginx 操作常用命令"></a><strong>4. Nginx 操作常用命令</strong></h2><p>Nginx 的命令在控制台中输入 <code>nginx -h</code> 就可以看到完整的命令，这里列举几个常用的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload  # 向主进程发送信号，重新加载配置文件，热重启</span><br><span class="line">nginx -s reopen	 # 重启 Nginx</span><br><span class="line">nginx -s stop    # 快速关闭</span><br><span class="line">nginx -s quit    # 等待工作进程处理完成后关闭</span><br><span class="line">nginx -T         # 查看当前 Nginx 最终的配置</span><br><span class="line">nginx -t -c &lt;配置路径&gt;    # 检查配置是否有问题，如果已经在配置目录，则不需要-c</span><br></pre></td></tr></table></figure>
<p><code>systemctl</code> 是 Linux 系统应用管理工具 <code>systemd</code> 的主命令，用于管理系统，我们也可以用它来对 Nginx 进行管理，相关命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start nginx    # 启动 Nginx</span><br><span class="line">systemctl stop nginx     # 停止 Nginx</span><br><span class="line">systemctl restart nginx  # 重启 Nginx</span><br><span class="line">systemctl reload nginx   # 重新加载 Nginx，用于修改配置后</span><br><span class="line">systemctl enable nginx   # 设置开机启动 Nginx</span><br><span class="line">systemctl disable nginx  # 关闭开机启动 Nginx</span><br><span class="line">systemctl status nginx   # 查看 Nginx 运行状态</span><br></pre></td></tr></table></figure>
<h2 id="5-Nginx-配置语法"><a href="#5-Nginx-配置语法" class="headerlink" title="5. Nginx 配置语法"></a><strong>5. Nginx 配置语法</strong></h2><p>就跟前面文件作用讲解的图所示，Nginx 的主配置文件是<code>/etc/nginx/nginx.conf</code>，你可以使用 <code>cat -n nginx.conf</code> 来查看配置。</p>
<p><code>nginx.conf</code> 结构图可以这样概括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main        # 全局配置，对全局生效</span><br><span class="line">├── events  # 配置影响 Nginx 服务器或与用户的网络连接</span><br><span class="line">├── http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置</span><br><span class="line">│   ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分</span><br><span class="line">│   ├── server   # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块</span><br><span class="line">│   ├── server</span><br><span class="line">│   │   ├── location  # server 块可以包含多个 location 块，location 指令用于匹配 uri</span><br><span class="line">│   │   ├── location</span><br><span class="line">│   │   └── ...</span><br><span class="line">│   └── ...</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>
<p>一个 Nginx 配置文件的结构就像 <code>nginx.conf</code> 显示的那样，配置文件的语法规则：</p>
<ol>
<li>配置文件由指令与指令块构成；</li>
<li>每条指令以 <code>;</code> 分号结尾，指令与参数间以空格符号分隔；</li>
<li>指令块以 <code>{}</code> 大括号将多条指令组织在一起；</li>
<li><code>include</code> 语句允许组合多个配置文件以提升可维护性；</li>
<li>使用 <code>#</code> 符号添加注释，提高可读性；</li>
<li>使用 <code>$</code> 符号使用变量；</li>
<li>部分指令的参数支持正则表达式；</li>
</ol>
<h3 id="5-1-典型配置"><a href="#5-1-典型配置" class="headerlink" title="5.1 典型配置"></a>5.1 典型配置</h3><p>Nginx 的典型配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user  nginx;                        # 运行用户，默认即是nginx，可以不进行设置</span><br><span class="line">worker_processes  1;                # Nginx 进程数，一般设置为和 CPU 核数一样</span><br><span class="line">error_log  /var/log/nginx/error.log warn;   # Nginx 的错误日志存放目录</span><br><span class="line">pid        /var/run/nginx.pid;      # Nginx 服务启动时的 pid 存放位置</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;     # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)</span><br><span class="line">    worker_connections 1024;   # 每个进程允许最大并发数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;   # 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置</span><br><span class="line">    # 设置日志模式</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;   # Nginx访问日志存放位置</span><br><span class="line"></span><br><span class="line">    sendfile            on;   # 开启高效传输模式</span><br><span class="line">    tcp_nopush          on;   # 减少网络报文段的数量</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;   # 保持连接的时间，也叫超时时间，单位秒</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;      # 文件扩展名与类型映射表</span><br><span class="line">    default_type        application/octet-stream;   # 默认文件类型</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;   # 加载子配置项</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">    	listen       80;       # 配置监听的端口</span><br><span class="line">    	server_name  localhost;    # 配置的域名</span><br><span class="line">    	</span><br><span class="line">    	location / &#123;</span><br><span class="line">    		root   /usr/share/nginx/html;  # 网站根目录</span><br><span class="line">    		index  index.html index.htm;   # 默认首页文件</span><br><span class="line">    		deny 172.168.22.11;   # 禁止访问的ip地址，可以为all</span><br><span class="line">    		allow 172.168.33.44；# 允许访问的ip地址，可以为all</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	error_page 500 502 503 504 /50x.html;  # 默认50x对应的访问页面</span><br><span class="line">    	error_page 400 404 error.html;   # 同上</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server 块可以包含多个 location 块，location 指令用于匹配 uri，语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~] uri &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指令后面：</p>
<ol>
<li><code>=</code> 精确匹配路径，用于不含正则表达式的 uri 前，如果匹配成功，不再进行后续的查找；</li>
<li><code>^~</code> 用于不含正则表达式的 uri 前，表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找；</li>
<li><code>~</code> 表示用该符号后面的正则去匹配路径，区分大小写；</li>
<li><code>~*</code> 表示用该符号后面的正则去匹配路径，不区分大小写。跟 <code>~</code> 优先级都比较低，如有多个location的正则能匹配的话，则使用正则表达式最长的那个；</li>
</ol>
<p>如果 uri 包含正则表达式，则必须要有 <code>~</code> 或 <code>~*</code> 标志。</p>
<h3 id="5-2-全局变量"><a href="#5-2-全局变量" class="headerlink" title="5.2 全局变量"></a>5.2 全局变量</h3><p>Nginx 有一些常用的全局变量，你可以在配置的任何位置使用它们，如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">全局变量名</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>$host</code></td>
<td style="text-align:left">请求信息中的 <code>Host</code>，如果请求中没有 <code>Host</code> 行，则等于设置的服务器名，不包含端口</td>
</tr>
<tr>
<td style="text-align:left"><code>$request_method</code></td>
<td style="text-align:left">客户端请求类型，如 <code>GET</code>、<code>POST</code></td>
</tr>
<tr>
<td style="text-align:left"><code>$remote_addr</code></td>
<td style="text-align:left">客户端的 <code>IP</code> 地址</td>
</tr>
<tr>
<td style="text-align:left"><code>$args</code></td>
<td style="text-align:left">请求中的参数</td>
</tr>
<tr>
<td style="text-align:left"><code>$arg_PARAMETER</code></td>
<td style="text-align:left"><code>GET</code> 请求中变量名 PARAMETER 参数的值，例如：<code>$http_user_agent</code>(Uaer-Agent 值),<code>$http_referer</code>…</td>
</tr>
<tr>
<td style="text-align:left"><code>$content_length</code></td>
<td style="text-align:left">请求头中的 <code>Content-length</code> 字段</td>
</tr>
<tr>
<td style="text-align:left"><code>$http_user_agent</code></td>
<td style="text-align:left">客户端agent信息</td>
</tr>
<tr>
<td style="text-align:left"><code>$http_cookie</code></td>
<td style="text-align:left">客户端cookie信息</td>
</tr>
<tr>
<td style="text-align:left"><code>$remote_addr</code></td>
<td style="text-align:left">客户端的IP地址</td>
</tr>
<tr>
<td style="text-align:left"><code>$remote_port</code></td>
<td style="text-align:left">客户端的端口</td>
</tr>
<tr>
<td style="text-align:left"><code>$http_user_agent</code></td>
<td style="text-align:left">客户端agent信息</td>
</tr>
<tr>
<td style="text-align:left"><code>$server_protocol</code></td>
<td style="text-align:left">请求使用的协议，如 <code>HTTP/1.0</code>、<code>HTTP/1.1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>$server_addr</code></td>
<td style="text-align:left">服务器地址</td>
</tr>
<tr>
<td style="text-align:left"><code>$server_name</code></td>
<td style="text-align:left">服务器名称</td>
</tr>
<tr>
<td style="text-align:left"><code>$server_port</code></td>
<td style="text-align:left">服务器的端口号</td>
</tr>
<tr>
<td style="text-align:left"><code>$scheme</code></td>
<td style="text-align:left">HTTP 方法（如http，https）</td>
</tr>
</tbody>
</table>
<p>还有更多的内置预定义变量，可以直接搜索关键字「nginx内置预定义变量」可以看到一堆博客写这个，这些变量都可以在配置文件中直接使用。</p>
<h2 id="6-设置二级域名虚拟主机"><a href="#6-设置二级域名虚拟主机" class="headerlink" title="6. 设置二级域名虚拟主机"></a><strong>6. 设置二级域名虚拟主机</strong></h2><p>在某某云 ☁️ 上购买了域名之后，就可以配置虚拟主机了，一般配置的路径在<code>域名管理 -&gt; 解析 -&gt; 添加记录</code> 中添加二级域名，配置后某某云会把二级域名也解析到我们配置的服务器 IP 上，然后我们在 Nginx 上配置一下虚拟主机的访问监听，就可以拿到从这个二级域名过来的请求了。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_57_35_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>image-20200426150644768<br><br>现在我自己的服务器上配置了一个 fe 的二级域名，也就是说在外网访问 <code>fe.sherlocked93.club</code> 的时候，也可以访问到我们的服务器了。<br><br>由于默认配置文件 <code>/etc/nginx/nginx.conf</code> 的 http 模块中有一句 <code>include /etc/nginx/conf.d/*.conf</code> 也就是说 <code>conf.d</code> 文件夹下的所有 <code>*.conf</code> 文件都会作为子配置项被引入配置文件中。为了维护方便，我在 <code>/etc/nginx/conf.d</code> 文件夹中新建一个 <code>fe.sherlocked93.club.conf</code> ：<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># /etc/nginx/conf.d/fe.sherlocked93.club.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">	server_name fe.sherlocked93.club;</span><br><span class="line"></span><br><span class="line">	location / &#123;</span><br><span class="line">		root  /usr/share/nginx/html/fe;</span><br><span class="line">		index index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>/usr/share/nginx/html</code> 文件夹下新建 fe 文件夹，新建文件<code>index.html</code>，内容随便写点，改完 <code>nginx -s reload</code> 重新加载，浏览器中输入<code>fe.sherlocked93.club</code>，发现从二级域名就可以访问到我们刚刚新建的 fe 文件夹：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_58_47_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<h2 id="7-配置反向代理"><a href="#7-配置反向代理" class="headerlink" title="7. 配置反向代理"></a><strong>7. 配置反向代理</strong></h2><p>反向代理是工作中最常用的服务器功能，经常被用来解决跨域问题，下面简单介绍一下如何实现反向代理。</p>
<p>首先进入 Nginx 的主配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>为了看起来方便，把行号显示出来 <code>:set nu</code> （个人习惯），然后我们去 <code>http</code>模块的 <code>server</code> 块中的 <code>location /</code>，增加一行将默认网址重定向到最大学习网站 Bilibili 的 <code>proxy_pass</code> 配置 🤓 ：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_58_57_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>改完保存退出，<code>nginx -s reload</code> 重新加载，进入默认网址，那么现在就直接跳转到 B 站了，实现了一个简单的代理。</p>
<p>实际使用中，可以将请求转发到本机另一个服务器上，也可以根据访问的路径跳转到不同端口的服务中。</p>
<p>比如我们监听 <code>9001</code> 端口，然后把访问不同路径的请求进行反向代理：</p>
<ol>
<li>把访问 <code>http://127.0.0.1:9001/edu</code> 的请求转发到 <code>http://127.0.0.1:8080</code></li>
<li>把访问 <code>http://127.0.0.1:9001/vod</code> 的请求转发到 <code>http://127.0.0.1:8081</code></li>
</ol>
<p>这种要怎么配置呢，首先同样打开主配置文件，然后在 http 模块下增加一个 server 块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 9001;</span><br><span class="line">  server_name *.sherlocked93.club;</span><br><span class="line"></span><br><span class="line">  location ~ /edu/ &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8080;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location ~ /vod/ &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8081;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反向代理还有一些其他的指令，可以了解一下：</p>
<ol>
<li><code>proxy_set_header</code>：在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息；</li>
<li><code>proxy_connect_timeout</code>：配置 Nginx 与后端代理服务器尝试建立连接的超时时间；</li>
<li><code>proxy_read_timeout</code>：配置 Nginx 向后端服务器组发出 read 请求后，等待相应的超时时间；</li>
<li><code>proxy_send_timeout</code>：配置 Nginx 向后端服务器组发出 write 请求后，等待相应的超时时间；</li>
<li><code>proxy_redirect</code>：用于修改后端服务器返回的响应头中的 Location 和 Refresh。</li>
</ol>
<h2 id="8-跨域-CORS-配置"><a href="#8-跨域-CORS-配置" class="headerlink" title="8. 跨域 CORS 配置"></a><strong>8. 跨域 CORS 配置</strong></h2><p>关于简单请求、非简单请求、跨域的概念，前面已经介绍过了，还不了解的可以看看前面的讲解。现在前后端分离的项目一统天下，经常本地起了前端服务，需要访问不同的后端地址，不可避免遇到跨域问题。</p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>要解决跨域问题，我们来制造一个跨域问题。首先和前面设置二级域名的方式一样，先设置好 <code>fe.sherlocked93.club</code> 和 <code>be.sherlocked93.club</code> 二级域名，都指向本云服务器地址，虽然对应 IP 是一样的，但是在 <code>fe.sherlocked93.club</code> 域名发出的请求访问 <code>be.sherlocked93.club</code> 域名的请求还是跨域了，因为访问的 host 不一致（如果不知道啥原因参见前面跨域的内容）。</p>
<h3 id="8-1-使用反向代理解决跨域"><a href="#8-1-使用反向代理解决跨域" class="headerlink" title="8.1 使用反向代理解决跨域"></a>8.1 使用反向代理解决跨域</h3><p>在前端服务地址为 <code>fe.sherlocked93.club</code> 的页面请求 <code>be.sherlocked93.club</code> 的后端服务导致的跨域，可以这样配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 9001;</span><br><span class="line">  server_name fe.sherlocked93.club;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass be.sherlocked93.club;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就将对前一个域名 <code>fe.sherlocked93.club</code> 的请求全都代理到了 <code>be.sherlocked93.club</code>，前端的请求都被我们用服务器代理到了后端地址下，绕过了跨域。</p>
<p>这里对静态文件的请求和后端服务的请求都以 <code>fe.sherlocked93.club</code> 开始，不易区分，所以为了实现对后端服务请求的统一转发，通常我们会约定对后端服务的请求加上 <code>/apis/</code> 前缀或者其他的 path 来和对静态资源的请求加以区分，此时我们可以这样配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 请求跨域，约定代理后端服务请求path以/apis/开头</span><br><span class="line">location ^~/apis/ &#123;</span><br><span class="line">    # 这里重写了请求，将正则匹配中的第一个分组的path拼接到真正的请求后面，并用break停止后续匹配</span><br><span class="line">    rewrite ^/apis/(.*)$ /$1 break;</span><br><span class="line">    proxy_pass be.sherlocked93.club;</span><br><span class="line">  </span><br><span class="line">    # 两个域名之间cookie的传递与回写</span><br><span class="line">    proxy_cookie_domain be.sherlocked93.club fe.sherlocked93.club;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，静态资源我们使用 <code>fe.sherlocked93.club/xx.html</code>，动态资源我们使用 <code>fe.sherlocked93.club/apis/getAwo</code>，浏览器页面看起来仍然访问的前端服务器，绕过了浏览器的同源策略，毕竟我们看起来并没有跨域。</p>
<p>也可以统一一点，直接把前后端服务器地址直接都转发到另一个 <code>server.sherlocked93.club</code>，只通过在后面添加的 path 来区分请求的是静态资源还是后端服务，看需求了。</p>
<h3 id="8-2-配置-header-解决跨域"><a href="#8-2-配置-header-解决跨域" class="headerlink" title="8.2 配置 header 解决跨域"></a>8.2 配置 header 解决跨域</h3><p>当浏览器在访问跨源的服务器时，也可以在跨域的服务器上直接设置 Nginx，从而前端就可以无感地开发，不用把实际上访问后端的地址改成前端服务的地址，这样可适性更高。</p>
<p>比如前端站点是 <code>fe.sherlocked93.club</code>，这个地址下的前端页面请求 <code>be.sherlocked93.club</code> 下的资源，比如前者的 <code>fe.sherlocked93.club/index.html</code> 内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;welcome fe.sherlocked93.club!!&lt;h1&gt;</span><br><span class="line">    &lt;script type=&apos;text/javascript&apos;&gt;</span><br><span class="line">    var xmlhttp = new XMLHttpRequest()</span><br><span class="line">    xmlhttp.open(&quot;GET&quot;, &quot;http://be.sherlocked93.club/index.html&quot;, true);</span><br><span class="line">    xmlhttp.send();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>打开浏览器访问 <code>fe.sherlocked93.club/index.html</code> 的结果如下：</p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>很明显这里是跨域请求，在浏览器中直接访问 <code>http://be.sherlocked93.club/index.html</code> 是可以访问到的，但是在 <code>fe.sherlocked93.club</code> 的 html 页面访问就会出现跨域。</p>
<p>在 <code>/etc/nginx/conf.d/</code> 文件夹中新建一个配置文件，对应二级域名 <code>be.sherlocked93.club</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># /etc/nginx/conf.d/be.sherlocked93.club.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  be.sherlocked93.club;</span><br><span class="line">  </span><br><span class="line">	add_header &apos;Access-Control-Allow-Origin&apos; $http_origin;   # 全局变量获得当前请求origin，带cookie的请求不支持*</span><br><span class="line">	add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;    # 为 true 可带上 cookie</span><br><span class="line">	add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;;  # 允许请求方法</span><br><span class="line">	add_header &apos;Access-Control-Allow-Headers&apos; $http_access_control_request_headers;  # 允许请求的 header，可以为 *</span><br><span class="line">	add_header &apos;Access-Control-Expose-Headers&apos; &apos;Content-Length,Content-Range&apos;;</span><br><span class="line">	</span><br><span class="line">  if ($request_method = &apos;OPTIONS&apos;) &#123;</span><br><span class="line">		add_header &apos;Access-Control-Max-Age&apos; 1728000;   # OPTIONS 请求的有效期，在有效期内不用发出另一条预检请求</span><br><span class="line">		add_header &apos;Content-Type&apos; &apos;text/plain; charset=utf-8&apos;;</span><br><span class="line">		add_header &apos;Content-Length&apos; 0;</span><br><span class="line">    </span><br><span class="line">		return 204;                  # 200 也可以</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	location / &#123;</span><br><span class="line">		root  /usr/share/nginx/html/be;</span><br><span class="line">		index index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后 <code>nginx -s reload</code> 重新加载配置。这时再访问 <code>fe.sherlocked93.club/index.html</code> 结果如下，请求中出现了我们刚刚配置的 Header：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_21_03_45_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>解决了跨域问题。</p>
<h2 id="9-开启-gzip-压缩"><a href="#9-开启-gzip-压缩" class="headerlink" title="9. 开启 gzip 压缩"></a><strong>9. 开启 gzip 压缩</strong></h2><p>gzip 是一种常用的网页压缩技术，传输的网页经过 gzip 压缩之后大小通常可以变为原来的一半甚至更小（官网原话），更小的网页体积也就意味着带宽的节约和传输速度的提升，特别是对于访问量巨大大型网站来说，每一个静态资源体积的减小，都会带来可观的流量与带宽的节省。</p>
<p>百度可以找到很多检测站点来查看目标网页有没有开启 gzip 压缩，在下随便找了一个 &lt;网页GZIP压缩检测&gt; 输入掘金 <code>juejin.im</code> 来偷窥下掘金有没有开启 gzip。</p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>这里可以看到掘金是开启了 gzip 的，压缩效果还挺不错，达到了 52% 之多，本来 <code>34kb</code> 的网页体积，压缩完只需要 <code>16kb</code>，可以想象网页传输速度提升了不少。</p>
<h3 id="9-1-Nginx-配置-gzip"><a href="#9-1-Nginx-配置-gzip" class="headerlink" title="9.1 Nginx 配置 gzip"></a>9.1 Nginx 配置 gzip</h3><p>使用 gzip 不仅需要 Nginx 配置，浏览器端也需要配合，需要在请求消息头中包含 <code>Accept-Encoding: gzip</code>（IE5 之后所有的浏览器都支持了，是现代浏览器的默认设置）。一般在请求 html 和 css 等静态资源的时候，支持的浏览器在 request 请求静态资源的时候，会加上 <code>Accept-Encoding: gzip</code> 这个 header，表示自己支持 gzip 的压缩方式，Nginx 在拿到这个请求的时候，如果有相应配置，就会返回经过 gzip 压缩过的文件给浏览器，并在 response 相应的时候加上 <code>content-encoding: gzip</code> 来告诉浏览器自己采用的压缩方式（因为浏览器在传给服务器的时候一般还告诉服务器自己支持好几种压缩方式），浏览器拿到压缩的文件后，根据自己的解压方式进行解析。</p>
<p>先来看看 Nginx 怎么进行 gzip 配置，和之前的配置一样，为了方便管理，还是在 <code>/etc/nginx/conf.d/</code> 文件夹中新建配置文件 <code>gzip.conf</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># /etc/nginx/conf.d/gzip.conf</span><br><span class="line"></span><br><span class="line">gzip on; # 默认off，是否开启gzip</span><br><span class="line">gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line"># 上面两个开启基本就能跑起了，下面的愿意折腾就了解一下</span><br><span class="line">gzip_static on;</span><br><span class="line">gzip_proxied any;</span><br><span class="line">gzip_vary on;</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line">gzip_buffers 16 8k;</span><br><span class="line"># gzip_min_length 1k;</span><br><span class="line">gzip_http_version 1.1;</span><br></pre></td></tr></table></figure>
<p>稍微解释一下：</p>
<ol>
<li><strong>gzip_types</strong>：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；</li>
<li><strong>gzip_static</strong>：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 <code>.gz</code> 文件内容；</li>
<li><strong>gzip_proxied</strong>：默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；</li>
<li><strong>gzip_vary</strong>：用于在响应消息头中添加 <code>Vary：Accept-Encoding</code>，使代理服务器根据请求头中的 <code>Accept-Encoding</code> 识别是否启用 gzip 压缩；</li>
<li><strong>gzip_comp_level</strong>：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</li>
<li><strong>gzip_buffers</strong>：获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；</li>
<li><strong>gzip_min_length</strong>：允许压缩的页面最小字节数，页面字节数从header头中的 <code>Content-Length</code> 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</li>
<li><strong>gzip_http_version</strong>：默认 1.1，启用 gzip 所需的 HTTP 最低版本；</li>
</ol>
<p>这个配置可以插入到 http 模块整个服务器的配置里，也可以插入到需要使用的虚拟主机的 <code>server</code> 或者下面的 <code>location</code> 模块中，当然像上面我们这样写的话就是被 include 到 http 模块中了。</p>
<p>其他更全的配置信息可以查看 &lt;官网文档ngx_http_gzip_module&gt;，配置前是这样的：</p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>配置之后 response 的 header 里面多了一个 <code>Content-Encoding: gzip</code>，返回信息被压缩了：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_21_04_05_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>注意了，一般 gzip 的配置建议加上 <code>gzip_min_length 1k</code>，不加的话：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_21_04_56_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>由于文件太小，gzip 压缩之后得到了 -48% 的体积优化，压缩之后体积还比压缩之前体积大了，所以最好设置低于 <code>1kb</code> 的文件就不要 gzip 压缩了 🤪</p>
<h3 id="9-2-Webpack-的-gzip-配置"><a href="#9-2-Webpack-的-gzip-配置" class="headerlink" title="9.2 Webpack 的 gzip 配置"></a>9.2 Webpack 的 gzip 配置</h3><p>当前端项目使用 Webpack 进行打包的时候，也可以开启 gzip 压缩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// vue-cli3 的 vue.config.js 文件</span><br><span class="line">const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // gzip 配置</span><br><span class="line">  configureWebpack: config =&gt; &#123;</span><br><span class="line">    if (process.env.NODE_ENV === &apos;production&apos;) &#123;</span><br><span class="line">      // 生产环境</span><br><span class="line">      return &#123;</span><br><span class="line">        plugins: [new CompressionWebpackPlugin(&#123;</span><br><span class="line">          test: /\.js$|\.html$|\.css/,    // 匹配文件名</span><br><span class="line">          threshold: 10240,               // 文件压缩阈值，对超过10k的进行压缩</span><br><span class="line">          deleteOriginalAssets: false     // 是否删除源文件</span><br><span class="line">        &#125;)]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此打包出来的文件如下图：</p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>这里可以看到某些打包之后的文件下面有一个对应的 <code>.gz</code> 经过 <code>gzip</code> 压缩之后的文件，这是因为这个文件超过了 <code>10kb</code>，有的文件没有超过 <code>10kb</code> 就没有进行<code>gzip</code> 打包，如果你期望压缩文件的体积阈值小一点，可以在 <code>compression-webpack-plugin</code> 这个插件的配置里进行对应配置。</p>
<p>那么为啥这里 Nginx 已经有了 gzip 压缩，Webpack 这里又整了个 gzip 呢，因为如果全都是使用 Nginx 来压缩文件，会耗费服务器的计算资源，如果服务器的 <code>gzip_comp_level</code> 配置的比较高，就更增加服务器的开销，相应增加客户端的请求时间，得不偿失。</p>
<p>如果压缩的动作在前端打包的时候就做了，把打包之后的高压缩等级文件作为静态资源放在服务器上，Nginx 会优先查找这些压缩之后的文件返回给客户端，相当于把压缩文件的动作从 Nginx 提前给 Webpack 打包的时候完成，节约了服务器资源，所以一般推介在生产环境应用 Webpack 配置 gzip 压缩。</p>
<h2 id="10-配置负载均衡"><a href="#10-配置负载均衡" class="headerlink" title="10. 配置负载均衡"></a><strong>10. 配置负载均衡</strong></h2><p>负载均衡在之前已经介绍了相关概念了，主要思想就是把负载均匀合理地分发到多个服务器上，实现压力分流的目的。</p>
<p>主要配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  upstream myserver &#123;</span><br><span class="line">  	# ip_hash;  # ip_hash 方式</span><br><span class="line">    # fair;   # fair 方式</span><br><span class="line">    server 127.0.0.1:8081;  # 负载均衡目的服务地址</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">    server 127.0.0.1:8082 weight=10;  # weight 方式，不写默认为 1</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_pass http://myserver;</span><br><span class="line">      proxy_connect_timeout 10;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nginx 提供了好几种分配方式，默认为<strong>轮询</strong>，就是轮流来。有以下几种分配方式：</p>
<ol>
<li><strong>轮询</strong>，默认方式，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务挂了，能自动剔除；</li>
<li><strong>weight</strong>，权重分配，指定轮询几率，权重越高，在被访问的概率越大，用于后端服务器性能不均的情况；</li>
<li><strong>ip_hash</strong>，每个请求按访问 IP 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决动态网页 session 共享问题。负载均衡每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的；</li>
<li><strong>fair</strong>（第三方），按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 nginx-upstream-fair，需要先安装；</li>
</ol>
<h2 id="11-配置动静分离"><a href="#11-配置动静分离" class="headerlink" title="11. 配置动静分离"></a><strong>11. 配置动静分离</strong></h2><p>动静分离在之前也介绍过了，就是把动态和静态的请求分开。方式主要有两种，一种 是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案。另外一种方法就是动态跟静态文件混合在一起发布， 通过 Nginx 配置来分开。</p>
<p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化。则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  location /www/ &#123;</span><br><span class="line">  	root /data/;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  location /image/ &#123;</span><br><span class="line">  	root /data/;</span><br><span class="line">    autoindex on;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-配置高可用集群（双机热备）"><a href="#12-配置高可用集群（双机热备）" class="headerlink" title="12. 配置高可用集群（双机热备）"></a><strong>12. 配置高可用集群（双机热备）</strong></h2><p>当主 Nginx 服务器宕机之后，切换到备份 Nginx 服务器</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_21_28_02_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>2020-03-13-双机热备<br><br>首先安装 keepalived，<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure>
<p>然后编辑 <code>/etc/keepalived/keepalived.conf</code> 配置文件，并在配置文件中增加 <code>vrrp_script</code> 定义一个外围检测机制，并在 <code>vrrp_instance</code> 中通过定义 <code>track_script</code> 来追踪脚本执行过程，实现节点转移：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global_defs&#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">        acassen@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre@firewall.loc</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30 // 上面都是邮件配置，没卵用</span><br><span class="line">   router_id LVS_DEVEL     // 当前服务器名字，用hostname命令来查看</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_maintainace &#123; // 检测机制的脚本名称为chk_maintainace</span><br><span class="line">    script &quot;[[ -e/etc/keepalived/down ]] &amp;&amp; exit 1 || exit 0&quot; // 可以是脚本路径或脚本命令</span><br><span class="line">    // script &quot;/etc/keepalived/nginx_check.sh&quot;    // 比如这样的脚本路径</span><br><span class="line">    interval 2  // 每隔2秒检测一次</span><br><span class="line">    weight -20  // 当脚本执行成立，那么把当前服务器优先级改为-20</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instanceVI_1 &#123;   // 每一个vrrp_instance就是定义一个虚拟路由器</span><br><span class="line">    state MASTER      // 主机为MASTER，备用机为BACKUP</span><br><span class="line">    interface eth0    // 网卡名字，可以从ifconfig中查找</span><br><span class="line">    virtual_router_id 51 // 虚拟路由的id号，一般小于255，主备机id需要一样</span><br><span class="line">    priority 100      // 优先级，master的优先级比backup的大</span><br><span class="line">    advert_int 1      // 默认心跳间隔</span><br><span class="line">    authentication &#123;  // 认证机制</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111   // 密码</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;  // 虚拟地址vip</span><br><span class="line">       172.16.2.8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中检测脚本 <code>nginx_check.sh</code>，这里提供一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">A=`ps -C nginx --no-header | wc -l`</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    /usr/sbin/nginx # 尝试重新启动nginx</span><br><span class="line">    sleep 2         # 睡眠2秒</span><br><span class="line">    if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then</span><br><span class="line">        killall keepalived # 启动失败，将keepalived服务杀死。将vip漂移到其它备份节点</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>复制一份到备份服务器，备份 Nginx 的配置要将 <code>state</code> 后改为 <code>BACKUP</code>，<code>priority</code> 改为比主机小。</p>
<p>设置完毕后各自 <code>service keepalived start</code> 启动，经过访问成功之后，可以把 Master 机的 keepalived 停掉，此时 Master 机就不再是主机了 <code>service keepalived stop</code>，看访问虚拟 IP 时是否能够自动切换到备机 <code>ip addr</code>。</p>
<p>再次启动 Master 的 keepalived，此时 vip 又变到了主机上。</p>
<h2 id="13-适配-PC-或移动设备"><a href="#13-适配-PC-或移动设备" class="headerlink" title="13. 适配 PC 或移动设备"></a><strong>13. 适配 PC 或移动设备</strong></h2><p>根据用户设备不同返回不同样式的站点，以前经常使用的是纯前端的自适应布局，但无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东……这些大型网站就都没有采用自适应，而是用分开制作的方式，根据用户请求的 <code>user-agent</code> 来判断是返回 PC 还是 H5 站点。</p>
<p>首先在 <code>/usr/share/nginx/html</code> 文件夹下 <code>mkdir</code> 分别新建两个文件夹 <code>PC</code> 和 <code>mobile</code>，<code>vim</code> 编辑两个 <code>index.html</code> 随便写点内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/share/nginx/html</span><br><span class="line">mkdir pc mobile</span><br><span class="line">cd pc</span><br><span class="line">vim index.html   # 随便写点比如 hello pc!</span><br><span class="line">cd ../mobile</span><br><span class="line">vim index.html   # 随便写点比如 hello mobile!</span><br></pre></td></tr></table></figure>
<p>然后和设置二级域名虚拟主机时候一样，去 <code>/etc/nginx/conf.d</code> 文件夹下新建一个配置文件 <code>fe.sherlocked93.club.conf</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># /etc/nginx/conf.d/fe.sherlocked93.club.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">	server_name fe.sherlocked93.club;</span><br><span class="line"></span><br><span class="line">	location / &#123;</span><br><span class="line">		root  /usr/share/nginx/html/pc;</span><br><span class="line">    if ($http_user_agent ~* &apos;(Android|webOS|iPhone|iPod|BlackBerry)&apos;) &#123;</span><br><span class="line">      root /usr/share/nginx/html/mobile;</span><br><span class="line">    &#125;</span><br><span class="line">		index index.html;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置基本没什么不一样的，主要多了一个 <code>if</code> 语句，然后使用<code>$http_user_agent</code> 全局变量来判断用户请求的 <code>user-agent</code>，指向不同的 root 路径，返回对应站点。</p>
<p>在浏览器访问这个站点，然后 F12 中模拟使用手机访问：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_21_28_35_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>可以看到在模拟使用移动端访问的时候，Nginx 返回的站点变成了移动端对应的 html 了。</p>
<h2 id="14-配置-HTTPS"><a href="#14-配置-HTTPS" class="headerlink" title="14. 配置 HTTPS"></a><strong>14. 配置 HTTPS</strong></h2><p>具体配置过程网上挺多的了，也可以使用你购买的某某云，一般都会有免费申请的服务器证书，安装直接看所在云的操作指南即可。</p>
<p>我购买的腾讯云提供的亚洲诚信机构颁发的免费证书只能一个域名使用，二级域名什么的需要另外申请，但是申请审批比较快，一般几分钟就能成功，然后下载证书的压缩文件，里面有个 nginx 文件夹，把 <code>xxx.crt</code> 和 <code>xxx.key</code> 文件拷贝到服务器目录，再配置下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl http2 default_server;   # SSL 访问端口号为 443</span><br><span class="line">  server_name sherlocked93.club;         # 填写绑定证书的域名</span><br><span class="line"></span><br><span class="line">  ssl_certificate /etc/nginx/https/1_sherlocked93.club_bundle.crt;   # 证书文件地址</span><br><span class="line">  ssl_certificate_key /etc/nginx/https/2_sherlocked93.club.key;      # 私钥文件地址</span><br><span class="line">  ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;      #请按照以下协议配置</span><br><span class="line">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    root         /usr/share/nginx/html;</span><br><span class="line">    index        index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完 <code>nginx -t -q</code> 校验一下，没问题就 <code>nginx -s reload</code>，现在去访问 <code>https://sherlocked93.club/</code> 就能访问 HTTPS 版的网站了。</p>
<p>一般还可以加上几个增强安全性的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_header X-Frame-Options DENY;           # 减少点击劫持</span><br><span class="line">add_header X-Content-Type-Options nosniff; # 禁止服务器自动解析资源类型</span><br><span class="line">add_header X-Xss-Protection 1;             # 防XSS攻击</span><br></pre></td></tr></table></figure>
<h2 id="15-一些常用技巧"><a href="#15-一些常用技巧" class="headerlink" title="15. 一些常用技巧"></a><strong>15. 一些常用技巧</strong></h2><h3 id="15-1-静态服务"><a href="#15-1-静态服务" class="headerlink" title="15.1 静态服务"></a>15.1 静态服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  static.sherlocked93.club;</span><br><span class="line">  charset utf-8;    # 防止中文文件名乱码</span><br><span class="line"></span><br><span class="line">  location /download &#123;</span><br><span class="line">    alias	          /usr/share/nginx/html/static;  # 静态资源目录</span><br><span class="line">    </span><br><span class="line">    autoindex               on;    # 开启静态资源列目录</span><br><span class="line">    autoindex_exact_size    off;   # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB</span><br><span class="line">    autoindex_localtime     off;   # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-图片防盗链"><a href="#15-2-图片防盗链" class="headerlink" title="15.2 图片防盗链"></a>15.2 图片防盗链</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  *.sherlocked93.club;</span><br><span class="line">  </span><br><span class="line">  # 图片防盗链</span><br><span class="line">  location ~* \.(gif|jpg|jpeg|png|bmp|swf)$ &#123;</span><br><span class="line">    valid_referers none blocked 192.168.0.2;  # 只允许本机 IP 外链引用</span><br><span class="line">    if ($invalid_referer)&#123;</span><br><span class="line">      return 403;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-3-请求过滤"><a href="#15-3-请求过滤" class="headerlink" title="15.3 请求过滤"></a>15.3 请求过滤</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 非指定请求全返回 403</span><br><span class="line">if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123;</span><br><span class="line">  return 403;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  # IP访问限制（只允许IP是 192.168.0.2 机器访问）</span><br><span class="line">  allow 192.168.0.2;</span><br><span class="line">  deny all;</span><br><span class="line">  </span><br><span class="line">  root   html;</span><br><span class="line">  index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-4-配置图片、字体等静态文件缓存"><a href="#15-4-配置图片、字体等静态文件缓存" class="headerlink" title="15.4 配置图片、字体等静态文件缓存"></a>15.4 配置图片、字体等静态文件缓存</h3><p>由于图片、字体、音频、视频等静态文件在打包的时候通常会增加了 hash，所以缓存可以设置的长一点，先设置强制缓存，再设置协商缓存；如果存在没有 hash 值的静态文件，建议不设置强制缓存，仅通过协商缓存判断是否需要使用缓存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 图片缓存时间设置</span><br><span class="line">location ~ .*\.(css|js|jpg|png|gif|swf|woff|woff2|eot|svg|ttf|otf|mp3|m4a|aac|txt)$ &#123;</span><br><span class="line">	expires 10d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 如果不希望缓存</span><br><span class="line">expires -1;</span><br></pre></td></tr></table></figure>
<h3 id="15-5-单页面项目-history-路由配置"><a href="#15-5-单页面项目-history-路由配置" class="headerlink" title="15.5 单页面项目 history 路由配置"></a>15.5 单页面项目 history 路由配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  fe.sherlocked93.club;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    root       /usr/share/nginx/html/dist;  # vue 打包后的文件夹</span><br><span class="line">    index      index.html index.htm;</span><br><span class="line">    try_files  $uri $uri/ /index.html @rewrites;</span><br><span class="line">    </span><br><span class="line">    expires -1;                          # 首页一般没有强制缓存</span><br><span class="line">    add_header Cache-Control no-cache;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 接口转发，如果需要的话</span><br><span class="line">  #location ~ ^/api &#123;</span><br><span class="line">  #  proxy_pass http://be.sherlocked93.club;</span><br><span class="line">  #&#125;</span><br><span class="line">  </span><br><span class="line">  location @rewrites &#123;</span><br><span class="line">    rewrite ^(.+)$ /index.html break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-6-HTTP-请求转发到-HTTPS"><a href="#15-6-HTTP-请求转发到-HTTPS" class="headerlink" title="15.6 HTTP 请求转发到 HTTPS"></a>15.6 HTTP 请求转发到 HTTPS</h3><p>配置完 HTTPS 后，浏览器还是可以访问 HTTP 的地址<code>http://sherlocked93.club/</code> 的，可以做一个 301 跳转，把对应域名的 HTTP 请求重定向到 HTTPS 上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name www.sherlocked93.club;</span><br><span class="line"></span><br><span class="line">    # 单域名重定向</span><br><span class="line">    if ($host = &apos;www.sherlocked93.club&apos;)&#123;</span><br><span class="line">        return 301 https://www.sherlocked93.club$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">    # 全局非 https 协议时重定向</span><br><span class="line">    if ($scheme != &apos;https&apos;) &#123;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 或者全部重定向</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line"></span><br><span class="line">    # 以上配置选择自己需要的即可，不用全部加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-7-泛域名路径分离"><a href="#15-7-泛域名路径分离" class="headerlink" title="15.7 泛域名路径分离"></a>15.7 泛域名路径分离</h3><p>这是一个非常实用的技能，经常有时候我们可能需要配置一些二级或者三级域名，希望通过 Nginx 自动指向对应目录，比如：</p>
<ol>
<li><code>test1.doc.sherlocked93.club</code> 自动指向 <code>/usr/share/nginx/html/doc/test1</code>服务器地址；</li>
<li><code>test2.doc.sherlocked93.club</code> 自动指向 <code>/usr/share/nginx/html/doc/test2</code>服务器地址；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  ~^([\w-]+)\.doc\.sherlocked93\.club$;</span><br><span class="line"></span><br><span class="line">    root /usr/share/nginx/html/doc/$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-8-泛域名转发"><a href="#15-8-泛域名转发" class="headerlink" title="15.8 泛域名转发"></a>15.8 泛域名转发</h3><p>和之前的功能类似，有时候我们希望把二级或者三级域名链接重写到我们希望的路径，让后端就可以根据路由解析不同的规则：</p>
<ol>
<li><code>test1.serv.sherlocked93.club/api?name=a</code> 自动转发到 <code>127.0.0.1:8080/test1/api?name=a</code>；</li>
<li><code>test2.serv.sherlocked93.club/api?name=a</code> 自动转发到 <code>127.0.0.1:8080/test2/api?name=a</code> ；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name ~^([\w-]+)\.serv\.sherlocked93\.club$;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header        X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header        Host $http_host;</span><br><span class="line">        proxy_set_header        X-NginX-Proxy true;</span><br><span class="line">        proxy_pass              http://127.0.0.1:8080/$1$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-最佳实践"><a href="#16-最佳实践" class="headerlink" title="16. 最佳实践"></a><strong>16. 最佳实践</strong></h2><ol>
<li>为了使 Nginx 配置更易于维护，建议为每个服务创建一个单独的配置文件，存储在 <code>/etc/nginx/conf.d</code> 目录，根据需求可以创建任意多个独立的配置文件。</li>
<li>独立的配置文件，建议遵循以下命名约定 <code>&lt;服务&gt;.conf</code>，比如域名是 <code>sherlocked93.club</code>，那么你的配置文件的应该是这样的 <code>/etc/nginx/conf.d/sherlocked93.club.conf</code>，如果部署多个服务，也可以在文件名中加上 Nginx 转发的端口号，比如 <code>sherlocked93.club.8080.conf</code>，如果是二级域名，建议也都加上 <code>fe.sherlocked93.club.conf</code>。</li>
<li>常用的、复用频率比较高的配置可以放到 <code>/etc/nginx/snippets</code> 文件夹，在 Nginx 的配置文件中需要用到的位置 include 进去，以功能来命名，并在每个 snippet 配置文件的开头注释标明主要功能和引入位置，方便管理。比如之前的 <code>gzip</code>、<code>cors</code> 等常用配置，我都设置了 snippet。</li>
<li>Nginx 日志相关目录，内以 <code>域名.type.log</code> 命名（比如 <code>be.sherlocked93.club.access.log</code> 和 <code>be.sherlocked93.club.error.log</code> ）位于 <code>/var/log/nginx/</code> 目录中，为每个独立的服务配置不同的访问权限和错误日志文件，这样查找错误时，会更加方便快捷。</li>
</ol>
<hr>
<p>网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~</p>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发必备的 RestFul API 知识</title>
    <url>/2020/05/07/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E7%9A%84-RestFul-API-%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_16_06_1.png" alt="image-20200507201600488"></p>
<p>RestFul API 是每个程序员都应该了解并掌握的基本知识，我们在开发过程中设计API的时候也应该至少要满足RestFul API的最基本的要求（比如接口中尽量使用名词，使用POST 请求创建资源，DELETE请求删除资源等等，示例：GET   /notes/id：获取某个指定id的笔记的信息）。最近学习过程中接触到这些东西，自己没有时间总结，所以分享一些不错的文章给大家。</p>
<p>相关阅读：</p>
<a id="more"></a>
<p>•<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html（阮一峰，这篇文章大部分内容来源）" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/restful_api.html（阮一峰，这篇文章大部分内容来源）</a></p>
<p>•<a href="https://www.baeldung.com/spring-hateoas-tutorial" target="_blank" rel="noopener">https://www.baeldung.com/spring-hateoas-tutorial</a>(RestFul API Tutorial)</p>
<p>•<a href="https://aisensiy.github.io/2017/06/04/spring-boot-and-hateoas/(Spring中使用HATEOAS)" target="_blank" rel="noopener">https://aisensiy.github.io/2017/06/04/spring-boot-and-hateoas/(Spring中使用HATEOAS)</a></p>
<p>•<a href="https://spring.io/guides/tutorials/bookmarks/" target="_blank" rel="noopener">https://spring.io/guides/tutorials/bookmarks/</a> (Building REST services with Spring)</p>
<p>•<a href="https://www.baeldung.com/spring-hateoas-tutorial(https://www.baeldung.com/spring-hateoas-tutorial)" target="_blank" rel="noopener">https://www.baeldung.com/spring-hateoas-tutorial(https://www.baeldung.com/spring-hateoas-tutorial)</a></p>
<h3 id="备注：HATEOAS这个大家可能之前并没有怎么接触过，我看了很多项目的源码也并没有满足HATEOAS设计的要求，实际上RestFul-API-最好满足HATEOAS设计，也就是在返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。"><a href="#备注：HATEOAS这个大家可能之前并没有怎么接触过，我看了很多项目的源码也并没有满足HATEOAS设计的要求，实际上RestFul-API-最好满足HATEOAS设计，也就是在返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。" class="headerlink" title="备注：HATEOAS这个大家可能之前并没有怎么接触过，我看了很多项目的源码也并没有满足HATEOAS设计的要求，实际上RestFul API 最好满足HATEOAS设计，也就是在返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。"></a>备注：HATEOAS这个大家可能之前并没有怎么接触过，我看了很多项目的源码也并没有满足HATEOAS设计的要求，实际上RestFul API 最好满足HATEOAS设计，也就是在返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</h3><h3 id="一、重要概念："><a href="#一、重要概念：" class="headerlink" title="一、重要概念："></a>一、重要概念：</h3><p>REST,即Representational State Transfer的缩写，翻译过来就是”表现层状态转化”。</p>
<ul>
<li><strong>Resource</strong>（资源） ：对象的单个实例。例如，一只动物。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</li>
<li><strong>集合</strong>：对象的集合。例如，动物。</li>
<li><strong>第三方</strong>：使用我们接口的开发者</li>
<li><strong>表现层（Representation）</strong>：”资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</li>
<li><strong>状态转化（State Transfer）</strong> 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</li>
</ul>
<p>综合上面的解释，我们总结一下什么是RESTful架构：</p>
<p>　（1）每一个URI代表一种资源；</p>
<p>　（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
<p>　（3）客户端通过HTTP动词(GET,POST等等)，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<h3 id="二、REST接口规范"><a href="#二、REST接口规范" class="headerlink" title="二、REST接口规范"></a>二、REST接口规范</h3><h4 id="1、动作"><a href="#1、动作" class="headerlink" title="1、动作"></a>1、动作</h4><ul>
<li>GET （SELECT）：从服务器检索特定资源，或资源列表。</li>
<li>POST （CREATE）：在服务器上创建一个新的资源。</li>
<li>PUT （UPDATE）：更新服务器上的资源（客户端提供更新后的整个资源）。</li>
<li>PATCH （UPDATE）：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新）。</li>
<li>DELETE （DELETE）：从服务器删除资源。</li>
</ul>
<h4 id="2、路径（接口命名）"><a href="#2、路径（接口命名）" class="headerlink" title="2、路径（接口命名）"></a>2、路径（接口命名）</h4><p>路径又称”终点”（endpoint），表示API的具体网址。</p>
<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>
<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>
<p>接口尽量使用名词，禁止使用动词，下面是一些例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET         /zoos：列出所有动物园</span><br><span class="line">POST        /zoos：新建一个动物园</span><br><span class="line">GET         /zoos/ID：获取某个指定动物园的信息</span><br><span class="line">PUT         /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH       /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE      /zoos/ID：删除某个动物园</span><br><span class="line">GET         /zoos/ID/animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE      /zoos/ID/animals/ID：删除某个指定动物园的指定动物复制代码</span><br></pre></td></tr></table></figure>
<p>反例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/getAllCars</span><br><span class="line">/createNewCar</span><br><span class="line">/deleteAllRedCars复制代码</span><br></pre></td></tr></table></figure>
<p>再比如，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p>
<p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p>
<blockquote>
<p>　　POST /accounts/1/transfer/500/to/2</p>
</blockquote>
<p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p>
<blockquote>
<p>　　POST /transaction HTTP/1.1</p>
<p>　　Host: 127.0.0.1</p>
<p>　　from=1&amp;to=2&amp;amount=500.00</p>
</blockquote>
<p>理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源(/school)，老师(/school/teachers)，学生(/school/students)就是二级资源。</p>
<h4 id="3、版本（Versioning）"><a href="#3、版本（Versioning）" class="headerlink" title="3、版本（Versioning）"></a>3、版本（Versioning）</h4><p>应该将API的版本号放入URL。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://api.example.com/v1/复制代码</span><br></pre></td></tr></table></figure>
<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>
<h4 id="4、过滤信息（Filtering）"><a href="#4、过滤信息（Filtering）" class="headerlink" title="4、过滤信息（Filtering）"></a>4、过滤信息（Filtering）</h4><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。下面是一些常见的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page_number=2&amp;page_size=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br><span class="line">参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，</span><br><span class="line">GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。复制代码</span><br></pre></td></tr></table></figure>
<h4 id="5、状态码（Status-Codes）"><a href="#5、状态码（Status-Codes）" class="headerlink" title="5、状态码（Status Codes）"></a>5、状态码（Status Codes）</h4><p>状态码范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1xx 信息，请求收到，继续处理。范围保留用于底层HTTP的东西，你很可能永远也用不到。</span><br><span class="line">2xx 成功，行为被成功地接受、理解和采纳</span><br><span class="line">3xx 重定向，为了完成请求，必须进一步执行的动作</span><br><span class="line">4xx 客户端错误，请求包含语法错误或者请求无法实现。范围保留用于响应客户端做出的错误，例如。他们提供不良数据或要求不存在的东西。这些请求应该是幂等的，而不是更改服务器的状态。</span><br><span class="line">5xx 范围的状态码是保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，甚至</span><br><span class="line">开发人员也通常没法处理，发送这类状态码的目的以确保客户端获得某种响应。</span><br><span class="line">当收到5xx响应时，客户端不可能知道服务器的状态，所以这类状态码是要尽可能的避免。复制代码</span><br></pre></td></tr></table></figure>
<p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line">201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</span><br><span class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</span><br><span class="line">400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</span><br><span class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line">422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br><span class="line">502 网关错误</span><br><span class="line">503 Service Unavailable</span><br><span class="line">504 网关超时</span><br></pre></td></tr></table></figure>
<h3 id="三-HATEOAS"><a href="#三-HATEOAS" class="headerlink" title="三 HATEOAS"></a>三 HATEOAS</h3><p>上面是RESTful API最基本的东西，也是我们平时开发过程中最容易实践到的。实际上，RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>
<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;link&quot;: &#123;</span><br><span class="line">  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,</span><br><span class="line">  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;List of zoos&quot;,</span><br><span class="line">  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型Hypermedia API的设计被称为HATEOAS。</p>
<p>在Spring 中有一个叫做HATEOAS的API 库，通过它我们可以更轻松的创建除符合 HATEOAS 设计的API。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>每个程序员都应该懂点cURL</title>
    <url>/2020/09/06/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E6%87%82%E7%82%B9cURL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>cURL 是常用的命令行工具，它的名字就是客户端（client）的 URL 工具的意思，如果熟练的话，完全可以取代 Postman 这一类的图形界面工具，但是多数情况可以用 cURL 快速的验证一下请求的正确性，所以一些基本用法我们还是值得学习的。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li><p>发起 GET 请求</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>指定 User-Agent 发起 GET 请求</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -A 'Mozilla/5.0' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>自定义 Header</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H 'User-Agent:Mozilla/5.0' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>发送 Cookies</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -b 'gt=octocat' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
<p>这个命令等同于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H 'Cookies:gt=octocat' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>发送 POST 请求，携带 username 参数，-d 命令会自带 <code>Content-Type : application/x-www-form-urlencoded</code> 的请求类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d'username=july' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>设置 Referer 为 <code>https://google.com</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -e 'https://google.com' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><ul>
<li><p>上传图片</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -F 'file=@photo.png;type=image/png' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>打印 Response 返回的内容，包括 Header</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -i https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>打印 request 请求的信息，包括 Header</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -I https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>跳过 SSL 检测。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -k https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>模拟弱网请求，10K/s 请求</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --limit-rate 10k https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>输出通信的整个过程，用于调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -v https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>看完让你彻底理解 WebSocket 原理</title>
    <url>/2020/08/02/%E7%9C%8B%E5%AE%8C%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3-WebSocket-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载:<a href="https://www.cnblogs.com/nnngu/p/9347635.html" target="_blank" rel="noopener">点击查看原文</a></p>
</blockquote>
<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>最近有同学问我有没有做过在线咨询功能。同时，公司也刚好让我接手一个 IM 项目。所以今天抽时间记录一下最近学习的内容。</p>
<p>本文主要剖析了 WebSocket 的原理，以及附上一个完整的聊天室实战 Demo （包含前端和后端，代码下载链接在文末）。</p>
<h2 id="2、WebSocket-与-HTTP"><a href="#2、WebSocket-与-HTTP" class="headerlink" title="2、WebSocket 与 HTTP"></a>2、WebSocket 与 HTTP</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。现在所有浏览器都已经支持了。WebSocket 的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。</p>
<p>HTTP 有 1.1 和 1.0 之说，也就是所谓的 keep-alive ，把多个 HTTP 请求合并为一个，但是 Websocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器，所以在握手阶段使用了 HTTP 。</p>
<p>下面一张图说明了 HTTP 与 WebSocket 的主要区别：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596350538206.webp" alt="" title="" class="">
                <p></p>
            </figure>
<a id="more"></a>
<p>WebSocket 的其他特点：</p>
<ul>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li>
</ul>
<h2 id="3、WebSocket-是什么样的协议，具体有什么优点"><a href="#3、WebSocket-是什么样的协议，具体有什么优点" class="headerlink" title="3、WebSocket 是什么样的协议，具体有什么优点"></a>3、WebSocket 是什么样的协议，具体有什么优点</h2><p>首先，WebSocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的 PHP 生命周期来解释。</p>
<p>HTTP 的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。</p>
<p>在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response， 在 HTTP 中永远是这样，也就是说一个 Request 只能有一个 Response。而且这个 Response 也是被动的，不能主动发起。</p>
<p>你 BB 了这么多，跟 WebSocket 有什么关系呢？好吧，我正准备说 WebSocket 呢。</p>
<p>首先 WebSocket 是基于 HTTP 协议的，或者说借用了 HTTP 协议来完成一部分握手。</p>
<p>首先我们来看个典型的 WebSocket 握手</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure>
<p>熟悉 HTTP 的童鞋可能发现了，这段类似 HTTP 协议的握手请求中，多了这么几个东西。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>这个就是 WebSocket 的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理~而不是那个老土的 HTTP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠我，我要验证你是不是真的是 WebSocket 助理。</p>
<p>然后， Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~</p>
<p>最后， Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft （协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用同一个版本：服务员，我要的是13岁的噢→_→</p>
<p>然后服务器会返回下列东西，表示已经接受到请求， 成功建立 WebSocket 啦！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>
<p>这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mozillasocket，lurnarsocket 或者 shitsocket。</p>
<p>然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧。</p>
<p>后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。</p>
<p>至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了。</p>
<h2 id="4、WebSocket-的作用"><a href="#4、WebSocket-的作用" class="headerlink" title="4、WebSocket 的作用"></a>4、WebSocket 的作用</h2><p>在讲 WebSocket之前，我就顺带着讲下 ajax轮询 和 long poll 的原理。</p>
<h3 id="4-1、ajax轮询"><a href="#4-1、ajax轮询" class="headerlink" title="4-1、ajax轮询"></a>4-1、ajax轮询</h3><p>ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</p>
<p><strong>场景再现：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line"></span><br><span class="line">服务端：没有（Response）</span><br><span class="line"></span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line"></span><br><span class="line">服务端：没有。。（Response）</span><br><span class="line"></span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line"></span><br><span class="line">服务端：你好烦啊，没有啊。。（Response）</span><br><span class="line"></span><br><span class="line">客户端：啦啦啦，有没有新消息（Request）</span><br><span class="line"></span><br><span class="line">服务端：好啦好啦，有啦给你。（Response）</span><br><span class="line"></span><br><span class="line">客户端：啦啦啦，有没有新消息（Request）</span><br><span class="line"></span><br><span class="line">服务端：。。。。。没。。。。没。。。没有（Response） —- loop</span><br></pre></td></tr></table></figure>
<h3 id="4-2、long-poll"><a href="#4-2、long-poll" class="headerlink" title="4-2、long poll"></a>4-2、long poll</h3><p>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起请求后，如果没消息，就一直不返回 Response 给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</p>
<p><strong>场景再现：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）</span><br><span class="line"></span><br><span class="line">服务端：额。。 等待到有消息的时候。。来 给你（Response）</span><br><span class="line"></span><br><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop</span><br></pre></td></tr></table></figure>
<p><strong>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。</strong></p>
<p>何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。</p>
<p>从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。</p>
<p>ajax轮询 需要服务器有很快的处理速度和资源。long poll 需要有很高的并发，也就是说同时接待客户的能力。</p>
<p>所以 ajax轮询 和 long poll 都有可能发生这种情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端：啦啦啦啦，有新信息么？</span><br><span class="line"></span><br><span class="line">服务端：正忙，请稍后再试（503 Server Unavailable）</span><br><span class="line"></span><br><span class="line">客户端：。。。。好吧，啦啦啦，有新信息么？</span><br><span class="line"></span><br><span class="line">服务端：正忙，请稍后再试（503 Server Unavailable）</span><br></pre></td></tr></table></figure>
<h3 id="4-3、WebSocket"><a href="#4-3、WebSocket" class="headerlink" title="4-3、WebSocket"></a>4-3、WebSocket</h3><p>通过上面这两个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。</p>
<p>一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。</p>
<p>哦对了，忘记说了 HTTP 还是一个无状态协议。通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。</p>
<p>所以在这种情况下出现了 WebSocket 。他解决了 HTTP 的这几个难题。首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。所以上面的情景可以做如下修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request）</span><br><span class="line"></span><br><span class="line">服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched）</span><br><span class="line"></span><br><span class="line">客户端：麻烦你有信息的时候推送给我噢。。</span><br><span class="line"></span><br><span class="line">服务端：ok，有的时候会告诉你的。</span><br><span class="line"></span><br><span class="line">服务端：balabalabalabala</span><br><span class="line"></span><br><span class="line">服务端：balabalabalabala</span><br><span class="line"></span><br><span class="line">服务端：哈哈哈哈哈啊哈哈哈哈</span><br><span class="line"></span><br><span class="line">服务端：笑死我了哈哈哈哈哈哈哈</span><br></pre></td></tr></table></figure>
<p>这样，只需要经过一次 HTTP 请求，就可以做到源源不断的信息传送了。</p>
<h2 id="5、实战代码"><a href="#5、实战代码" class="headerlink" title="5、实战代码"></a>5、实战代码</h2><p>本文的更新源 托管于GitHub</p>
<p>参考文档：</p>
<blockquote>
<p><a href="http://php.net/manual/zh/ref.sockets.php" target="_blank" rel="noopener">http://php.net/manual/zh/ref.sockets.php</a> <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</a></p>
</blockquote>
<p>前端代码：<a href="https://github.com/nnngu/WebSocketDemo-js" target="_blank" rel="noopener">https://github.com/nnngu/WebSocketDemo-js</a><br>后端代码：<a href="https://github.com/nnngu/WebSocketDemo-php" target="_blank" rel="noopener">https://github.com/nnngu/WebSocketDemo-php</a></p>
<p>运行步骤：</p>
<ol>
<li>在终端打开 <code>WebSocketDemo-php</code> 目录，执行 <code>php -q server.php</code></li>
<li>用浏览器访问 <code>WebSocketDemo-js</code> 目录里面的 <code>index.html</code></li>
</ol>
<p>运行截图：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596350538215.webp" alt="" title="" class="">
                <p></p>
            </figure>]]></content>
      <categories>
        <category>java</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出 Kafka 和 ZooKeeper 的分布式消息队列</title>
    <url>/2020/05/16/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Kafka-%E5%92%8C-ZooKeeper-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247491550&amp;idx=3&amp;sn=0d6aa438a6cc4ea208c84f1f0379b3b2&amp;chksm=e82bfecfdf5c77d9620dc76961be083c59d78ed95f95161f9ccc68e60340576776fc4f1295bb&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1589620106744&amp;sharer_shareid=40612a9bc90b8d55689c1d82b8ad1cd7&amp;key=4c5479cb7e07b2ac11eb878bf4bbe77475b5ddbee6605609ce3b505a9e2e871c999eebda374f3a655a6b5e103c88704ae7d5cc939580c8cad9181cbbbd53b95978296a1f1b100deda5c4487082d627b8&amp;ascene=1&amp;uin=MTc0MjQ2ODA2OQ%3D%3D&amp;devicetype=Windows+10+x64&amp;version=6209007b&amp;lang=zh_CN&amp;exportkey=ATBs42KokFLoegR4uWL%2BLkk%3D&amp;pass_ticket=2jrmEmmI%2FRKlJnUXJvlSHbMpD7YmNlp77%2FbnqdknS92wQ%2FpqE2jV1X8ub0m%2Bygwf" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<h3 id="1-Kafka-总体架构"><a href="#1-Kafka-总体架构" class="headerlink" title="1. Kafka 总体架构"></a>1. Kafka 总体架构</h3><p>基于 Kafka-ZooKeeper 的分布式消息队列系统总体架构如下：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937051.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<a id="more"></a>
<p>如上图所示，一个典型的 Kafka 体系架构包括若干 Producer（消息生产者），若干 broker（作为 Kafka 节点的服务器），若干 Consumer（Group），以及一个 ZooKeeper 集群。Kafka通过 ZooKeeper 管理集群配置、选举 Leader 以及在 consumer group 发生变化时进行 Rebalance（即消费者负载均衡，在下一课介绍）。Producer 使用 push（推）模式将消息发布到 broker，Consumer 使用 pull（拉）模式从 broker 订阅并消费消息。</p>
<p>上图仅描摹了一个总体架构，并没有对作为 Kafka 节点的 broker 进行深入刻画，事实上，它的内部细节相当复杂，如下图所示，Kafka 节点涉及 Topic、Partition 两个重要概念。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937072.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>在 Kafka 架构中，有几个术语：</p>
<ul>
<li><strong>Producer</strong>：生产者，即消息发送者，push 消息到 Kafka 集群中的 broker（就是 server）中；</li>
<li><strong>Broker</strong>：Kafka 集群由多个 Kafka 实例（server） 组成，每个实例构成一个 broker，说白了就是服务器；</li>
<li><strong>Topic</strong>：producer 向 kafka 集群 push 的消息会被归于某一类别，即Topic，这本质上只是一个逻辑概念，面向的对象是 producer 和 consumer，producer 只需要关注将消息 push 到哪一个 Topic 中，而 consumer 只需要关心自己订阅了哪个 Topic；</li>
<li><strong>Partition</strong>：每一个 Topic 又被分为多个 Partitions，即物理分区；出于负载均衡的考虑，同一个 Topic 的 Partitions 分别存储于 Kafka 集群的多个 broker 上；而为了提高可靠性，这些 Partitions 可以由 Kafka 机制中的 replicas 来设置备份的数量；如上面的框架图所示，每个 partition 都存在两个备份；</li>
<li><strong>Consumer</strong>：消费者，从 Kafka 集群的 broker 中 pull 消息、消费消息；</li>
<li><strong>Consumer group</strong>：high-level consumer API 中，每个 consumer 都属于一个 consumer-group，每条消息只能被 consumer-group 中的一个 Consumer 消费，但可以被多个 consumer-group 消费；</li>
<li><strong>replicas</strong>：partition 的副本，保障 partition 的高可用；</li>
<li><strong>leader</strong>：replicas 中的一个角色， producer 和 consumer 只跟 leader 交互；</li>
<li><strong>follower</strong>：replicas 中的一个角色，从 leader 中复制数据，作为副本，一旦 leader 挂掉，会从它的 followers 中选举出一个新的 leader 继续提供服务；</li>
<li><strong>controller</strong>：Kafka 集群中的其中一个服务器，用来进行 leader election 以及 各种 failover；</li>
<li><strong>ZooKeeper</strong>：Kafka 通过 ZooKeeper 来存储集群的 meta 信息等，文中将详述。</li>
</ul>
<h4 id="1-1-Topic-amp-Partition"><a href="#1-1-Topic-amp-Partition" class="headerlink" title="1.1 Topic &amp; Partition"></a>1.1 Topic &amp; Partition</h4><p>一个 topic 可以认为是一类消息，每个 topic 将被分成多个 partition，每个 partition 在存储层面是 append log 文件。任何发布到此 partition 的消息都会被追加到log文件的尾部，每条消息在文件中的位置称为 offset（偏移量），offset 为一个 long 型的数字，它唯一标记一条消息。Kafka 机制中，producer push 来的消息是追加（append）到 partition 中的，这是一种顺序写磁盘的机制，效率远高于随机写内存，如下示意图：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937084.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<h4 id="1-2-Kafka-为什么要将-Topic-进行分区？"><a href="#1-2-Kafka-为什么要将-Topic-进行分区？" class="headerlink" title="1.2 Kafka 为什么要将 Topic 进行分区？"></a>1.2 Kafka 为什么要将 Topic 进行分区？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简而言之：负载均衡 + 水平扩展。</span><br></pre></td></tr></table></figure>
<p>前已述及，Topic 只是逻辑概念，面向的是 producer 和 consumer；而 Partition 则是物理概念。可以想象，如果 Topic 不进行分区，而将 Topic 内的消息存储于一个 broker，那么关于该 Topic 的所有读写请求都将由这一个 broker 处理，吞吐量很容易陷入瓶颈，这显然是不符合高吞吐量应用场景的。有了 Partition 概念以后，假设一个 Topic 被分为 10 个 Partitions，Kafka 会根据一定的算法将 10 个 Partition 尽可能均匀的分布到不同的 broker（服务器）上，当 producer 发布消息时，producer 客户端可以采用 <code>random</code>、<code>key-hash</code> 及 <code>轮询</code> 等算法选定目标 partition，若不指定，Kafka 也将根据一定算法将其置于某一分区上。Partiton 机制可以极大的提高吞吐量，并且使得系统具备良好的水平扩展能力。</p>
<p>在创建 topic 时可以在 <code>$KAFKA_HOME/config/server.properties</code> 中指定这个 partition 的数量（如下所示），当然可以在 topic 创建之后去修改 partition 的数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The default number of log partitions per topic. More partitions allow greater# parallelism for consumption, but this will also result in more files across# the brokers.num.partitions=3</span><br></pre></td></tr></table></figure>
<p>在发送一条消息时，可以指定这个消息的 key，producer 根据这个 key 和 partition 机制来判断这个消息发送到哪个partition。partition 机制可以通过指定 producer 的 partition.class 这一参数来指定（即支持自定义），该 class 必须实现 kafka.producer.Partitioner 接口。</p>
<p>有关 topic 与 partition 的更多细节，可以参考下面的“Kafka 文件存储机制”这一节。</p>
<h3 id="2-Kafka-高可靠性实现基础解读"><a href="#2-Kafka-高可靠性实现基础解读" class="headerlink" title="2. Kafka 高可靠性实现基础解读"></a>2. Kafka 高可靠性实现基础解读</h3><p>谈及可靠性，最常规、最有效的策略就是 “副本（replication）机制” ，Kafka 实现高可靠性同样采用了该策略。通过调节副本相关参数，可使 Kafka 在性能和可靠性之间取得平衡。本节先从 Kafka 文件存储机制入手，从最底层了解 Kafka 的存储细节，进而对消息的存储有个微观的认知。之后通过介绍 Kafka 的复制原理和同步方式来阐述宏观层面的概念。最后介绍 ISR，HW 和 leader 选举。</p>
<h4 id="2-1-Kafka-文件存储机制"><a href="#2-1-Kafka-文件存储机制" class="headerlink" title="2.1 Kafka 文件存储机制"></a>2.1 Kafka 文件存储机制</h4><p>Kafka 中消息是以 topic 进行分类的，生产者通过 topic 向 Kafka broker 发送消息，消费者通过 topic 读取数据。然而 topic 在物理层面又能以 partition 为分组，一个 topic 可以分成若干个 partition。事实上，partition 并不是最终的存储粒度，partition 还可以细分为 segment，一个 partition 物理上由多个 segment 组成，那么这些 segment 又是什么呢？</p>
<p>为了便于说明问题，假设这里只有一个 Kafka 集群，且这个集群只有一个 Kafka broker，即只有一台物理机。在这个 Kafka broker 中配置 <code>log.dirs=/tmp/kafka-logs</code>，以此来设置 Kafka 消息文件存储目录；与此同时，通过命令创建一个 topic：mytopic_test，partition 的数量配置为 4（创建 topic 的命令请见上一课）。之后，可以在 <code>/tmp/kafka-logs</code> 目录中可以看到生成了 4 个目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-0</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-1</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-2</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-3</span><br></pre></td></tr></table></figure>
<p>在 Kafka 文件存储中，同一个 topic 下有多个不同的 partition，每个 partiton 为一个目录，partition 的名称规则为：topic 名称 + 有序序号，第一个序号从 0 开始计，最大的序号为 partition 数量减 1，partition 是实际物理上的概念，而 topic 是逻辑上的概念。</p>
<p><strong>问题 1：为什么不能以 partition 作为存储单位？</strong></p>
<p>上面提到 partition 还可以细分为 segment，这个 segment 又是什么？如果就以 partition 为最小存储单位，可以想象，当 Kafka producer 不断发送消息，必然会引起 partition 文件的无限扩张，将对消息文件的维护以及已消费的消息的清理带来严重的影响，因此，需以 segment 为单位将 partition 进一步细分。每个 partition（目录）相当于一个巨型文件被平均分配到多个大小相等的 segment（段）数据文件中（每个 segment 文件中消息数量不一定相等）这种特性也方便 old segment 的删除，即方便已被消费的消息的清理，提高磁盘的利用率。每个 partition 只需要支持顺序读写就行，segment 的文件生命周期由服务端配置参数（log.segment.bytes，log.roll.{ms,hours} 等若干参数）决定。</p>
<p><strong>问题 2：segment 的工作原理是怎样的？</strong></p>
<p>segment 文件由两部分组成，分别为 “.index” 文件和 “.log” 文件，分别表示为 segment 索引文件和数据文件。这两个文件的命令规则为：partition 全局的第一个 segment 从 0 开始，后续每个 segment 文件名为上一个 segment 文件最后一条消息的 offset 值，数值大小为 64 位，20 位数字字符长度，没有数字用 0 填充，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000000000000000.index</span><br><span class="line">00000000000000000000.log</span><br><span class="line">00000000000000170410.index</span><br><span class="line">00000000000000170410.log</span><br><span class="line">00000000000000239430.index</span><br><span class="line">00000000000000239430.log</span><br></pre></td></tr></table></figure>
<p>以上面的 segment 文件为例，展示出 segment：00000000000000170410 的 “.index” 文件和 “.log” 文件的对应的关系，如下图：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937106.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>如上图，“.index” 索引文件存储大量的元数据，“.log” 数据文件存储大量的消息，索引文件中的元数据指向对应数据文件中 message 的物理偏移地址。其中以 “.index” 索引文件中的元数据 [3, 348] 为例，在 “.log” 数据文件表示第 3 个消息，即在全局 partition 中表示 170410+3=170413 个消息，该消息的物理偏移地址为 348。</p>
<p><strong>问题 3：如何从 partition 中通过 offset 查找 message 呢？</strong></p>
<p>以上图为例，读取 offset=170418 的消息，首先查找 segment 文件，其中 00000000000000000000.index 为最开始的文件，第二个文件为 00000000000000170410.index（起始偏移为 170410+1=170411），而第三个文件为 00000000000000239430.index（起始偏移为 239430+1=239431），所以这个 offset=170418 就落到了第二个文件之中。其它后续文件可以依次类推，以其偏移量命名并排列这些文件，然后根据二分查找法就可以快速定位到具体文件位置。其次根据 00000000000000170410.index 文件中的 [8,1325] 定位到 00000000000000170410.log 文件中的 1325 的位置进行读取。</p>
<p>要是读取 offset=170418 的消息，从 00000000000000170410.log 文件中的 1325 的位置进行读取，那么，如何确定何时读完本条消息呢？（否则就读到下一条消息的内容了）</p>
<p>这个问题由消息的物理结构解决，消息都具有固定的物理结构，包括：offset（8 Bytes）、消息体的大小（4 Bytes）、crc32（4 Bytes）、magic（1 Byte）、attributes（1 Byte）、key length（4 Bytes）、key（K Bytes）、payload（N Bytes）等等字段，可以确定一条消息的大小，即读取到哪里截止。</p>
<h4 id="2-2-复制原理和同步方式"><a href="#2-2-复制原理和同步方式" class="headerlink" title="2.2 复制原理和同步方式"></a>2.2 复制原理和同步方式</h4><p>Kafka 中 topic 的每个 partition 有一个预写式的日志文件，虽然 partition 可以继续细分为若干个 segment 文件，但是对于上层应用来说，仍然可以将 partition 看成最小的存储单元（一个有多个 segment 文件拼接的 “巨型” 文件），每个 partition 都由一些列有序的、不可变的消息组成，这些消息被连续的追加到 partition 中。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937116.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>上图中有两个新名词：HW 和 LEO。这里先介绍下 LEO，LogEndOffset 的缩写，表示每个 partition 的 log 最后一条 Message 的位置。HW 是 HighWatermark 的缩写，是指 consumer 能够看到的此 partition 的位置，这个涉及到多副本的概念，这里先提及一下，下文再详述。</p>
<p>言归正传，为了提高消息的可靠性，Kafka 每个 topic 的 partition 有 N 个副本（replicas），其中 N（大于等于 1）是 topic 的复制因子（replica fator）的个数。Kafka 通过多副本机制实现故障自动转移，当 Kafka 集群中出现 broker 失效时，副本机制可保证服务可用。对于任何一个 partition，它的 N 个 replicas 中，其中一个 replica 为 leader，其他都为 follower，leader 负责处理 partition 的所有读写请求，follower 则负责被动地去复制 leader 上的数据。如下图所示，Kafka 集群中有 4 个 broker，某 topic 有 3 个 partition，且复制因子即副本个数也为 3：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937131.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>如果 leader 所在的 broker 发生故障或宕机，对应 partition 将因无 leader 而不能处理客户端请求，这时副本的作用就体现出来了：一个新 leader 将从 follower 中被选举出来并继续处理客户端的请求。</p>
<p><strong>如何确保新选举出的 leader 是优选呢？</strong></p>
<p>一个 partition 有多个副本（replicas），为了提高可靠性，这些副本分散在不同的 broker 上，由于带宽、读写性能、网络延迟等因素，同一时刻，这些副本的状态通常是不一致的：即 followers 与 leader 的状态不一致。那么，如何保证新选举出的 leader 是优选呢？Kafka 机制中，leader 将负责维护和跟踪一个 ISR（In-Sync Replicas）列表，即同步副本队列，这个列表里面的副本与 leader 保持同步，状态一致。如果新的 leader 从 ISR 列表中的副本中选出，那么就可以保证新 leader 为优选。当然，这不是唯一的策略，下文将继续解读。</p>
<h4 id="2-3-同步副本-ISR"><a href="#2-3-同步副本-ISR" class="headerlink" title="2.3 同步副本 ISR"></a>2.3 同步副本 ISR</h4><p>上一节中讲到了同步副本队列 ISR（In-Sync Replicas）。虽然副本极大的增强了可用性，但是副本数量对 Kafka 的吞吐率有一定影响。默认情况下 Kafka 的 replica 数量为 1，即每个 partition 都只有唯一的 leader，无 follower，没有容灾能力。为了确保消息的可靠性，生产环境中，通常将其值（由 broker 的参数 offsets.topic.replication.factor 指定）大小设置为大于 1，比如 3。所有的副本（replicas）统称为 Assigned Replicas，即 AR。ISR 是 AR 中的一个子集，由 leader 维护 ISR 列表，follower 从 leader 同步数据有一些延迟（由参数 replica.lag.time.max.ms 设置超时阈值），超过阈值的 follower 将被剔除出 ISR， 存入 OSR（Outof-Sync Replicas）列表，新加入的 follower 也会先存放在 OSR 中。AR=ISR+OSR。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：ISR中包括：leader + 与leader保持同步的followers。</span><br></pre></td></tr></table></figure>
<p>上面一节还涉及到一个概念，即 HW。HW 俗称高水位，HighWatermark 的缩写，取一个 partition 对应的 ISR 中最小的 LEO 作为 HW，consumer 最多只能消费到 HW 所在的位置。另外每个 replica 都有 HW，leader 和 follower 各自负责更新自己的 HW 的状态。对于 leader 新写入的消息，consumer 不能立刻消费，leader 会等待该消息被所有 ISR 中的 replicas 同步后更新 HW，此时消息才能被 consumer 消费。这样就保证了如果 leader 所在的 broker 失效，该消息仍然可以从新选举的 leader 中获取。对于来自内部 broker 的读取请求，没有 HW 的限制。</p>
<p>下图详细的说明了当 producer 生产消息至 broker 后，ISR 以及 HW 和 LEO 的流转过程：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937149.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>由此可见，Kafka 的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的 follower 都复制完，这条消息才会被 commit，这种复制方式受限于复制最慢的 follower，会极大的影响吞吐率。而异步复制方式下，follower 异步的从 leader 复制数据，数据只要被 leader 写入 log 就被认为已经 commit，这种情况下如果 follower 都还没有复制完，落后于 leader 时，突然 leader 宕机，则会丢失数据，降低可靠性。而 Kafka 使用 ISR 的策略则在可靠性和吞吐率方面取得了较好的平衡。</p>
<p>Kafka 的 ISR 的管理最终都会反馈到 ZooKeeper 节点上，具体位置为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/brokers/topics/[topic]/partitions/[partition]/state</span><br></pre></td></tr></table></figure>
<p>目前，有两个地方会对这个 ZooKeeper 的节点进行维护。</p>
<ol>
<li>Controller 来维护：Kafka 集群中的其中一个 Broker 会被选举为 Controller，主要负责 Partition 管理和副本状态管理，也会执行类似于重分配 partition 之类的管理任务。在符合某些特定条件下，Controller 下的 LeaderSelector 会选举新的 leader，ISR 和新的 <code>leader_epoch</code> 及 <code>controller_epoch</code> 写入 ZooKeeper 的相关节点中。同时发起 LeaderAndIsrRequest 通知所有的 replicas。</li>
<li>leader 来维护：leader 有单独的线程定期检测 ISR 中 follower 是否脱离 ISR，如果发现 ISR 变化，则会将新的 ISR 的信息返回到 ZooKeeper 的相关节点中。</li>
</ol>
<h4 id="2-4-数据可靠性和持久性保证"><a href="#2-4-数据可靠性和持久性保证" class="headerlink" title="2.4 数据可靠性和持久性保证"></a>2.4 数据可靠性和持久性保证</h4><p>当 producer 向 leader 发送数据时，可以通过 request.required.acks 参数来设置数据可靠性的级别：</p>
<p><strong>1. request.required.acks = 1</strong></p>
<p>这是默认情况，即：producer 发送数据到 leader，leader 写本地日志成功，返回客户端成功；此时 ISR 中的其它副本还没有来得及拉取该消息，如果此时 leader 宕机了，那么此次发送的消息就会丢失。</p>
<p><strong>2. request.required.acks = 0</strong></p>
<p>producer 不停向leader发送数据，而不需要 leader 反馈成功消息，这种情况下数据传输效率最高，但是数据可靠性确是最低的。可能在发送过程中丢失数据，可能在 leader 宕机时丢失数据。</p>
<p><strong>3. request.required.acks = -1（all）</strong></p>
<p>producer 发送数据给 leader，leader 收到数据后要等到 ISR 列表中的所有副本都同步数据完成后（强一致性），才向生产者返回成功消息，如果一直收不到成功消息，则认为发送数据失败会自动重发数据。这是可靠性最高的方案，当然，性能也会受到一定影响。</p>
<p><strong>注意：参数 min.insync.replicas</strong></p>
<p>如果要提高数据的可靠性，在设置 request.required.acks=-1 的同时，还需参数 min.insync.replicas 配合，如此才能发挥最大的功效。min.insync.replicas 这个参数用于设定 ISR 中的最小副本数，默认值为1，当且仅当 request.required.acks 参数设置为-1时，此参数才生效。当 ISR 中的副本数少于 min.insync.replicas 配置的数量时，客户端会返回异常：<code>org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required</code>。不难理解，如果 min.insync.replicas 设置为 2，当 ISR 中实际副本数为 1 时（只有leader），将无法保证可靠性，此时拒绝客户端的写请求以防止消息丢失。</p>
<h4 id="2-5-深入解读-HW-机制"><a href="#2-5-深入解读-HW-机制" class="headerlink" title="2.5 深入解读 HW 机制"></a>2.5 深入解读 HW 机制</h4><p>考虑这样一种场景：acks=-1，部分 ISR 副本完成同步，此时leader挂掉，如下图所示：follower1 同步了消息 4、5，follower2 同步了消息 4，与此同时 follower2 被选举为 leader，那么此时 follower1 中的多出的消息 5 该做如何处理呢？</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937156.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>这里就需要 HW 的协同配合了。如前所述，一个 partition 中的 ISR 列表中，leader 的 HW 是所有 ISR 列表里副本中最小的那个的 LEO。类似于木桶原理，水位取决于最低那块短板。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937175.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>如上图，某个 topic 的某 partition 有三个副本，分别为 A、B、C。A 作为 leader 肯定是 LEO 最高，B 紧随其后，C 机器由于配置比较低，网络比较差，故而同步最慢。这个时候 A 机器宕机，这时候如果 B 成为 leader，假如没有 HW，在 A 重新恢复之后会做同步（makeFollower) 操作，在宕机时 log 文件之后直接做追加操作，而假如 B 的 LEO 已经达到了 A 的 LEO，会产生数据不一致的情况，所以使用 HW 来避免这种情况。A 在做同步操作的时候，先将 log 文件截断到之前自己的 HW 的位置，即 3，之后再从 B 中拉取消息进行同步。</p>
<p>如果失败的 follower 恢复过来，它首先将自己的 log 文件截断到上次 checkpointed 时刻的 HW 的位置，之后再从 leader 中同步消息。leader 挂掉会重新选举，新的 leader 会发送 “指令” 让其余的 follower 截断至自身的 HW 的位置然后再拉取新的消息。</p>
<p>当 ISR 中的个副本的 LEO 不一致时，如果此时 leader 挂掉，选举新的 leader 时并不是按照 LEO 的高低进行选举，而是按照 ISR 中的顺序选举。</p>
<h4 id="2-6-Leader-选举"><a href="#2-6-Leader-选举" class="headerlink" title="2.6 Leader 选举"></a>2.6 Leader 选举</h4><p>为了保证可靠性，对于任意一条消息，只有它被 ISR 中的所有 follower 都从 leader 复制过去才会被认为已提交，并返回信息给 producer。如此，可以避免因部分数据被写进 leader，而尚未被任何 follower 复制就宕机的情况下而造成数据丢失。对于 producer 而言，它可以选择是否等待消息 commit，这可以通过参数 request.required.acks 来设置。这种机制可以确保：只要 ISR 中有一个或者以上的 follower，一条被 commit 的消息就不会丢失。</p>
<p><strong>问题 1：如何在保证可靠性的前提下避免吞吐量下降？</strong></p>
<p>有一个很重要的问题是当 leader 宕机了，怎样在 follower 中选举出新的 leader，因为 follower 可能落后很多或者直接 crash 了，所以必须确保选择 “最新” 的 follower 作为新的 leader。一个基本的原则就是，如果 leader 挂掉，新的 leader 必须拥有原来的 leader 已经 commit 的所有消息，这不就是 ISR 中副本的特征吗？</p>
<p>但是，存在一个问题，ISR 列表维持多大的规模合适呢？换言之，leader 在一个消息被 commit 前需要等待多少个 follower 确认呢？等待 follower 的数量越多，与 leader 保持同步的 follower 就越多，可靠性就越高，但这也会造成吞吐率的下降。</p>
<p><strong>少数服从多数的选举原则</strong></p>
<p>一种常用的选举 leader 的策略是 “少数服从多数” ，不过，Kafka 并不是采用这种方式。这种模式下，如果有 2f+1 个副本，那么在 commit 之前必须保证有 f+1 个 replica 复制完消息，同时为了保证能正确选举出新的 leader，失败的副本数不能超过 f 个。这种方式有个很大的优势，系统的延迟取决于最快的几台机器，也就是说比如副本数为 3，那么延迟就取决于最快的那个 follower 而不是最慢的那个。</p>
<p>“少数服从多数” 的策略也有一些劣势，为了保证 leader 选举的正常进行，它所能容忍的失败的 follower 数比较少，如果要容忍 1 个 follower 挂掉，那么至少要 3 个以上的副本，如果要容忍 2 个 follower 挂掉，必须要有 5 个以上的副本。也就是说，在生产环境下为了保证较高的容错率，必须要有大量的副本，而大量的副本又会在大数据量下导致性能的急剧下降。这种算法更多用在 ZooKeeper 这种共享集群配置的系统中，而很少在需要大量数据的系统中使用。</p>
<p><strong>Kafka 选举 leader 的策略是怎样的？</strong></p>
<p>实际上，leader 选举的算法非常多，比如 ZooKeeper 的 Zab、Raft 以及 Viewstamped Replication。而 Kafka 所使用的 leader 选举算法更像是微软的 PacificA 算法。</p>
<p>Kafka 在 ZooKeeper 中为每一个 partition 动态的维护了一个 ISR，这个 ISR 里的所有 replica 都与 leader 保持同步，只有 ISR 里的成员才能有被选为 leader 的可能（通过参数配置：<code>unclean.leader.election.enable=false</code>）。在这种模式下，对于 f+1 个副本，一个 Kafka topic 能在保证不丢失已经 commit 消息的前提下容忍 f 个副本的失败，在大多数使用场景下，这种模式是十分有利的。事实上，对于任意一条消息，只有它被 ISR 中的所有 follower 都从 leader 复制过去才会被认为已提交，并返回信息给 producer，从而保证可靠性。但与 “少数服从多数” 策略不同的是，Kafka ISR 列表中副本的数量不需要超过副本总数的一半，即不需要满足 “多数派” 原则，通常，ISR 列表副本数大于等于 2 即可，如此，便在可靠性和吞吐量方面取得平衡。</p>
<p><strong>极端情况下的 leader 选举策略</strong></p>
<p>前已述及，当 ISR 中至少有一个 follower 时（ISR 包括 leader），Kafka 可以确保已经 commit 的消息不丢失，但如果某一个 partition 的所有 replica 都挂了，自然就无法保证数据不丢失了。这种情况下如何进行 leader 选举呢？通常有两种方案：</p>
<ol>
<li>等待 ISR 中任意一个 replica 恢复过来，并且选它作为 leader；</li>
<li>选择第一个恢复过来的 replica（并不一定是在 ISR 中）作为leader。</li>
</ol>
<p>如何选择呢？这就需要在可用性和一致性当中作出抉择。如果一定要等待 ISR 中的 replica 恢复过来，不可用的时间就可能会相对较长。而且如果 ISR 中所有的 replica 都无法恢复了，或者数据丢失了，这个 partition 将永远不可用。</p>
<p>选择第一个恢复过来的 replica 作为 leader，如果这个 replica 不是 ISR 中的 replica，那么，它可能并不具备所有已经 commit 的消息，从而造成消息丢失。默认情况下，Kafka 采用第二种策略，即 <code>unclean.leader.election.enable=true</code>，也可以将此参数设置为 false 来启用第一种策略。</p>
<p><code>unclean.leader.election.enable</code> 这个参数对于 leader 的选举、系统的可用性以及数据的可靠性都有至关重要的影响。生产环境中应慎重权衡。</p>
<h3 id="3-Kafka-架构中-ZooKeeper-以怎样的形式存在？"><a href="#3-Kafka-架构中-ZooKeeper-以怎样的形式存在？" class="headerlink" title="3. Kafka 架构中 ZooKeeper 以怎样的形式存在？"></a>3. Kafka 架构中 ZooKeeper 以怎样的形式存在？</h3><p>ZooKeeper 是一个分布式的、开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现。分布式应用程序可以基于它实现统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。在基于 Kafka 的分布式消息队列中，ZooKeeper 的作用有：broker 注册、topic 注册、producer 和 consumer 负载均衡、维护 partition 与 consumer 的关系、记录消息消费的进度以及 consumer 注册等。</p>
<h4 id="3-1-broker-在-ZooKeeper-中的注册"><a href="#3-1-broker-在-ZooKeeper-中的注册" class="headerlink" title="3.1 broker 在 ZooKeeper 中的注册"></a>3.1 broker 在 ZooKeeper 中的注册</h4><ul>
<li>为了记录 broker 的注册信息，在 ZooKeeper 上，专门创建了属于 Kafka 的一个节点，其路径为 /brokers；</li>
<li>Kafka 的每个 broker 启动时，都会到 ZooKeeper 中进行注册，告诉 ZooKeeper 其 broker.id，在整个集群中，broker.id 应该全局唯一，并在 ZooKeeper 上创建其属于自己的节点，其节点路径为 <code>/brokers/ids/{broker.id}</code>；</li>
<li>创建完节点后，Kafka 会将该 broker 的 broker.name 及端口号记录到该节点；</li>
<li>另外，该 broker 节点属性为临时节点，当 broker 会话失效时，ZooKeeper 会删除该节点，这样，我们就可以很方便的监控到broker 节点的变化，及时调整负载均衡等。</li>
</ul>
<h4 id="3-2-Topic-在-ZooKeeper-中的注册"><a href="#3-2-Topic-在-ZooKeeper-中的注册" class="headerlink" title="3.2 Topic 在 ZooKeeper 中的注册"></a>3.2 Topic 在 ZooKeeper 中的注册</h4><p>在 Kafka 中，所有 topic 与 broker 的对应关系都由 ZooKeeper 进行维护，在 ZooKeeper 中，建立专门的节点来记录这些信息，其节点路径为 <code>/brokers/topics/{topic_name}</code>。前面说过，为了保障数据的可靠性，每个 Topic 的 Partitions 实际上是存在备份的，并且备份的数量由 Kafka 机制中的 replicas 来控制。那么问题来了：如下图所示，假设某个 TopicA 被分为 2 个 Partitions，并且存在两个备份，由于这 2 个 Partitions（1-2）被分布在不同的 broker 上，同一个 partiton 与其备份不能（也不应该）存储于同一个 broker 上。以 Partition1 为例，假设它被存储于 broker2，其对应的备份分别存储于 broker1 和 broker4，有了备份，可靠性得到保障，但数据一致性却是个问题。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937185.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>为了保障数据的一致性，ZooKeeper 机制得以引入。基于 ZooKeeper，Kafka 为每一个 partition 找一个节点作为 leader，其余备份作为 follower；接续上图的例子，就 TopicA 的 partition1 而言，如果位于 broker2（Kafka 节点）上的 partition1 为 leader，那么位于 broker1 和 broker4 上面的 partition1 就充当 follower，则有下图：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937191.png" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>基于上图的架构，当 producer push 的消息写入 partition（分区) 时，作为 leader 的 broker（Kafka 节点） 会将消息写入自己的分区，同时还会将此消息复制到各个 follower，实现同步。如果，某个follower 挂掉，leader 会再找一个替代并同步消息；如果 leader 挂了，follower 们会选举出一个新的 leader 替代，继续业务，这些都是由 ZooKeeper 完成的。</p>
<h4 id="3-3-consumer-在-ZooKeeper-中的注册"><a href="#3-3-consumer-在-ZooKeeper-中的注册" class="headerlink" title="3.3 consumer 在 ZooKeeper 中的注册"></a>3.3 consumer 在 ZooKeeper 中的注册</h4><p><strong>注册新的消费者分组</strong></p>
<p>当新的消费者组注册到 ZooKeeper 中时，ZooKeeper 会创建专用的节点来保存相关信息，其节点路径为 <code>ls/consumers/{group_id}</code>，其节点下有三个子节点，分别为 <code>[ids, owners, offsets]</code>。</p>
<ul>
<li>ids 节点：记录该消费组中当前正在消费的消费者；</li>
<li>owners 节点：记录该消费组消费的 topic 信息；</li>
<li>offsets 节点：记录每个 topic 的每个分区的 offset。</li>
</ul>
<p><strong>注册新的消费者</strong></p>
<p>当新的消费者注册到 Kafka 中时，会在 <code>/consumers/{group_id}/ids</code> 节点下创建临时子节点，并记录相关信息。</p>
<p><strong>监听消费者分组中消费者的变化</strong></p>
<p>每个消费者都要关注其所属消费者组中消费者数目的变化，即监听 <code>/consumers/{group_id}/ids</code> 下子节点的变化。一单发现消费者新增或减少，就会触发消费者的负载均衡。</p>
<h4 id="3-4-Producers-负载均衡"><a href="#3-4-Producers-负载均衡" class="headerlink" title="3.4 Producers 负载均衡"></a>3.4 Producers 负载均衡</h4><p>对于同一个 topic 的不同 partition，Kafka会尽力将这些 partition 分布到不同的 broker 服务器上，这种均衡策略实际上是基于 ZooKeeper 实现的。在一个 broker 启动时，会首先完成 broker 的注册过程，并注册一些诸如 “有哪些可订阅的 topic” 之类的元数据信息。producers 启动后也要到 ZooKeeper 下注册，创建一个临时节点来监听 broker 服务器列表的变化。由于在 ZooKeeper 下 broker 创建的也是临时节点，当 brokers 发生变化时，producers 可以得到相关的通知，从改变自己的 broker list。其它的诸如 topic 的变化以及broker 和 topic 的关系变化，也是通过 ZooKeeper 的这种 Watcher 监听实现的。</p>
<p>在生产中，必须指定 topic；但是对于 partition，有两种指定方式：</p>
<ul>
<li>明确指定 partition(0-N)，则数据被发送到指定 partition；</li>
<li>设置为 <code>RD_KAFKA_PARTITION_UA</code>，则 Kafka 会回调 partitioner 进行均衡选取，partitioner 方法需要自己实现。可以轮询或者传入 key 进行 hash。未实现则采用默认的随机方法 <code>rd_kafka_msg_partitioner_random</code> 随机选择。</li>
</ul>
<h4 id="3-5-Consumer-负载均衡"><a href="#3-5-Consumer-负载均衡" class="headerlink" title="3.5 Consumer 负载均衡"></a>3.5 Consumer 负载均衡</h4><p>Kafka 保证同一 consumer group 中只有一个 consumer 可消费某条消息，实际上，Kafka 保证的是稳定状态下每一个 consumer 实例只会消费某一个或多个特定的数据，而某个 partition 的数据只会被某一个特定的 consumer 实例所消费。这样设计的劣势是无法让同一个 consumer group 里的 consumer 均匀消费数据，优势是每个 consumer 不用都跟大量的 broker 通信，减少通信开销，同时也降低了分配难度，实现也更简单。另外，因为同一个 partition 里的数据是有序的，这种设计可以保证每个 partition 里的数据也是有序被消费。</p>
<p><strong>consumer 数量不等于 partition 数量</strong></p>
<p>如果某 consumer group 中 consumer 数量少于 partition 数量，则至少有一个 consumer 会消费多个 partition 的数据；如果 consumer 的数量与 partition 数量相同，则正好一个 consumer 消费一个 partition 的数据，而如果 consumer 的数量多于 partition 的数量时，会有部分 consumer 无法消费该 topic 下任何一条消息。</p>
<p><strong>借助 ZooKeeper 实现负载均衡</strong></p>
<p>关于负载均衡，对于某些低级别的 API，consumer 消费时必须指定 topic 和 partition，这显然不是一种友好的均衡策略。基于高级别的 API，consumer 消费时只需制定 topic，借助 ZooKeeper 可以根据 partition 的数量和 consumer 的数量做到均衡的动态配置。</p>
<p>consumers 在启动时会到 ZooKeeper 下以自己的 conusmer-id 创建临时节点 <code>/consumer/[group-id]/ids/[conusmer-id]</code>，并对 <code>/consumer/[group-id]/ids</code> 注册监听事件，当消费者发生变化时，同一 group 的其余消费者会得到通知。当然，消费者还要监听 broker 列表的变化。librdkafka 通常会将 partition 进行排序后，根据消费者列表，进行轮流的分配。</p>
<h4 id="3-6-记录消费进度-Offset"><a href="#3-6-记录消费进度-Offset" class="headerlink" title="3.6 记录消费进度 Offset"></a>3.6 记录消费进度 Offset</h4><p>在 consumer 对指定消息 partition 的消息进行消费的过程中，需要定时地将 partition 消息的消费进度 Offset 记录到 ZooKeeper上，以便在该 consumer 进行重启或者其它 consumer 重新接管该消息分区的消息消费权后，能够从之前的进度开始继续进行消息消费。Offset 在 ZooKeeper 中由一个专门节点进行记录，其节点路径为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#节点内容就是Offset的值。/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</span><br></pre></td></tr></table></figure>
<p>PS：Kafka 已推荐将 consumer 的 Offset 信息保存在 Kafka 内部的 topic 中，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__consumer_offsets(/brokers/topics/__consumer_offsets)</span><br></pre></td></tr></table></figure>
<p>并且默认提供了 <code>kafka_consumer_groups.sh</code> 脚本供用户查看consumer 信息（命令：<code>sh kafka-consumer-groups.sh –bootstrap-server * –describe –group *</code>）。在当前版本中，offset 存储方式要么存储在本地文件中，要么存储在 broker 端，具体的存储方式取决 <code>offset.store.method</code> 的配置，默认是存储在 broker 端。</p>
<h4 id="3-7-记录-Partition-与-Consumer-的关系"><a href="#3-7-记录-Partition-与-Consumer-的关系" class="headerlink" title="3.7 记录 Partition 与 Consumer 的关系"></a>3.7 记录 Partition 与 Consumer 的关系</h4><p>consumer group 下有多个 consumer（消费者），对于每个消费者组（consumer group），Kafka都会为其分配一个全局唯一的 group ID，group 内部的所有消费者共享该 ID。订阅的 topic 下的每个分区只能分配给某个 group 下的一个consumer（当然该分区还可以被分配给其它 group）。同时，Kafka 为每个消费者分配一个 consumer ID，通常采用 <code>hostname:UUID</code> 形式表示。</p>
<p>在Kafka中，规定了每个 partition 只能被同组的一个消费者进行消费，因此，需要在 ZooKeeper 上记录下 partition 与 consumer 之间的关系，每个 consumer 一旦确定了对一个 partition 的消费权力，需要将其 consumer ID 写入到 ZooKeeper 对应消息分区的临时节点上，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]</span><br></pre></td></tr></table></figure>
<p>其中，[<code>broker_id-partition_id</code>] 就是一个消息分区的标识，节点内容就是该消息分区 消费者的 consumer ID。</p>
<h3 id="4-全程解析（Producer-kafka-consumer）"><a href="#4-全程解析（Producer-kafka-consumer）" class="headerlink" title="4. 全程解析（Producer-kafka-consumer）"></a>4. 全程解析（Producer-kafka-consumer）</h3><h4 id="4-1-producer-发布消息"><a href="#4-1-producer-发布消息" class="headerlink" title="4.1 producer 发布消息"></a>4.1 producer 发布消息</h4><p>producer 采用 push 模式将消息发布到 broker，每条消息都被 append 到 patition 中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障 kafka 吞吐率）。producer 发送消息到 broker 时，会根据分区算法选择将其存储到哪一个 partition。</p>
<p><strong>其路由机制为：</strong></p>
<ol>
<li>指定了 patition，则直接使用；</li>
<li>未指定 patition 但指定 key，通过对 key 进行 hash 选出一个 patition；</li>
<li>patition 和 key 都未指定，使用轮询选出一个 patition。</li>
</ol>
<p><strong>写入流程：</strong></p>
<ol>
<li>producer 先从 ZooKeeper 的 “/brokers/…/state” 节点找到该 partition 的leader；</li>
<li>producer 将消息发送给该 leader；</li>
<li>leader 将消息写入本地 log；</li>
<li>followers 从 leader pull 消息，写入本地 log 后 leader 发送 ACK；</li>
<li>leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset） 并向 producer 发送 ACK；</li>
</ol>
<h4 id="4-2-Broker-存储消息"><a href="#4-2-Broker-存储消息" class="headerlink" title="4.2 Broker 存储消息"></a>4.2 Broker 存储消息</h4><p>物理上把 topic 分成一个或多个 patition，每个 patition 物理上对应一个文件夹（该文件夹存储该 patition 的所有消息和索引文件）</p>
<h4 id="4-3-Consumer-消费消息"><a href="#4-3-Consumer-消费消息" class="headerlink" title="4.3 Consumer 消费消息"></a>4.3 Consumer 消费消息</h4><p>high-level consumer API 提供了 consumer group 的语义，一个消息只能被 group 内的一个 consumer 所消费，且 consumer 消费消息时不关注 offset，最后一个 offset 由 ZooKeeper 保存（下次消费时，该group 中的consumer将从offset记录的位置开始消费）。</p>
<p><strong>注意：</strong></p>
<ol>
<li>如果消费线程大于 patition 数量，则有些线程将收不到消息；</li>
<li>如果 patition 数量大于消费线程数，则有些线程多收到多个 patition 的消息；</li>
<li>如果一个线程消费多个 patition，则无法保证你收到的消息的顺序，而一个 patition 内的消息是有序的。</li>
</ol>
<p><strong>consumer 采用 pull 模式从 broker 中读取数据。</strong></p>
<p>push 模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p>
<p>对于 Kafka 而言，pull 模式更合适，它可简化 broker 的设计，consumer 可自主控制消费消息的速率，同时 consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>ZooKeeper</tag>
        <tag>分布式消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap详解</title>
    <url>/2020/09/24/java/HashMap%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>HashMap是基于哈希表实现的,每一个元素是一个key-value对,其内部通过单链表解决冲突问题,容量不足(超过了阀值)时,同样会自动增长.</p>
<p>HashMap是非线程安全的,只适用于单线程环境,多线程环境可以采用并发包下的concurrentHashMap</p>
<p>HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆</p>
<p>HashMap是基于哈希表的Map接口的非同步实现.此实现提供所有可选的映射操作,并允许使用null值和null键.此类不保证映射的顺序,特别是它不保证该顺序恒久不变.</p>
<p>Java8中又对此类底层实现进行了优化，比如引入了红黑树的结构以解决哈希碰撞</p>
<a id="more"></a>
<h3 id="2-HashMap的数据结构"><a href="#2-HashMap的数据结构" class="headerlink" title="2 HashMap的数据结构"></a>2 HashMap的数据结构</h3><p>在Java中,最基本的结构就是两种,一个是数组,另外一个是模拟指针(引用),所有的数据结构都可以用这两个基本结构来构造,HashMap也不例外. HashMap实际上是一个”链表散列”的数据结构,即数组和链表的结合体.<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114618" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>HashMap的主结构类似于一个数组,添加值时通过key确定储存位置.<br>每个位置是一个Entry的数据结构,该结构可组成链表.<br>当发生冲突时,相同hash值的键值对会组成链表.<br>这种数组+链表的组合形式大部分情况下都能有不错的性能效果,Java6、7就是这样设计的. 然而,在极端情况下,一组（比如经过精心设计的）键值对都发生了冲突，这时的哈希结构就会退化成一个链表，使HashMap性能急剧下降.</p>
<p>所以在Java8中,HashMap的结构实现变为数组+链表+红黑树<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114625.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>可以看出,HashMap底层就是一个数组结构<br>数组中的每一项又是一个链表<br>当新建一个HashMap时,就会初始化一个数组.</p>
<h3 id="3-三大集合与迭代子"><a href="#3-三大集合与迭代子" class="headerlink" title="3 三大集合与迭代子"></a>3 三大集合与迭代子</h3><p>HashMap使用三大集合和三种迭代子来轮询其Key、Value和Entry对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            map.put(i, <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;(<span class="keyword">char</span>) (<span class="string">'A'</span>+ i)&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"======keySet======="</span>);</span><br><span class="line">        Set set = map.keySet();</span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"======values======="</span>);</span><br><span class="line">        Collection values = map.values();</span><br><span class="line">        Iterator stringIterator=values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (stringIterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(stringIterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"======entrySet======="</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4 源码分析"></a>4 源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量16,且实际容量是2的整数幂 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//最大容量(传入容量过大将被这个值替换)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认加载因子为0.75(当表达到3/4满时,才会再散列),这个因子在时间和空间代价之间达到了平衡.更高的因子可以降低表所需的空间,但是会增加查找代价,而查找是最频繁操作</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">//桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 &gt;= 8时，则将链表转换成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">   <span class="comment">// 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt;= 6时，则将 红黑树转换成链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">   <span class="comment">//最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）</span></span><br></pre></td></tr></table></figure>
<p>因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要<br>链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短</p>
<p>还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换<br>假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了避免扩容/树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line">    <span class="comment">// 小于该值时使用的是扩容哦!!!</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储数据的Node数组,长度是2的幂.    </span></span><br><span class="line">    <span class="comment">// HashMap采用链表法解决冲突，每一个Node本质上是一个单向链表 </span></span><br><span class="line">    <span class="comment">//HashMap底层存储的数据结构,是一个Node数组.上面得知Node类为元素维护了一个单向链表.至此,HashMap存储的数据结构也就很清晰了:维护了一个数组,每个数组又维护了一个单向链表.之所以这么设计,考虑到遇到哈希冲突的时候,同index的value值就用单向链表来维护</span></span><br><span class="line">    <span class="comment">//与 JDK 1.7 的对比（Entry类），仅仅只是换了名字</span></span><br><span class="line">    <span class="keyword">transient</span> Node[] table;</span><br><span class="line">    <span class="comment">// HashMap的底层数组中已用槽的数量 </span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） </span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子实际大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    <span class="comment">// HashMap被改变的次数 </span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 指定“容量大小”和“加载因子”的构造函数,是最基础的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY                                       </span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//负载因子须大于0</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="comment">// 设置"负载因子"                                        </span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 设置"HashMap阈值",当HashMap中存储数据的数量达到threshold时,就需将HashMap的容量加倍    </span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的tableSizeFor有何用?<br>tableSizeFor方法保证函数返回值是大于等于给定参数initialCapacity最小的2的幂次方的数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> (n = MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">a |= b 等同于 a = a|b</span><br></pre></td></tr></table></figure>
<p>逐行分析</p>
<ul>
<li>int n = cap - 1<br>给定的cap 减 1,为了避免参数cap本来就是2的幂次方,这样一来,经过后续操作，cap将会变成2 * cap,是不符合我们预期的</li>
<li>n |= n &gt;&gt;&gt; 1<br>n &gt;&gt;&gt; 1 : n无符号右移1位,即n二进制最高位的1右移一位<br>n | (n &gt;&gt;&gt; 1) 导致 n二进制的高2位值为1<br>目前n的高1~2位均为1</li>
<li>n |= n &gt;&gt;&gt; 2<br>n继续无符号右移2位<br>n | (n &gt;&gt;&gt; 2) 导致n二进制表示的高34位经过运算值均为1<br>目前n的高14位均为1</li>
<li>n |= n &gt;&gt;&gt; 4<br>n继续无符号右移4位<br>n | (n &gt;&gt;&gt; 4) 导致n二进制表示的高58位经过运算值均为1<br>目前n的高18位均为1</li>
<li>n |= n &gt;&gt;&gt; 8<br>n继续无符号右移8位<br>n | (n &gt;&gt;&gt; 8) 导致n二进制表示的高916位经过运算值均为1<br>目前n的高116位均为1</li>
</ul>
<p>可以看出,无论给定cap(cap &lt; MAXIMUM_CAPACITY )的值是多少,经过以上运算,其值的二进制所有位都会是1.再将其加1,这时候这个值一定是2的幂次方.<br>当然如果经过运算值大于MAXIMUM_CAPACITY,直接选用MAXIMUM_CAPACITY.</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114638" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>至此tableSizeFor如何保证cap为2的幂次方已经显而易见了,那么问题来了</p>
<h4 id="4-1-为什么cap要保持为2的幂次方？"><a href="#4-1-为什么cap要保持为2的幂次方？" class="headerlink" title="4.1 为什么cap要保持为2的幂次方？"></a>4.1 为什么cap要保持为2的幂次方？</h4><p>主要与HashMap中的数据存储有关.</p>
<p>在Java8中,HashMap中key的Hash值由Hash(key)方法计得<br><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114644.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>HashMap中存储数据table的index是由key的Hash值决定的.<br>在HashMap存储数据时,我们期望数据能均匀分布,以防止哈希冲突.<br>自然而然我们就会想到去用%取余操作来实现我们这一构想</p>
<p><em>取余(%)操作 : 如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作.</em></p>
<p>这也就解释了为什么一定要求cap要为2的幂次方.再来看看table的index的计算规则：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114650.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>等价于:<br><code>index = e.hash % newCap</code></p>
<p>采用二进制位操作&amp;,相对于%,能够提高运算效率,这就是cap的值被要求为2幂次的原因</p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114658.jpg)![img" title="" class="">
                <p>img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114658.jpg)![img</p>
            </figure>
<h4 id="4-2-Node类"><a href="#4-2-Node类" class="headerlink" title="4.2 Node类"></a>4.2 Node类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry e = (Map.Entry)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Node 类是HashMap中的静态内部类,实现Map.Entry接口.定义了key键、value值、next节点,也就是说元素之间构成了单向链表.</p>
<h4 id="4-3-TreeNode"><a href="#4-3-TreeNode" class="headerlink" title="4.3 TreeNode"></a>4.3 TreeNode</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span> </span>&#123;</span><br><span class="line">        TreeNode parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node next) &#123;&#125;</span><br><span class="line">        <span class="comment">// 返回当前节点的根节点  </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode <span class="title">root</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">for</span> (TreeNode r = <span class="keyword">this</span>, p;;) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)  </span><br><span class="line">                <span class="keyword">return</span> r;  </span><br><span class="line">            r = p;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>红黑树结构包含前、后、左、右节点，以及标志是否为红黑树的字段<br>此结构是Java8新加的</p>
<h4 id="4-4-hash方法"><a href="#4-4-hash方法" class="headerlink" title="4.4 hash方法"></a>4.4 hash方法</h4><p>Java 8中的散列值优化函数<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>只做一次16位右位移异或<br>key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值</p>
<p>理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int范围大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。<br>但问题是一个40亿长度的数组，内存是放不下的.HashMap扩容之前的数组初始大小才16,所以这个散列值是不能直接拿来用的.<br>用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标<br>源码中模运算就是把散列值和数组长度做一个”与”操作，<br><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114709.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>这也正好解释了为什么HashMap的数组长度要取2的整次幂<br>因为这样（数组长度-1）正好相当于一个“低位掩码”<br>“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问</p>
<p>以初始长度16为例，16-1=15<br>2进制表示是00000000 00000000 00001111<br>和某散列值做“与”操作如下，结果就是截取了最低的四位值<br><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114729.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>但这时候问题就来了,这样就算我的散列值分布再松散,要是只取最后几位的话,碰撞也会很严重</p>
<p>这时候“扰动函数”的价值就体现出来了<br><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114736.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>右位移16位，正好是32位一半，自己的高半区和低半区做异或，就是为了混合原始hashCode的高位和低位，以此来加大低位的随机性<br>而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<p>index的运算规则是<br><code>e.hash &amp; (newCap - 1)</code><br>newCap是2的幂,所以newCap - 1的高位全0</p>
<p>若e.hash值只用自身的hashcode,index只会和e.hash的低位做&amp;操作.这样一来,index的值就只有低位参与运算,高位毫无存在感,从而会带来哈希冲突的风险<br>所以在计算key的hashCode时,用其自身hashCode与其低16位做异或操作<br>这也就让高位参与到index的计算中来了,即降低了哈希冲突的风险又不会带来太大的性能问题</p>
<h4 id="4-5-Put方法"><a href="#4-5-Put方法" class="headerlink" title="4.5 Put方法"></a>4.5 Put方法</h4><figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114759.jpg" alt="img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114744.jpg)![img" title="" class="">
                <p>img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114744.jpg)![img</p>
            </figure>
<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容</p>
<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③</p>
<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals</p>
<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤</p>
<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可</p>
<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，执行resize()扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node[] tab; Node p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 步骤① tab为空则调用resize()初始化创建</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)         </span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 步骤② 计算index,并对null做处理  </span></span><br><span class="line">        <span class="comment">//tab[i = (n - 1) &amp; hash对应下标的第一个节点   </span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 无哈希冲突的情况下,将value直接封装为Node并赋值</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node e; K k;</span><br><span class="line">            <span class="comment">// 步骤③ 节点的key相同,直接覆盖节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 步骤④ 判断该链为红黑树    </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 <span class="comment">// p是红黑树类型，则调用putTreeVal方式赋值</span></span><br><span class="line">                e = ((TreeNode)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 步骤⑤ p非红黑树类型,该链为链表    </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// index 相同的情况下</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果p的next为空,将新的value值添加至链表后面</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                            <span class="comment">// 如果链表长度大于8,链表转化为红黑树,执行插入</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// key相同则跳出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;  ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//就是移动指针方便继续取 p.next</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">//根据规则选择是否覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 步骤⑥:超过最大容量,就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">// size大于加载因子,扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中最多也只是设置了initialCapacity、loadFactor的值,并没有初始化table,table的初始化工作是在put方法中进行的.</p>
<h4 id="4-6-resize"><a href="#4-6-resize" class="headerlink" title="4.6 resize"></a>4.6 resize</h4><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114807.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>扩容(resize)就是重新计算容量,向HashMap对象里不停的添加元素,内部的数组无法装载更多的元素时,就需要扩大数组的长度.<br>当然Java里的数组是无法自动扩容的,方法是使用一个新的数组代替已有的容量小的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该函数有2种使用情况：1.初始化哈希表 2.当前数组容量过小，需扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">final</span> Node[] resize() &#123;</span><br><span class="line">        Node[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 针对情况2：若扩容前的数组容量超过最大值，则不再扩充</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 针对情况2：若无超过最大值，就扩充为原来的2倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">//newCap设置为oldCap的2倍并小于MAXIMUM_CAPACITY，且大于默认值, 新的threshold增加为原来的2倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 针对情况1：初始化哈希表（采用指定 or 默认值）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">// threshold&gt;0, 将threshold设置为newCap,所以要用tableSizeFor方法保证threshold是2的幂次方</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">// 默认初始化</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算新的resize上限</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// newThr为0，newThr = newCap * 0.75</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            <span class="comment">// 新生成一个table数组</span></span><br><span class="line">            Node[] newTab = (Node[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// oldTab 复制到 newTab</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="comment">// 链表只有一个节点，直接赋值</span></span><br><span class="line">                       <span class="comment">//为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">// e为红黑树的情况</span></span><br><span class="line">                        ((TreeNode)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order链表优化重hash的代码块</span></span><br><span class="line">                        Node loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 原索引</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114831.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<h4 id="4-7-remove方法"><a href="#4-7-remove方法" class="headerlink" title="4.7 remove方法"></a>4.7 remove方法</h4><p>remove(key) 方法 和 remove(key, value) 方法都是通过调用removeNode的方法来实现删除元素的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node[] tab; Node p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// index 元素只有一个元素</span></span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// index处是一个红黑树</span></span><br><span class="line">                    node = ((TreeNode)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// index处是一个链表，遍历链表返回node</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分不同情形删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-get"><a href="#4-8-get" class="headerlink" title="4.8 get"></a>4.8 get</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 函数原型</span></span><br><span class="line"><span class="comment">   * 作用：根据键key，向HashMap获取对应的值</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   map.get(key)；</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 源码分析</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node e;</span><br><span class="line">    <span class="comment">// 1\. 计算需获取数据的hash值</span></span><br><span class="line">    <span class="comment">// 2\. 通过getNode（）获取所查询的数据 -&gt;&gt;分析1</span></span><br><span class="line">    <span class="comment">// 3\. 获取后，判断数据是否为空</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1：getNode(hash(key), key))</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node[] tab; Node first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 1\. 计算存放在数组table中的位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 4\. 通过该函数，依次在数组、红黑树、链表中查找（通过equals（）判断）</span></span><br><span class="line">        <span class="comment">// a. 先在数组中找，若存在，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// b. 若数组中没有，则到红黑树中寻找</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// c. 若红黑树中也没有，则通过遍历，到链表中寻找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>在JDK1.7及以前的版本中，HashMap里是没有红黑树的实现的，在JDK1.8中加入了红黑树是为了防止哈希表碰撞攻击，当链表链长度为8时，及时转成红黑树，提高map的效率</em></p>
<p>如果某个桶中的记录过大的话（当前是TREEIFY_THRESHOLD = 8），HashMap会动态的使用一个专门的treemap实现来替换掉它。这样做的结果会更好，是O(logn)，而不是糟糕的O(n)。它是如何工作的？前面产生冲突的那些KEY对应的记录只是简单的追加到一个链表后面，这些记录只能通过遍历来进行查找。但是超过这个阈值后HashMap开始将列表升级成一个二叉树，使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入。这对HashMap的key来说并不是必须的，不过如果实现了当然最好。如果没有实现这个接口，在出现严重的哈希碰撞的时候，你就并别指望能获得性能提升了。</p>
<p>这个性能提升有什么用处？比方说恶意的程序，如果它知道我们用的是哈希算法，它可能会发送大量的请求，导致产生严重的哈希碰撞。然后不停的访问这些key就能显著的影响服务器的性能，这样就形成了一次拒绝服务攻击（DoS）。JDK 8中从O(n)到O(logn)的飞跃，可以有效地防止类似的攻击，同时也让HashMap性能的可预测性稍微增强了一些</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 源码分析：resize(2 * table.length)</span></span><br><span class="line"><span class="comment">   * 作用：当容量不足时（容量 &gt; 阈值），则扩容（扩到2倍）</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 1\. 保存旧数组（old table） </span></span><br><span class="line">    Entry[] oldTable = table;  </span><br><span class="line">    <span class="comment">// 2\. 保存旧容量（old capacity ），即数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length; </span><br><span class="line">    <span class="comment">// 3\. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出    </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 4\. 根据新容量（2倍容量）新建1个数组，即新table  </span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  </span><br><span class="line">    <span class="comment">// 5\. （重点分析）将旧数组上的数据（键值对）转移到新table中，从而完成扩容 -&gt;&gt;分析1.1 </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line">    <span class="comment">// 6\. 新数组table引用到HashMap的table属性上</span></span><br><span class="line">    table = newTable;  </span><br><span class="line">    <span class="comment">// 7\. 重新设置阈值  </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor); </span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1.1：transfer(newTable); </span></span><br><span class="line"><span class="comment">   * 作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容</span></span><br><span class="line"><span class="comment">   * 过程：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1\. src引用了旧数组</span></span><br><span class="line">      Entry[] src = table; </span><br><span class="line">      <span class="comment">// 2\. 获取新数组的大小 = 获取新容量大小                 </span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="comment">// 3\. 通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">          <span class="comment">// 3.1 取得旧数组的每个元素  </span></span><br><span class="line">          Entry e = src[j];           </span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 3.2 释放旧数组的对象引用（for循环后，旧数组不再引用任何对象）</span></span><br><span class="line">              src[j] = <span class="keyword">null</span>; </span><br><span class="line">              <span class="keyword">do</span> &#123; </span><br><span class="line">                  <span class="comment">// 3.3 遍历 以该数组元素为首 的链表</span></span><br><span class="line">                  <span class="comment">// 注：转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开</span></span><br><span class="line">                  Entry next = e.next; </span><br><span class="line">                 <span class="comment">// 3.3 重新计算每个元素的存储位置</span></span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 <span class="comment">// 3.4 将元素放在数组上：采用单链表的头插入方式 = 在链表头上存放数据 = 将数组位置的原有数据放在后1个指针、将需放入的数据放到数组位置中</span></span><br><span class="line">                 <span class="comment">// 即 扩容后，可能出现逆序：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line">                 e.next = newTable[i]; </span><br><span class="line">                 newTable[i] = e;  </span><br><span class="line">                 <span class="comment">// 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点</span></span><br><span class="line">                 e = next;             </span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">             <span class="comment">// 如此不断循环，直到遍历完数组上的所有数据元素</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从上面可看出：在扩容resize（）过程中，在将旧数组上的数据 转移到 新数组上时，转移数据操作 = 按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况</p>
<p><strong>设重新计算存储位置后不变，即扩容前 = 1-&gt;2-&gt;3，扩容后 = 3-&gt;2-&gt;1</strong></p>
<p>此时若并发执行 put 操作，一旦出现扩容情况，则 容易出现 环形链表，从而在获取数据、遍历链表时 形成死循环（Infinite Loop），即死锁<br><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114931" alt="img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)![img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114856.jpg)![img" title="" class="">
                <p>img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)![img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114856.jpg)![img</p>
            </figure></p>
<h3 id="单线程rehash"><a href="#单线程rehash" class="headerlink" title="单线程rehash"></a>单线程rehash</h3><p>单线程情况下，rehash无问题<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114944.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<h3 id="多线程并发下的rehash"><a href="#多线程并发下的rehash" class="headerlink" title="多线程并发下的rehash"></a>多线程并发下的rehash</h3><p>这里假设有两个线程同时执行了put操作并引发了rehash，执行了transfer方法，并假设线程一进入transfer方法并执行完next = e.next后，因为线程调度所分配时间片用完而“暂停”，此时线程二完成了transfer方法的执行。此时状态如下。<br><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114952.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>接着线程1被唤醒，继续执行第一轮循环的剩余部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.next = newTable[<span class="number">1</span>] = <span class="keyword">null</span></span><br><span class="line">newTable[<span class="number">1</span>] = e = key(<span class="number">5</span>)</span><br><span class="line">e = next = key(<span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下图所示<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004115001.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>接着执行下一轮循环，结果状态图如下所示<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004115011" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>继续下一轮循环，结果状态图如下所示<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure></p>
<p>此时循环链表形成，并且key(11)无法加入到线程1的新数组。在下一次访问该链表时会出现死循环。</p>
<h3 id="Fast-fail"><a href="#Fast-fail" class="headerlink" title="Fast-fail"></a>Fast-fail</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>在使用迭代器的过程中如果HashMap被修改，那么ConcurrentModificationException将被抛出，也即Fast-fail策略。</p>
<p>当HashMap的iterator()方法被调用时，会构造并返回一个新的EntryIterator对象，并将EntryIterator的expectedModCount设置为HashMap的modCount（该变量记录了HashMap被修改的次数）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">  expectedModCount = modCount;</span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">  Entry[] t = table;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在通过该Iterator的next方法访问下一个Entry时，它会先检查自己的expectedModCount与HashMap的modCount是否相等，如果不相等，说明HashMap被修改，直接抛出ConcurrentModificationException。该Iterator的remove方法也会做类似的检查。该异常的抛出意在提醒用户及早意识到线程安全问题。</p>
<h3 id="线程安全解决方案"><a href="#线程安全解决方案" class="headerlink" title="线程安全解决方案"></a>线程安全解决方案</h3><p>单线程条件下，为避免出现ConcurrentModificationException，需要保证只通过HashMap本身或者只通过Iterator去修改数据，不能在Iterator使用结束之前使用HashMap本身的方法修改数据。因为通过Iterator删除数据时，HashMap的modCount和Iterator的expectedModCount都会自增，不影响二者的相等性。如果是增加数据，只能通过HashMap本身的方法完成，此时如果要继续遍历数据，需要重新调用iterator()方法从而重新构造出一个新的Iterator，使得新Iterator的expectedModCount与更新后的HashMap的modCount相等。</p>
<p>多线程条件下，可使用Collections.synchronizedMap方法构造出一个同步Map，或者直接使用线程安全的ConcurrentHashMap。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 完整深入解析</title>
    <url>/2020/05/07/java/JVM-%E5%AE%8C%E6%95%B4%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>Java运行时数据区：</li>
<li>JMM Java内存模型：</li>
<li>堆的内存划分：</li>
<li>GC垃圾回收：</li>
<li>HotSpot 虚拟机详解：</li>
<li>JVM优化：</li>
<li>类加载机制：</li>
</ul>
<hr>
<a id="more"></a>
<h1 id="Java运行时数据区："><a href="#Java运行时数据区：" class="headerlink" title="Java运行时数据区："></a>Java运行时数据区：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图：</span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_47_29_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>1、程序计数器：指向当前线程正在执行的字节码指令。线程私有的。2、虚拟机栈：虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压人栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。（1）栈帧：栈帧存储方法的相关信息，包含局部变量数表、返回值、操作数栈、动态链接 a、局部变量表：包含了方法执行过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组的大小。b、返回值：如果有返回值的话，压入调用者栈帧中的操作数栈中，并且把PC的值指向 方法调用指令 后面的一条指令地址。c、操作数栈：操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定（写入方法区code属性的max_stacks项中）。操作数栈的的元素可以是任意Java类型，包括long和double，32位数据占用栈空间为1，64位数据占用2。方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令往栈中存取数据。d、动态链接：每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。（2）线程私有 3、本地方法栈：（1）调用本地native的内存模型 （2）线程独享。4、方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据 （1）线程共享的 （2）运行时常量池：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A、是方法区的一部分</span><br><span class="line">B、存放编译期生成的各种字面量和符号引用</span><br><span class="line">C、Class文件中除了存有类的版本、字段、方法、接口等描述信息，还有一项是常量池，存有这个类的 编译期生成的各种字面量和符号引用，这部分内容将在类加载后，存放到方法区的运行时常量池中。</span><br></pre></td></tr></table></figure>
<p>5、堆（Heap）：Java对象存储的地方 （1）Java堆是虚拟机管理的内存中最大的一块 （2）Java堆是所有线程共享的区域 （3）在虚拟机启动时创建 （4）此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。存放new生成的对象和数组 （5）Java堆是垃圾收集器管理的内存区域，因此很多时候称为“GC堆”</p>
<h1 id="JMM-Java内存模型："><a href="#JMM-Java内存模型：" class="headerlink" title="JMM Java内存模型："></a>JMM Java内存模型：</h1><p>1、 Java的并发采用“共享内存”模型，线程之间通过读写内存的公共状态进行通讯。多个线程之间是不能通过直接传递数据交互的，它们之间交互只能通过共享变量实现。2、 主要目的是定义程序中各个变量的访问规则。3、 Java内存模型规定所有变量都存储在主内存中，每个线程还有自己的工作内存。（1） 线程的工作内存中保存了被该线程使用到的变量的拷贝（从主内存中拷贝过来），线程对变量的所有操作都必须在工作内存中执行，而不能直接访问主内存中的变量。（2） 不同线程之间无法直接访问对方工作内存的变量，线程间变量值的传递都要通过主内存来完成。（3） 主内存主要对应Java堆中实例数据部分。工作内存对应于虚拟机栈中部分区域。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_48_09_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>4、Java线程之间的通信由内存模型JMM（Java Memory Model）控制。（1）JMM决定一个线程对变量的写入何时对另一个线程可见。（2）线程之间共享变量存储在主内存中 （3）每个线程有一个私有的本地内存，里面存储了读/写共享变量的副本。（4）JMM通过控制每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。5、可见性、有序性：（1）当一个共享变量在多个本地内存中有副本时，如果一个本地内存修改了该变量的副本，其他变量应该能够看到修改后的值，此为可见性。（2）保证线程的有序执行，这个为有序性。（保证线程安全） 6、内存间交互操作：（1）lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。（2）unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。（3）read（读取）：作用于主内存变量，把主内存的一个变量读取到工作内存中。（4）load（载入）：作用于工作内存，把read操作读取到工作内存的变量载入到工作内存的变量副本中 （5）use（使用）：作用于工作内存的变量，把工作内存中的变量值传递给一个执行引擎。（6）assign（赋值）：作用于工作内存的变量。把执行引擎接收到的值赋值给工作内存的变量。（7）store（存储）：把工作内存的变量的值传递给主内存 （8）write（写入）：把store操作的值入到主内存的变量中 6.1、注意：（1）不允许read、load、store、write操作之一单独出现 （2）不允许一个线程丢弃assgin操作 （3）不允许一个线程不经过assgin操作，就把工作内存中的值同步到主内存中 （4）一个新的变量只能在主内存中生成 （5）一个变量同一时刻只允许一条线程对其进行lock操作。但lock操作可以被同一条线程执行多次，只有执行相同次数的unlock操作，变量才会解锁 （6）如果对一个变量进行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或者assgin操作初始化变量的值。（7）如果一个变量没有被锁定，不允许对其执行unlock操作，也不允许unlock一个被其他线程锁定的变量 （8）对一个变量执行unlock操作之前，需要将该变量同步回主内存中</p>
<h1 id="堆的内存划分："><a href="#堆的内存划分：" class="headerlink" title="堆的内存划分："></a>堆的内存划分：</h1><figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>Java堆的内存划分如图所示，分别为年轻代、Old Memory（老年代）、Perm（永久代）。其中在Jdk1.8中，永久代被移除，使用MetaSpace代替。1、新生代：（1）使用复制清除算法（Copinng算法），原因是年轻代每次GC都要回收大部分对象。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。（2）分为Eden、Survivor From、Survivor To，比例默认为8：1：1 （3）内存不足时发生Minor GC 2、老年代：（1）采用标记-整理算法（mark-compact），原因是老年代每次GC只会回收少部分对象。3、Perm：用来存储类的元数据，也就是方法区。（1）Perm的废除：在jdk1.8中，Perm被替换成MetaSpace，MetaSpace存放在本地内存中。原因是永久代进场内存不够用，或者发生内存泄漏。（2）MetaSpace（元空间）：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。4、堆内存的划分在JVM里面的示意图：<br><br><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_48_17_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<h1 id="GC垃圾回收："><a href="#GC垃圾回收：" class="headerlink" title="GC垃圾回收："></a>GC垃圾回收：</h1><p>一、 判断对象是否要回收的方法：可达性分析法 1、 可达性分析法：通过一系列“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不一定会成为可回收对象。进入DEAD状态的线程还可以恢复，GC不会回收它的内存。（把一些对象当做root对象，JVM认为root对象是不可回收的，并且root对象引用的对象也是不可回收的） 2、 以下对象会被认为是root对象：（1） 虚拟机栈（栈帧中本地变量表）中引用的对象 （2） 方法区中静态属性引用的对象 （3） 方法区中常量引用的对象 （4） 本地方法栈中Native方法引用的对象 3、 对象被判定可被回收，需要经历两个阶段：（1） 第一个阶段是可达性分析，分析该对象是否可达 （2） 第二个阶段是当对象没有重写finalize()方法或者finalize()方法已经被调用过，虚拟机认为该对象不可以被救活，因此回收该对象。（finalize()方法在垃圾回收中的作用是，给该对象一次救活的机会） 4、 方法区中的垃圾回收：（1） 常量池中一些常量、符号引用没有被引用，则会被清理出常量池 （2） 无用的类：被判定为无用的类，会被清理出方法区。判定方法如下：A、 该类的所有实例被回收 B、 加载该类的ClassLoader被回收 C、 该类的Class对象没有被引用 5、 finalize(): （1） GC垃圾回收要回收一个对象的时候，调用该对象的finalize()方法。然后在下一次垃圾回收的时候，才去回收这个对象的内存。（2） 可以在该方法里面，指定一些对象在释放前必须执行的操作。</p>
<p>二、 发现虚拟机频繁full GC时应该怎么办：（full GC指的是清理整个堆空间，包括年轻代和永久代） （1） 首先用命令查看触发GC的原因是什么 jstat –gccause 进程id （2） 如果是System.gc()，则看下代码哪里调用了这个方法 （3） 如果是heap inspection(内存检查)，可能是哪里执行jmap –histo[:live]命令 （4） 如果是GC locker，可能是程序依赖的JNI库的原因</p>
<p>三、常见的垃圾回收算法：1、Mark-Sweep（标记-清除算法）：（1）思想：标记清除算法分为两个阶段，标记阶段和清除阶段。标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。（2）优缺点：实现简单，容易产生内存碎片 2、Copying（复制清除算法）：（1）思想：将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。（2）优缺点：不容易产生内存碎片；可用内存空间少；存活对象多的话，效率低下。3、Mark-Compact（标记-整理算法）：（1）思想：先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存。（2）优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，移动次数多，效率低下</p>
<p>4、分代收集算法：（目前大部分JVM的垃圾收集器所采用的算法）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思想：把堆分成新生代和老年代。（永久代指的是方法区）</span><br></pre></td></tr></table></figure>
<p>（1） 因为新生代每次垃圾回收都要回收大部分对象，所以新生代采用Copying算法。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。（2） 由于老年代每次只回收少量的对象，因此采用mark-compact算法。（3） 在堆区外有一个永久代。对永久代的回收主要是无效的类和常量 5、GC使用时对程序的影响？垃圾回收会影响程序的性能，Java虚拟机必须要追踪运行程序中的有用对象，然后释放没用对象，这个过程消耗处理器时间 6、几种不同的垃圾回收类型：（1）Minor GC：从年轻代（包括Eden、Survivor区）回收内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A、当JVM无法为一个新的对象分配内存的时候，越容易触发Minor GC。所以分配率越高，内存越来越少，越频繁执行Minor GC</span><br><span class="line">B、执行Minor GC操作的时候，不会影响到永久代（Tenured）。从永久代到年轻代的引用，被当成GC Roots，从年轻代到老年代的引用在标记阶段直接被忽略掉。</span><br></pre></td></tr></table></figure>
<p>（2）Major GC：清理整个老年代，当eden区内存不足时触发。（3）Full GC：清理整个堆空间，包括年轻代和老年代。当老年代内存不足时触发</p>
<h1 id="HotSpot-虚拟机详解："><a href="#HotSpot-虚拟机详解：" class="headerlink" title="HotSpot 虚拟机详解："></a>HotSpot 虚拟机详解：</h1><p>1、 Java对象创建过程：（1）虚拟机遇到一条new指令时，首先检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经加载、连接和初始化。如果没有，就执行该类的加载过程。（2）为该对象分配内存。A、假设Java堆是规整的，所有用过的内存放在一边，空闲的内存放在另外一边，中间放着一个指针作为分界点的指示器。那分配内存只是把指针向空闲空间那边挪动与对象大小相等的距离，这种分配称为“指针碰撞” B、假设Java堆不是规整的，用过的内存和空闲的内存相互交错，那就没办法进行“指针碰撞”。虚拟机通过维护一个列表，记录哪些内存块是可用的，在分配的时候找出一块足够大的空间分配给对象实例，并更新表上的记录。这种分配方式称为“空闲列表“。C、使用哪种分配方式由Java堆是否规整决定。Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。D、分配对象保证线程安全的做法：虚拟机使用CAS失败重试的方式保证更新操作的原子性。（实际上还有另外一种方案：每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，TLAB。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才进行同步锁定。虚拟机是否使用TLAB，由-XX:+/-UseTLAB参数决定） （3）虚拟机为分配的内存空间初始化为零值（默认值） （4）虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到对象的元数据信息、对象的Hash码、对象的GC分代年龄等信息。这些信息存放在对象的对象头中。（5） 执行方法，把对象按照程序员的意愿进行初始化。2、 对象的定位访问的方式（通过引用如何去定位到堆上的具体对象的位置）：（1）句柄：使用句柄的方式，Java堆中将会划分出一块内存作为作为句柄池，引用中存储的就是对象的句柄的地址。而句柄中包含了对象实例数据和对象类型数据的地址。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_48_32_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>（2）直接指针：使用直接指针的方式，引用中存储的就是对象的地址。Java堆对象的布局必须必须考虑如何去访问对象类型数据。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_48_36_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>（3）两种方式各有优点：A、使用句柄访问的好处是引用中存放的是稳定的句柄地址，当对象被移动（比如说垃圾回收时移动对象），只会改变句柄中实例数据指针，而引用本身不会被修改。B、使用直接指针，节省了一次指针定位的时间开销。3、HotSpot的GC算法实现：（1）HotSpot怎么快速找到GC Root？HotSpot使用一组称为OopMap的数据结构。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在栈和寄存器中哪些位置是引用。这样子，在GC扫描的时候，就可以直接知道哪些是可达对象了。（2）安全点：A、HotSpot只在特定的位置生成OopMap，这些位置称为安全点。B、程序执行过程中并非所有地方都可以停下来开始GC，只有在到达安全点是才可以暂停。C、安全点的选定基本上以“是否具有让程序长时间执行“的特征选定的。比如说方法调用、循环跳转、异常跳转等。具有这些功能的指令才会产生Safepoint。（3）中断方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A、抢占式中断：在GC发生时，首先把所有线程中断，如果发现有线程不在安全点上，就恢复线程，让它跑到安全点上。</span><br><span class="line">B、主动式中断：GC需要中断线程时，不直接对线程操作，仅仅设置一个标志，各个线程执行时主动去轮询这个标志，当发现中断标记为真就自己中断挂起。轮询标记的地方和安全点是重合的。</span><br></pre></td></tr></table></figure>
<p>（5）安全区域：一段代码片段中，对象的引用关系不会发生变化，在这个区域中任何地方开始GC都是安全的。在线程进入安全区域时，它首先标志自己已经进入安全区域，在这段时间里，当JVM发起GC时，就不用管进入安全区域的线程了。在线程将要离开安全区域时，它检查系统是否完成了GC过程，如果完成了，它就继续前行。否则，它就必须等待直到收到可以离开安全区域的信号。4、 GC时为什么要停顿所有Java线程？因为GC先进行可达性分析。可达性分析是判断GC Root对象到其他对象是否可达，假如分析过程中对象的引用关系在不断变化，分析结果的准确性就无法得到保证。5、 CMS收集器：（1）一种以获取最短回收停顿时间为目标的收集器。（2）一般用于互联网站或者B/S系统的服务端 （3）基于标记-清除算法的实现，不过更为复杂，整个过程为4个步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A、初始标记：标记GC Root能直接引用的对象</span><br><span class="line">B、并发标记：利用多线程对每个GC Root对象进行tracing搜索，在堆中查找其下所有能关联到的对象。</span><br><span class="line">C、重新标记：为了修正并发标记期间，用户程序继续运作而导致标志产生变动的那一部分对象的标记记录。</span><br><span class="line">D、并发清除：利用多个线程对标记的对象进行清除</span><br></pre></td></tr></table></figure>
<p>（4）由于耗时最长的并发标记和并发清除操作都是用户线程一起工作，所以总体来说，CMS的内存回收工作是和用户线程一起并发执行的。（5）缺点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A、对CPU资源占用比较多。可能因为占用一部分CPU资源导致应用程序响应变慢。</span><br><span class="line">B、CMS无法处理浮动垃圾。在并发清除阶段，用户程序继续运行，可能产生新的内存垃圾，这一部分垃圾出现在标记过程之后，因此，CMS无法清除。这部分垃圾称为“浮动垃圾“</span><br><span class="line">C、需要预留一部分内存，在垃圾回收时，给用户程序使用。</span><br><span class="line">D、基于标记-清除算法，容易产生大量内存碎片，导致full GC（full GC进行内存碎片的整理）</span><br></pre></td></tr></table></figure>
<p>6、 对象头部分的内存布局：HotSpot的对象头分为两部分，第一部分用于存储对象自身的运行时数据，比如哈希码、GC分代年龄等。另外一部分用于指向方法区对象类型数据的指针。7、 偏向锁：偏向锁偏向于第一个获取它的线程，如果在接下来的执行过程，没有其他线程获取该锁，则持有偏向锁的线程永远不需要同步。（当一个线程获取偏向锁，它每次进入这个锁相关的同步块，虚拟机不在进行任何同步操作。当有另外一个线程尝试获取这个锁时，偏向模式宣告结束）</p>
<h1 id="JVM优化："><a href="#JVM优化：" class="headerlink" title="JVM优化："></a>JVM优化：</h1><p>1、一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用<code>-Xmn</code>设置年轻代的大小</p>
<p>2、对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：<code>-XX:PetenureSizeThreshold=1000000</code>，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。</p>
<p>3、一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构<code>-XX:MaxTenuringThreshold</code>设置。如果想让对象留在年轻代，可以设置比较大的阈值。</p>
<p>4、设置最小堆和最大堆：<code>-Xmx</code>和<code>-Xms</code>稳定的堆大小堆垃圾回收是有利的，获得一个稳定的堆大小的方法是设置-Xms和-Xmx的值一样，即最大堆和最小堆一样，如果这样子设置，系统在运行时堆大小理论上是恒定的，稳定的堆空间可以减少GC次数，因此，很多服务端都会将这两个参数设置为一样的数值。稳定的堆大小虽然减少GC次数，但是增加每次GC的时间，因为每次GC要把堆的大小维持在一个区间内。</p>
<p>5、一个不稳定的堆并非毫无用处。在系统不需要使用大内存的时候，压缩堆空间，使得GC每次应对一个较小的堆空间，加快单次GC次数。基于这种考虑，JVM提供两个参数，用于压缩和扩展堆空间。（1）<code>-XX:MinHeapFreeRatio</code> 参数用于设置堆空间的最小空闲比率。默认值是40，当堆空间的空闲内存比率小于40，JVM便会扩展堆空间 （2）<code>-XX:MaxHeapFreeRatio</code> 参数用于设置堆空间的最大空闲比率。默认值是70， 当堆空间的空闲内存比率大于70，JVM便会压缩堆空间。（3）当-Xmx和-Xmx相等时，上面两个参数无效</p>
<p>6、通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器。（1）<code>-XX:+UseParallelGC</code>:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。（2）<code>-XX:+UseParallelOldGC</code>:设置老年代使用并行垃圾回收收集器。</p>
<p>7、尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。<code>-XX:+LargePageSizeInBytes</code> 设置内存页的大小</p>
<p>8、使用非占用的垃圾收集器。<code>-XX:+UseConcMarkSweepGC</code>老年代使用CMS收集器降低停顿。</p>
<p>9、<code>-XXSurvivorRatio=3</code>，表示年轻代中的分配比率：survivor:eden = 2:3</p>
<p>10、JVM性能调优的工具：（1）jps（Java Process Status）：输出JVM中运行的进程状态信息(现在一般使用jconsole) （2）jstack：查看java进程内线程的堆栈信息。（3）jmap：用于生成堆转存快照 （4）jhat：用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer） （3）jstat是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。（4）VisualVM：故障处理工具</p>
<h1 id="类加载机制："><a href="#类加载机制：" class="headerlink" title="类加载机制："></a>类加载机制：</h1><p>一、 概念：类加载器把class文件中的二进制数据读入到内存中，存放在方法区，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类加载的步骤如下：1、加载：查找并加载类的二进制数据（把class文件里面的信息加载到内存里面） 2、连接：把内存中类的二进制数据合并到虚拟机的运行时环境中 （1）验证：确保被加载的类的正确性。包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A、类文件的结构检查：检查是否满足Java类文件的固定格式</span><br><span class="line">B、语义检查：确保类本身符合Java的语法规范</span><br><span class="line">C、字节码验证：确保字节码流可以被Java虚拟机安全的执行。字节码流是操作码组成的序列。每一个操作码后面都会跟着一个或者多个操作数。字节码检查这个步骤会检查每一个操作码是否合法。</span><br><span class="line">D、二进制兼容性验证：确保相互引用的类之间是协调一致的。</span><br></pre></td></tr></table></figure>
<p>（2）准备：为类的静态变量分配内存，并将其初始化为默认值 （3）解析：把类中的符号引用转化为直接引用（比如说方法的符号引用，是有方法名和相关描述符组成，在解析阶段，JVM把符号引用替换成一个指针，这个指针就是直接引用，它指向该类的该方法在方法区中的内存位置） 3、初始化：为类的静态变量赋予正确的初始值。当静态变量的等号右边的值是一个常量表达式时，不会调用static代码块进行初始化。只有等号右边的值是一个运行时运算出来的值，才会调用static初始化。</p>
<p>二、双亲委派模型：1、当一个类加载器收到类加载请求的时候，它首先不会自己去加载这个类的信息，而是把该 请求转发给父类加载器，依次向上。所以所有的类加载请求都会被传递到父类加载器中，只有当父类加载器中无法加载到所需的类，子类加载器才会自己尝试去加载该类。当当前类加载器和所有父类加载器都无法加载该类时，抛出ClassNotFindException异常。2、意义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提高系统的安全性。用户自定义的类加载器不可能加载应该由父加载器加载的可靠类。（比如用户定义了一个恶意代码，自定义的类加载器首先让系统加载器去加载，系统加载器检查该代码不符合规范，于是就不继续加载了）</span><br></pre></td></tr></table></figure>
<p>3、定义类加载器：如果某个类加载器能够加载一个类，那么这个类加载器就叫做定义类加载器 4、初始类加载器：定义类加载器及其所有子加载器都称作初始类加载器。5、运行时包：（1）由同一个类加载器加载并且拥有相同包名的类组成运行时包 （2）只有属于同一个运行时包的类，才能访问包可见（default）的类和类成员。作用是 限制用户自定义的类冒充核心类库的类去访问核心类库的包可见成员。6、加载两份相同的class对象的情况：A和B不属于父子类加载器关系，并且各自都加载了同一个类。</p>
<p>三、特点：1、全盘负责：当一个类加载器加载一个类时，该类所依赖的其他类也会被这个类加载器加载到内存中。2、缓存机制：所有的Class对象都会被缓存，当程序需要使用某个Class时，类加载器先从缓存中查找，找不到，才从class文件中读取数据，转化成Class对象，存入缓存中。</p>
<p>三、 类加载器：两种类型的类加载器：1、 JVM自带的类加载器（3种）：（1）根类加载器（Bootstrap）：a、C++编写的，程序员无法在程序中获取该类 b、负责加载虚拟机的核心库，比如java.lang.Object c、没有继承ClassLoader类 （2）扩展类加载器（Extension）：a、Java编写的，从指定目录中加载类库 b、父加载器是根类加载器 c、是ClassLoader的子类 d、如果用户把创建的jar文件放到指定目录中，也会被扩展加载器加载。（3）系统加载器（System）或者应用加载器(App)：a、Java编写的 b、父加载器是扩展类加载器 c、从环境变量或者class.path中加载类 d、是用户自定义类加载的默认父加载器 e、是ClassLoader的子类</p>
<p>2、用户自定义的类加载器：（1）Java.lang.ClassLoader类的子类 （2）用户可以定制类的加载方式 （3）父类加载器是系统加载器 （4）编写步骤：A、继承ClassLoader B、重写findClass方法。从特定位置加载class文件，得到字节数组，然后利用defineClass把字节数组转化为Class对象 （5）为什么要自定义类加载器？A、可以从指定位置加载class文件，比如说从数据库、云端加载class文件 B、加密：Java代码可以被轻易的反编译，因此，如果需要对代码进行加密，那么加密以后的代码，就不能使用Java自带的ClassLoader来加载这个类了，需要自定义ClassLoader，对这个类进行解密，然后加载。</p>
<p>问题：Java程序对类的执行有几种方式：1、 主动使用（6种情况）：JVM必须在每个类“首次 主动使用”的时候，才会初始化这些类。（1） 创建类的实例 （2） 读写某个类或者接口的静态变量 （3） 调用类的静态方法 （4） 同过反射的API（Class.forName()）获取类 （5） 初始化一个类的子类 （6） JVM启动的时候，被标明启动类的类（包含Main方法的类） 只有当程序使用的静态变量或者静态方法确实在该类中定义时，该可以认为是对该类或者接口的主动使用。2、 被动使用：除了主动使用的6种情况，其他情况都是被动使用，都不会导致类的初始化。3、 JVM规范允许类加载器在预料某个类将要被使用的时候，就预先加载它。如果该class文件缺失或者存在错误，则在程序“首次 主动使用”的时候，才报告这个错误。（Linkage Error错误）。如果这个类一直没有被程序“主动使用”，就不会报错。</p>
<p>类加载机制与接口：1、 当Java虚拟机初始化一个类时，不会初始化该类实现的接口。2、 在初始化一个接口时，不会初始化这个接口父接口。3、 只有当程序首次使用该接口的静态变量时，才导致该接口的初始化。</p>
<p>ClassLoader：1、 调用Classloader的loadClass方法去加载一个类，不是主动使用，因此不会进行类的初始化。</p>
<p>类的卸载：1、 有JVM自带的三种类加载器（根、扩展、系统）加载的类始终不会卸载。因为JVM始终引用这些类加载器，这些类加载器使用引用他们所加载的类，因此这些Class类对象始终是可到达的。2、 由用户自定义类加载器加载的类，是可以被卸载的。</p>
<p>补充：</p>
<ul>
<li>JDK和JRK</li>
</ul>
<p>（1）JDK ：Java Development Kit，开发的时候用到的类包。（2）JRE ：Java Runtime Environment，Java运行的基础，包含运行时需要的所有类库。</p>
<ul>
<li>图解java文件转化成机器码</li>
</ul>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_50_04_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>JVM虚拟机先将java文件编译成class文件（字节码文件），然后再将class文件转换成所有操作系统都能运行的机器指令。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>API接口的安全设计</title>
    <url>/2020/06/24/java/API%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载，<a href="https://mp.weixin.qq.com/s/G94Z3BC5pZxPdbFxEnCyrw" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<p><strong>说明：在实际的业务中，难免会跟第三方系统进行数据的交互与传递，那么如何保证数据在传输过程中的安全呢（防窃取）？除了https的协议之外，能不能加上通用的一套算法以及规范来保证传输的安全性呢？</strong></p>
<p><strong>下面我们就来讨论下常用的一些API设计的安全方法，可能不一定是最好的，有更牛逼的实现方式，但是这篇是我自己的经验分享.</strong></p>
<h1 id="一：token-简介"><a href="#一：token-简介" class="headerlink" title="一：token 简介"></a>一：token 简介</h1><p>Token：访问令牌access token, 用于接口中, 用于标识接口调用者的身份、凭证，减少用户名和密码的传输次数。一般情况下客户端(接口调用方)需要先向服务器端申请一个接口调用的账号，服务器会给出一个appId和一个key, key用于参数签名使用，注意key保存到客户端，需要做一些安全处理，防止泄露。</p>
<p>Token的值一般是UUID，服务端生成Token后需要将token做为key，将一些和token关联的信息作为value保存到缓存服务器中(redis)，当一个请求过来后，服务器就去缓存服务器中查询这个Token是否存在，存在则调用接口，不存在返回接口错误，一般通过拦截器或者过滤器来实现，Token分为两种：</p>
<a id="more"></a>
<ul>
<li>API Token(接口令牌): 用于访问不需要用户登录的接口，如登录、注册、一些基本数据的获取等。获取接口令牌需要拿appId、timestamp和sign来换，sign=加密(timestamp+key)</li>
<li>USER Token(用户令牌): 用于访问需要用户登录之后的接口，如：获取我的基本信息、保存、修改、删除等操作。获取用户令牌需要拿用户名和密码来换</li>
</ul>
<p>关于Token的时效性：token可以是一次性的、也可以在一段时间范围内是有效的，具体使用哪种看业务需要。</p>
<p>一般情况下接口最好使用https协议，如果使用http协议，Token机制只是一种减少被黑的可能性，其实只能防君子不能防小人。</p>
<p>一般token、timestamp和sign 三个参数会在接口中会同时作为参数传递，每个参数都有各自的用途。</p>
<h1 id="二：timestamp-简介"><a href="#二：timestamp-简介" class="headerlink" title="二：timestamp 简介"></a>二：timestamp 简介</h1><p>timestamp: 时间戳，是客户端调用接口时对应的当前时间戳，时间戳用于防止DoS攻击。当黑客劫持了请求的url去DoS攻击，每次调用接口时接口都会判断服务器当前系统时间和接口中传的的timestamp的差值，如果这个差值超过某个设置的时间(假如5分钟)，那么这个请求将被拦截掉，如果在设置的超时时间范围内，是不能阻止DoS攻击的。timestamp机制只能减轻DoS攻击的时间，缩短攻击时间。如果黑客修改了时间戳的值可通过sign签名机制来处理。</p>
<h3 id="DoS"><a href="#DoS" class="headerlink" title="DoS"></a>DoS</h3><p>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。</p>
<p>DoS攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃，而在此攻击中并不包括侵入目标服务器或目标网络设备。这些服务资源包括网络带宽，文件系统空间容量，开放的进程或者允许的连接。这种攻击会导致资源的匮乏，无论计算机的处理速度多快、内存容量多大、网络带宽的速度多快都无法避免这种攻击带来的后果。</p>
<ul>
<li>Pingflood: 该攻击在短时间内向目的主机发送大量ping包，造成网络堵塞或主机资源耗尽。</li>
<li>Synflood: 该攻击以多个随机的源主机地址向目的主机发送SYN包，而在收到目的主机的SYN ACK后并不回应，这样，目的主机就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这</li>
</ul>
<p>些队列，造成了资源的大量消耗而不能向正常请求提供服务。</p>
<ul>
<li>Smurf：该攻击向一个子网的广播地址发一个带有特定请求（如ICMP回应请求）的包，并且将源地址伪装成想要攻击的主机地址。子网上所有主机都回应广播包请求而向被攻击主机发包，使该主机受到攻击。</li>
<li>Land-based：攻击者将一个包的源地址和目的地址都设置为目标主机的地址，然后将该包通过IP欺骗的方式发送给被攻击主机，这种包可以造成被攻击主机因试图与自己建立连接而陷入死循环，从而很大程度地降低了系统性能。</li>
<li>Ping of Death：根据TCP/IP的规范，一个包的长度最大为65536字节。尽管一个包的长度不能超过65536字节，但是一个包分成的多个片段的叠加却能做到。当一个主机收到了长度大于65536字节的包时，就是受到了Ping of Death攻击，该攻击会造成主机的宕机。</li>
<li>Teardrop：IP数据包在网络传递时，数据包可以分成更小的片段。攻击者可以通过发送两段（或者更多）数据包来实现TearDrop攻击。第一个包的偏移量为0，长度为N，第二个包的偏移量小于N。为了合并这些数据段，TCP/IP堆栈会分配超乎寻常的巨大资源，从而造成系统资源的缺乏甚至机器的重新启动。</li>
<li>PingSweep：使用ICMP Echo轮询多个主机。</li>
</ul>
<h1 id="三：sign-简介"><a href="#三：sign-简介" class="headerlink" title="三：sign 简介"></a>三：sign 简介</h1><p>nonce：随机值，是客户端随机生成的值，作为参数传递过来，随机值的目的是增加sign签名的多变性。随机值一般是数字和字母的组合，6位长度，随机值的组成和长度没有固定规则。</p>
<p>sign: 一般用于参数签名，防止参数被非法篡改，最常见的是修改金额等重要敏感参数， sign的值一般是将所有非空参数按照升续排序然后+token+key+timestamp+nonce(随机数)拼接在一起，然后使用某种加密算法进行加密，作为接口中的一个参数sign来传递，也可以将sign放到请求头中。接口在网络传输过程中如果被黑客挟持，并修改其中的参数值，然后再继续调用接口，虽然参数的值被修改了，但是因为黑客不知道sign是如何计算出来的，不知道sign都有哪些值构成，不知道以怎样的顺序拼接在一起的，最重要的是不知道签名字符串中的key是什么，所以黑客可以篡改参数的值，但没法修改sign的值，当服务器调用接口前会按照sign的规则重新计算出sign的值然后和接口传递的sign参数的值做比较，如果相等表示参数值没有被篡改，如果不等，表示参数被非法篡改了，就不执行接口了。</p>
<h1 id="四：防止重复提交"><a href="#四：防止重复提交" class="headerlink" title="四：防止重复提交"></a>四：防止重复提交</h1><p>对于一些重要的操作需要防止客户端重复提交的(如非幂等性重要操作)，具体办法是当请求第一次提交时将sign作为key保存到redis，并设置超时时间，超时时间和Timestamp中设置的差值相同。当同一个请求第二次访问时会先检测redis是否存在该sign，如果存在则证明重复提交了，接口就不再继续调用了。如果sign在缓存服务器中因过期时间到了，而被删除了，此时当这个url再次请求服务器时，因token的过期时间和sign的过期时间一直，sign过期也意味着token过期，那样同样的url再访问服务器会因token错误会被拦截掉，这就是为什么sign和token的过期时间要保持一致的原因。拒绝重复调用机制确保URL被别人截获了也无法使用（如抓取数据）。</p>
<p>对于哪些接口需要防止重复提交可以自定义个注解来标记。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p><strong>所有的安全措施都用上的话有时候难免太过复杂，在实际项目中需要根据自身情况作出裁剪，比如可以只使用签名机制就可以保证信息不会被篡改，或者定向提供服务的时候只用Token机制就可以了。如何裁剪，全看项目实际情况和对接口安全性的要求。</strong></p>
<h1 id="五：使用流程"><a href="#五：使用流程" class="headerlink" title="五：使用流程"></a>五：使用流程</h1><ol>
<li>接口调用方(客户端)向接口提供方(服务器)申请接口调用账号，申请成功后，接口提供方会给接口调用方一个appId和一个key参数</li>
<li>客户端携带参数appId、timestamp、sign去调用服务器端的API token，其中sign=加密(appId + timestamp + key)</li>
<li>客户端拿着api_token 去访问不需要登录就能访问的接口</li>
<li>当访问用户需要登录的接口时，客户端跳转到登录页面，通过用户名和密码调用登录接口，登录接口会返回一个usertoken, 客户端拿着usertoken 去访问需要登录才能访问的接口</li>
</ol>
<p>sign的作用是防止参数被篡改，客户端调用服务端时需要传递sign参数，服务器响应客户端时也可以返回一个sign用于客户度校验返回的值是否被非法篡改了。客户端传的sign和服务器端响应的sign算法可能会不同。</p>
<h1 id="六：示例代码"><a href="#六：示例代码" class="headerlink" title="六：示例代码"></a>六：示例代码</h1><h3 id="1-dependency"><a href="#1-dependency" class="headerlink" title="1. dependency"></a>1. dependency</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-RedisConfiguration"><a href="#2-RedisConfiguration" class="headerlink" title="2. RedisConfiguration"></a>2. RedisConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">jedisConnectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持存储对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">redisTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        redisTemplate.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-TokenController"><a href="#3-TokenController" class="headerlink" title="3. TokenController"></a>3. TokenController</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/token"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * API Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sign</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/api_token"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiResponse&lt;AccessToken&gt; <span class="title">apiToken</span><span class="params">(String appId, @RequestHeader(<span class="string">"timestamp"</span>)</span> String timestamp, @<span class="title">RequestHeader</span><span class="params">(<span class="string">"sign"</span>)</span> String sign) </span>&#123;</span><br><span class="line">        Assert.isTrue(!StringUtils.isEmpty(appId) &amp;&amp; !StringUtils.isEmpty(timestamp) &amp;&amp; !StringUtils.isEmpty(sign), <span class="string">"参数错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> reqeustInterval = System.currentTimeMillis() - Long.valueOf(timestamp);</span><br><span class="line">        Assert.isTrue(reqeustInterval &lt; <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>, <span class="string">"请求过期，请重新请求"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据appId查询数据库获取appSecret</span></span><br><span class="line">        AppInfo appInfo = <span class="keyword">new</span> AppInfo(<span class="string">"1"</span>, <span class="string">"12345678954556"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 校验签名</span></span><br><span class="line">        String signString = timestamp + appId + appInfo.getKey();</span><br><span class="line">        String signature = MD5Util.encode(signString);</span><br><span class="line">        log.info(signature);</span><br><span class="line">        Assert.isTrue(signature.equals(sign), <span class="string">"签名错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果正确生成一个token保存到redis中，如果错误返回错误信息</span></span><br><span class="line">        AccessToken accessToken = <span class="keyword">this</span>.saveToken(<span class="number">0</span>, appInfo, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(accessToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotRepeatSubmit</span>(<span class="number">5000</span>)</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"user_token"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiResponse&lt;UserInfo&gt; <span class="title">userToken</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据用户名查询密码, 并比较密码(密码可以RSA加密一下)</span></span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(username, <span class="string">"81255cb0dca1a5f304328a70ac85dcbd"</span>, <span class="string">"111111"</span>);</span><br><span class="line">        String pwd = password + userInfo.getSalt();</span><br><span class="line">        String passwordMD5 = MD5Util.encode(pwd);</span><br><span class="line">        Assert.isTrue(passwordMD5.equals(userInfo.getPassword()), <span class="string">"密码错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 保存Token</span></span><br><span class="line">        AppInfo appInfo = <span class="keyword">new</span> AppInfo(<span class="string">"1"</span>, <span class="string">"12345678954556"</span>);</span><br><span class="line">        AccessToken accessToken = <span class="keyword">this</span>.saveToken(<span class="number">1</span>, appInfo, userInfo);</span><br><span class="line">        userInfo.setAccessToken(accessToken);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AccessToken <span class="title">saveToken</span><span class="params">(<span class="keyword">int</span> tokenType, AppInfo appInfo,  UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        String token = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// token有效期为2小时</span></span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.setTime(<span class="keyword">new</span> Date());</span><br><span class="line">        calendar.add(Calendar.SECOND, <span class="number">7200</span>);</span><br><span class="line">        Date expireTime = calendar.getTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 保存token</span></span><br><span class="line">        ValueOperations&lt;String, TokenInfo&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">        TokenInfo tokenInfo = <span class="keyword">new</span> TokenInfo();</span><br><span class="line">        tokenInfo.setTokenType(tokenType);</span><br><span class="line">        tokenInfo.setAppInfo(appInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tokenType == <span class="number">1</span>) &#123;</span><br><span class="line">            tokenInfo.setUserInfo(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        operations.set(token, tokenInfo, <span class="number">7200</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        AccessToken accessToken = <span class="keyword">new</span> AccessToken(token, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        System.out.println(timestamp);</span><br><span class="line">        String signString = timestamp + <span class="string">"1"</span> + <span class="string">"12345678954556"</span>;</span><br><span class="line">        String sign = MD5Util.encode(signString);</span><br><span class="line">        System.out.println(sign);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        signString = <span class="string">"password=123456&amp;username=1&amp;12345678954556"</span> + <span class="string">"ff03e64b-427b-45a7-b78b-47d9e8597d3b1529815393153sdfsdfsfs"</span> + timestamp + <span class="string">"A1scr6"</span>;</span><br><span class="line">        sign = MD5Util.encode(signString);</span><br><span class="line">        System.out.println(sign);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-WebMvcConfiguration"><a href="#4-WebMvcConfiguration" class="headerlink" title="4. WebMvcConfiguration"></a>4. WebMvcConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] excludePathPatterns  = &#123;<span class="string">"/api/token/api_token"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenInterceptor tokenInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">        registry.addInterceptor(tokenInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">"/api/**"</span>)</span><br><span class="line">                .excludePathPatterns(excludePathPatterns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span>. TokenInterceptor</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 访问的目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        String timestamp = request.getHeader(<span class="string">"timestamp"</span>);</span><br><span class="line">        <span class="comment">// 随机字符串</span></span><br><span class="line">        String nonce = request.getHeader(<span class="string">"nonce"</span>);</span><br><span class="line">        String sign = request.getHeader(<span class="string">"sign"</span>);</span><br><span class="line">        Assert.isTrue(!StringUtils.isEmpty(token) &amp;&amp; !StringUtils.isEmpty(timestamp) &amp;&amp; !StringUtils.isEmpty(sign), <span class="string">"参数错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取超时时间</span></span><br><span class="line">        NotRepeatSubmit notRepeatSubmit = ApiUtil.getNotRepeatSubmit(handler);</span><br><span class="line">        <span class="keyword">long</span> expireTime = notRepeatSubmit == <span class="keyword">null</span> ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span> : notRepeatSubmit.value();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 请求时间间隔</span></span><br><span class="line">        <span class="keyword">long</span> reqeustInterval = System.currentTimeMillis() - Long.valueOf(timestamp);</span><br><span class="line">        Assert.isTrue(reqeustInterval &lt; expireTime, <span class="string">"请求超时，请重新请求"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 校验Token是否存在</span></span><br><span class="line">        ValueOperations&lt;String, TokenInfo&gt; tokenRedis = redisTemplate.opsForValue();</span><br><span class="line">        TokenInfo tokenInfo = tokenRedis.get(token);</span><br><span class="line">        Assert.notNull(tokenInfo, <span class="string">"token错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 校验签名(将所有的参数加进来，防止别人篡改参数) 所有参数看参数名升续排序拼接成url</span></span><br><span class="line">        <span class="comment">// 请求参数 + token + timestamp + nonce</span></span><br><span class="line">        String signString = ApiUtil.concatSignString(request) + tokenInfo.getAppInfo().getKey() + token + timestamp + nonce;</span><br><span class="line">        String signature = MD5Util.encode(signString);</span><br><span class="line">        <span class="keyword">boolean</span> flag = signature.equals(sign);</span><br><span class="line">        Assert.isTrue(flag, <span class="string">"签名错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 拒绝重复调用(第一次访问时存储，过期时间和请求超时时间保持一致), 只有标注不允许重复提交注解的才会校验</span></span><br><span class="line">        <span class="keyword">if</span> (notRepeatSubmit != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ValueOperations&lt;String, Integer&gt; signRedis = redisTemplate.opsForValue();</span><br><span class="line">            <span class="keyword">boolean</span> exists = redisTemplate.hasKey(sign);</span><br><span class="line">            Assert.isTrue(!exists, <span class="string">"请勿重复提交"</span>);</span><br><span class="line">            signRedis.set(sign, <span class="number">0</span>, expireTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-MD5Util-—-MD5工具类，加密生成数字签名"><a href="#6-MD5Util-—-MD5工具类，加密生成数字签名" class="headerlink" title="6. MD5Util —-MD5工具类，加密生成数字签名"></a>6. MD5Util —-MD5工具类，加密生成数字签名</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Util</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String hexDigits[] = &#123; <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>,</span><br><span class="line">            <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteArrayToHexString</span><span class="params">(<span class="keyword">byte</span> b[])</span> </span>&#123;</span><br><span class="line">        StringBuffer resultSb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++)</span><br><span class="line">            resultSb.append(byteToHexString(b[i]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultSb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToHexString</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = b;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            n += <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span> d1 = n / <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">int</span> d2 = n % <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> hexDigits[d1] + hexDigits[d2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encode(origin, <span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String origin, String charsetname)</span> </span>&#123;</span><br><span class="line">        String resultString = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resultString = <span class="keyword">new</span> String(origin);</span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="keyword">if</span> (charsetname == <span class="keyword">null</span> || <span class="string">""</span>.equals(charsetname))</span><br><span class="line">                resultString = byteArrayToHexString(md.digest(resultString</span><br><span class="line">                        .getBytes()));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                resultString = byteArrayToHexString(md.digest(resultString</span><br><span class="line">                        .getBytes(charsetname)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-NotRepeatSubmit-—–自定义注解，防止重复提交。"><a href="#7-NotRepeatSubmit-—–自定义注解，防止重复提交。" class="headerlink" title="7. @NotRepeatSubmit  —–自定义注解，防止重复提交。"></a>7. @NotRepeatSubmit  —–自定义注解，防止重复提交。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁止重复提交</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotRepeatSubmit &#123;</span><br><span class="line">    <span class="comment">/** 过期时间，单位毫秒 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 5000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-AccessToken"><a href="#8-AccessToken" class="headerlink" title="8. AccessToken"></a>8. AccessToken</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessToken</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** token */</span></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 失效时间 */</span></span><br><span class="line">    <span class="keyword">private</span> Date expireTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-AppInfo"><a href="#9-AppInfo" class="headerlink" title="9. AppInfo"></a>9. AppInfo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** App id */</span></span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="comment">/** API 秘钥 */</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-TokenInfo"><a href="#10-TokenInfo" class="headerlink" title="10. TokenInfo"></a>10. TokenInfo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** token类型: api:0 、user:1 */</span></span><br><span class="line">    <span class="keyword">private</span> Integer tokenType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** App 信息 */</span></span><br><span class="line">    <span class="keyword">private</span> AppInfo appInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用户其他数据 */</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-UserInfo"><a href="#11-UserInfo" class="headerlink" title="11. UserInfo"></a>11. UserInfo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 用户名 */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">/** 手机号 */</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">    <span class="comment">/** 邮箱 */</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">/** 密码 */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/** 盐 */</span></span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccessToken accessToken;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">(String username, String password, String salt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.salt = salt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-ApiCodeEnum"><a href="#12-ApiCodeEnum" class="headerlink" title="12. ApiCodeEnum"></a>12. ApiCodeEnum</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码code可以使用纯数字,使用不同区间标识一类错误，也可以使用纯字符，也可以使用前缀+编号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 错误码：ERR + 编号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以使用日志级别的前缀作为错误类型区分 Info(I) Error(E) Warning(W)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 或者以业务模块 + 错误号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * TODO 错误码设计</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Alipay 用了两个code，两个msg(https://docs.open.alipay.com/api_1/alipay.trade.pay)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ApiCodeEnum &#123;</span><br><span class="line">    SUCCESS(<span class="string">"10000"</span>, <span class="string">"success"</span>),</span><br><span class="line">    UNKNOW_ERROR(<span class="string">"ERR0001"</span>,<span class="string">"未知错误"</span>),</span><br><span class="line">    PARAMETER_ERROR(<span class="string">"ERR0002"</span>,<span class="string">"参数错误"</span>),</span><br><span class="line">    TOKEN_EXPIRE(<span class="string">"ERR0003"</span>,<span class="string">"认证过期"</span>),</span><br><span class="line">    REQUEST_TIMEOUT(<span class="string">"ERR0004"</span>,<span class="string">"请求超时"</span>),</span><br><span class="line">    SIGN_ERROR(<span class="string">"ERR0005"</span>,<span class="string">"签名错误"</span>),</span><br><span class="line">    REPEAT_SUBMIT(<span class="string">"ERR0006"</span>,<span class="string">"请不要频繁操作"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 代码 */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 结果 */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    ApiCodeEnum(String code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-ApiResult"><a href="#13-ApiResult" class="headerlink" title="13. ApiResult"></a>13. ApiResult</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 代码 */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 结果 */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-ApiUtil-——-这个参考支付宝加密的算法写的-我直接Copy过来了。"><a href="#14-ApiUtil-——-这个参考支付宝加密的算法写的-我直接Copy过来了。" class="headerlink" title="14. ApiUtil ——-这个参考支付宝加密的算法写的.我直接Copy过来了。"></a>14. ApiUtil ——-这个参考支付宝加密的算法写的.我直接Copy过来了。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按参数名升续拼接参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatSignString</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; paramterMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        request.getParameterMap().forEach((key, value) -&gt; paramterMap.put(key, value[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// 按照key升续排序，然后拼接参数</span></span><br><span class="line">        Set&lt;String&gt; keySet = paramterMap.keySet();</span><br><span class="line">        String[] keyArray = keySet.toArray(<span class="keyword">new</span> String[keySet.size()]);</span><br><span class="line">        Arrays.sort(keyArray);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String k : keyArray) &#123;</span><br><span class="line">            <span class="comment">// 或略掉的字段</span></span><br><span class="line">            <span class="keyword">if</span> (k.equals(<span class="string">"sign"</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (paramterMap.get(k).trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 参数值为空，则不参与签名</span></span><br><span class="line">                sb.append(k).append(<span class="string">"="</span>).append(paramterMap.get(k).trim()).append(<span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatSignString</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; paramterMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.forEach((key, value) -&gt; paramterMap.put(key, value));</span><br><span class="line">        <span class="comment">// 按照key升续排序，然后拼接参数</span></span><br><span class="line">        Set&lt;String&gt; keySet = paramterMap.keySet();</span><br><span class="line">        String[] keyArray = keySet.toArray(<span class="keyword">new</span> String[keySet.size()]);</span><br><span class="line">        Arrays.sort(keyArray);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String k : keyArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (paramterMap.get(k).trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 参数值为空，则不参与签名</span></span><br><span class="line">                sb.append(k).append(<span class="string">"="</span>).append(paramterMap.get(k).trim()).append(<span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取方法上的<span class="doctag">@NotRepeatSubmit</span>注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NotRepeatSubmit <span class="title">getNotRepeatSubmit</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">            HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            NotRepeatSubmit annotation = method.getAnnotation(NotRepeatSubmit.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> annotation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-ApiResponse"><a href="#15-ApiResponse" class="headerlink" title="15. ApiResponse"></a>15. ApiResponse</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 结果 */</span></span><br><span class="line">    <span class="keyword">private</span> ApiResult result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据 */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 签名 */</span></span><br><span class="line">    <span class="keyword">private</span> String sign;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse <span class="title">success</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response(ApiCodeEnum.SUCCESS.getCode(), ApiCodeEnum.SUCCESS.getMsg(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResponse <span class="title">error</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response(code, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse <span class="title">response</span><span class="params">(String code, String msg, T data)</span> </span>&#123;</span><br><span class="line">        ApiResult result = <span class="keyword">new</span> ApiResult(code, msg);</span><br><span class="line">        ApiResponse response = <span class="keyword">new</span> ApiResponse();</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        response.setData(data);</span><br><span class="line"></span><br><span class="line">        String sign = signData(data);</span><br><span class="line">        response.setSign(sign);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">signData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 查询key</span></span><br><span class="line">        String key = <span class="string">"12345678954556"</span>;</span><br><span class="line">        Map&lt;String, String&gt; responseMap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            responseMap = getFields(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String urlComponent = ApiUtil.concatSignString(responseMap);</span><br><span class="line">        String signature = urlComponent + <span class="string">"key="</span> + key;</span><br><span class="line">        String sign = MD5Util.encode(signature);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 反射的对象,获取对象的字段名和值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getFields</span><span class="params">(Object data)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Field[] fields = data.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            Field field = fields[i];</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            String name = field.getName();</span><br><span class="line">            Object value = field.get(data);</span><br><span class="line">            <span class="keyword">if</span> (field.get(data) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                map.put(name, value.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七-ThreadLocal"><a href="#七-ThreadLocal" class="headerlink" title="七: ThreadLocal"></a>七: ThreadLocal</h1><p>ThreadLocal是线程内的全局上下文。就是在单个线程中，方法之间共享的内存，每个方法都可以从该上下文中获取值和修改值。</p>
<h5 id="实际案例："><a href="#实际案例：" class="headerlink" title="实际案例："></a>实际案例：</h5><p>在调用api时都会传一个token参数，通常会写一个拦截器来校验token是否合法，我们可以通过token找到对应的用户信息(User)，如果token合法，然后将用户信息存储到ThreadLocal中，这样无论是在controller、service、dao的哪一层都能访问到该用户的信息。作用类似于Web中的request作用域。</p>
<p>传统方式我们要在方法中访问某个变量，可以通过传参的形式往方法中传参，如果多个方法都要使用那么每个方法都要传参；如果使用ThreadLocal所有方法就不需要传该参数了，每个方法都可以通过ThreadLocal来访问该值。</p>
<ul>
<li>ThreadLocalUtil.set(“key”, value); 保存值</li>
<li>T value = ThreadLocalUtil.get(“key”); 获取值</li>
</ul>
<p>ThreadLocalUtil</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUtil</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getThreadLocal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key,T defaultValue)</span> </span>&#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key) == <span class="keyword">null</span> ? defaultValue : (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Map&lt;String, Object&gt; keyValueMap)</span> </span>&#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        map.putAll(keyValueMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Map&lt;String,T&gt; <span class="title">fetchVarsByPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,T&gt; vars = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>( prefix == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> vars;</span><br><span class="line">        &#125;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        Set&lt;Map.Entry&gt; set = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( Map.Entry entry : set)&#123;</span><br><span class="line">            Object key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span>( key <span class="keyword">instanceof</span> String )&#123;</span><br><span class="line">                <span class="keyword">if</span>( ((String) key).startsWith(prefix) )&#123;</span><br><span class="line">                    vars.put((String)key,(T)entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( prefix == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        Set&lt;Map.Entry&gt; set = map.entrySet();</span><br><span class="line">        List&lt;String&gt; removeKeys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( Map.Entry entry : set )&#123;</span><br><span class="line">            Object key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span>( key <span class="keyword">instanceof</span> String )&#123;</span><br><span class="line">                <span class="keyword">if</span>( ((String) key).startsWith(prefix) )&#123;</span><br><span class="line">                    removeKeys.add((String)key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( String key : removeKeys )&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结: 这个是目前第三方数据接口交互过程中常用的一些参数与使用示例，希望对大家有点帮助。</strong></p>
<p><strong>当然如果为了保证更加的安全，可以加上RSA,RSA2，AES等等加密方式，保证了数据的更加的安全，但是唯一的缺点是加密与解密比较耗费CPU的资源.</strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava - 拯救垃圾代码，写出优雅高效，效率提升N倍</title>
    <url>/2021/01/24/java/Guava-%E6%8B%AF%E6%95%91%E5%9E%83%E5%9C%BE%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E9%AB%98%E6%95%88%EF%BC%8C%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87N%E5%80%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Guava</strong> 项目是 Google 公司开源的 Java 核心库，它主要是包含一些在 Java 开发中经常使用到的功能，如<strong>数据校验</strong>、<strong>不可变集合</strong>、计数集合，集合增强操作、I/O、缓存、字符串操作等。并且 <strong>Guava</strong> 广泛用于 Google 内部的 Java 项目中，也被其他公司广泛使用，甚至在新版 JDK 中直接引入了 <strong>Guava</strong> 中的优秀类库，所以质量毋庸置疑。</p>
<p>使用方式直接 mavan 依赖引入。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>30.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><p>数据校验说来十分简单，一是<strong>非空判断</strong>，二是<strong>预期值判断</strong>。非空判断我想每一个 Java 开发者都很熟悉，一开始都经常和 <code>NullPointException</code> 打交道。处理的方式我们自然是一个 <code>if( xx == null)</code> 就能轻松解决。预期值判断也是类似，检查数据值是不是自己想要的结果即可。</p>
<p>即使这么简单的操作，我们是不是还经常出错呢？而且写起来的代码总是一行判断一行异常抛出，怎么看都觉得那么优雅。还好，现在就来尝试第一次使用 Guava 吧。</p>
<a id="more"></a>
<h3 id="非空判断"><a href="#非空判断" class="headerlink" title="非空判断"></a>非空判断</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String param = <span class="string">"未读代码"</span>;</span><br><span class="line">String name = Preconditions.checkNotNull(param);</span><br><span class="line">System.out.println(name); <span class="comment">// 未读代码</span></span><br><span class="line">String param2 = <span class="keyword">null</span>;</span><br><span class="line">String name2 = Preconditions.checkNotNull(param2); <span class="comment">// NullPointerException</span></span><br><span class="line">System.out.println(name2);</span><br></pre></td></tr></table></figure>
<p>引入了 Guava 后可以直接使用 <code>Preconditions.checkNotNull</code> 进行非空判断，好处为觉得有两个，一是语义清晰代码优雅；二是你也可以自定义报错信息，这样如果参数为空，报错的信息清晰，可以直接定位到具体参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String param2 = <span class="keyword">null</span>;</span><br><span class="line">String name2 = Preconditions.checkNotNull(param2,<span class="string">"param2 is null"</span>);</span><br><span class="line"><span class="comment">// java.lang.NullPointerException: param2 is null</span></span><br></pre></td></tr></table></figure>
<h3 id="预期值判断"><a href="#预期值判断" class="headerlink" title="预期值判断"></a>预期值判断</h3><p>和非空判断类似，可以比较当前值和预期值，如果不相等可以自定义报错信息抛出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String param = <span class="string">"www.wdbyte.com2"</span>;</span><br><span class="line">String wdbyte = <span class="string">"www.wdbyte.com"</span>;</span><br><span class="line">Preconditions.checkArgument(wdbyte.equals(param), <span class="string">"[%s] 404 NOT FOUND"</span>, param);</span><br><span class="line"><span class="comment">// java.lang.IllegalArgumentException: [www.wdbyte.com2] 404 NOT FOUND</span></span><br></pre></td></tr></table></figure>
<h3 id="是否越界"><a href="#是否越界" class="headerlink" title="是否越界"></a>是否越界</h3><p><code>Preconditions</code> 类还可以用来检查数组和集合的元素获取是否越界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Guava 中快速创建ArrayList</span></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line"><span class="comment">// 开始校验</span></span><br><span class="line"><span class="keyword">int</span> index = Preconditions.checkElementIndex(<span class="number">5</span>, list.size());</span><br><span class="line"><span class="comment">// java.lang.IndexOutOfBoundsException: index (5) must be less than size (4)</span></span><br></pre></td></tr></table></figure>
<p>代码中快速创建 List 的方式也是 Guava 提供的，后面会详细介绍 Guava 中集合创建的超多姿势。</p>
<h2 id="不可变的集合"><a href="#不可变的集合" class="headerlink" title="不可变的集合"></a>不可变的集合</h2><p>创建不可变集合是我个人最喜欢 Guava 的一个原因，因为创建一个<strong>不能删除、不能修改、不能增加元素</strong>的集合实在是太实用了。这样的集合你完全不用担心发生什么问题，总的来说有下面几个优点：</p>
<ol>
<li>线程安全，因为不能修改任何元素，可以随意多线程使用且没有并发问题。</li>
<li>可以无忧的提供给第三方使用，反正修改不了。</li>
<li>减少内存占用，因为不能改变，所以内部实现可以最大程度节约内存占用。</li>
<li>可以用作常量集合。</li>
</ol>
<h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p>说了那么多，那么到底怎么使用呢？赶紧撸起代码来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建方式1：of</span></span><br><span class="line">ImmutableSet&lt;String&gt; immutableSet = ImmutableSet.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">immutableSet.forEach(System.out::println);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建方式2：builder</span></span><br><span class="line">ImmutableSet&lt;String&gt; immutableSet2 = ImmutableSet.&lt;String&gt;builder()</span><br><span class="line">    .add(<span class="string">"hello"</span>)</span><br><span class="line">    .add(<span class="keyword">new</span> String(<span class="string">"未读代码"</span>))</span><br><span class="line">    .build();</span><br><span class="line">immutableSet2.forEach(System.out::println);</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// 未读代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建方式3：从其他集合中拷贝创建</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"www.wdbyte.com"</span>);</span><br><span class="line">arrayList.add(<span class="string">"https"</span>);</span><br><span class="line">ImmutableSet&lt;String&gt; immutableSet3 = ImmutableSet.copyOf(arrayList);</span><br><span class="line">immutableSet3.forEach(System.out::println);</span><br><span class="line"><span class="comment">// www.wdbyte.com</span></span><br><span class="line"><span class="comment">// https</span></span><br></pre></td></tr></table></figure>
<p>都可以正常打印遍历结果，但是如果进行增删改，会直接报 <code>UnsupportedOperationException</code>.</p>
<p>其实 JDK 中也提供了一个不可变集合，可以像下面这样创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"www.wdbyte.com"</span>);</span><br><span class="line">arrayList.add(<span class="string">"https"</span>);</span><br><span class="line"><span class="comment">// JDK Collections 创建不可变 List</span></span><br><span class="line">List&lt;String&gt; list = Collections.unmodifiableList(arrayList);</span><br><span class="line">list.forEach(System.out::println);<span class="comment">// www.wdbyte.com https</span></span><br><span class="line">list.add(<span class="string">"未读代码"</span>); <span class="comment">// java.lang.UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>使用 Guava 创建的不可变集合是拒绝 <code>null</code> 值的，因为在 Google 内部调查中，95% 的情况下都不需要放入 <code>null</code> 值。</li>
<li>使用 JDK 提供的不可变集合创建成功后，原集合添加元素会体现在不可变集合中，而 Guava 的不可变集合不会有这个问题。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">"a"</span>);</span><br><span class="line">arrayList.add(<span class="string">"b"</span>);</span><br><span class="line">List&lt;String&gt; jdkList = Collections.unmodifiableList(arrayList);</span><br><span class="line">ImmutableList&lt;String&gt; immutableList = ImmutableList.copyOf(arrayList);</span><br><span class="line">arrayList.add(<span class="string">"ccc"</span>);</span><br><span class="line">jdkList.forEach(System.out::println);<span class="comment">// result: a b ccc</span></span><br><span class="line">System.out.println(<span class="string">"-------"</span>);</span><br><span class="line">immutableList.forEach(System.out::println);<span class="comment">// result: a b</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果不可变集合的元素是引用对象，那么引用对象的属性是可以更改的。</li>
</ol>
<p><strong>其他不可变集合</strong></p>
<p>不可变集合除了上面演示的 <code>set</code> 之外，还有很多不可变集合，下面是 Guava 中不可变集合和其他集合的对应关系。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>可变集合接口</strong></th>
<th style="text-align:left">属于JDK还是Guava</th>
<th style="text-align:left"><strong>不可变版本</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Collection</td>
<td style="text-align:left">JDK</td>
<td style="text-align:left"><code>ImmutableCollection</code></td>
</tr>
<tr>
<td style="text-align:left">List</td>
<td style="text-align:left">JDK</td>
<td style="text-align:left"><code>ImmutableList</code></td>
</tr>
<tr>
<td style="text-align:left">Set</td>
<td style="text-align:left">JDK</td>
<td style="text-align:left"><code>ImmutableSet</code></td>
</tr>
<tr>
<td style="text-align:left">SortedSet/NavigableSet</td>
<td style="text-align:left">JDK</td>
<td style="text-align:left"><code>ImmutableSortedSet</code></td>
</tr>
<tr>
<td style="text-align:left">Map</td>
<td style="text-align:left">JDK</td>
<td style="text-align:left"><code>ImmutableMap</code></td>
</tr>
<tr>
<td style="text-align:left">SortedMap</td>
<td style="text-align:left">JDK</td>
<td style="text-align:left"><code>ImmutableSortedMap</code></td>
</tr>
<tr>
<td style="text-align:left">Multiset</td>
<td style="text-align:left">Guava</td>
<td style="text-align:left"><code>ImmutableMultiset</code></td>
</tr>
<tr>
<td style="text-align:left">SortedMultiset</td>
<td style="text-align:left">Guava</td>
<td style="text-align:left"><code>ImmutableSortedMultiset</code></td>
</tr>
<tr>
<td style="text-align:left">Multimap</td>
<td style="text-align:left">Guava</td>
<td style="text-align:left"><code>ImmutableMultimap</code></td>
</tr>
<tr>
<td style="text-align:left">ListMultimap</td>
<td style="text-align:left">Guava</td>
<td style="text-align:left"><code>ImmutableListMultimap</code></td>
</tr>
<tr>
<td style="text-align:left">SetMultimap</td>
<td style="text-align:left">Guava</td>
<td style="text-align:left"><code>ImmutableSetMultimap</code></td>
</tr>
<tr>
<td style="text-align:left">BiMap</td>
<td style="text-align:left">Guava</td>
<td style="text-align:left"><code>ImmutableBiMap</code></td>
</tr>
<tr>
<td style="text-align:left">ClassToInstanceMap</td>
<td style="text-align:left">Guava</td>
<td style="text-align:left"><code>ImmutableClassToInstanceMap</code></td>
</tr>
<tr>
<td style="text-align:left">Table</td>
<td style="text-align:left">Guava</td>
<td style="text-align:left"><code>ImmutableTable</code></td>
</tr>
</tbody>
</table>
<h2 id="集合操作工厂"><a href="#集合操作工厂" class="headerlink" title="集合操作工厂"></a>集合操作工厂</h2><p>其实这里只会介绍一个创建方法，但是为什么还是单独拿出来介绍了呢？看下去你就会<strong>大呼好用</strong>。虽然 JDK 中已经提供了大量的集合相关的操作方法，用起来也是非常的方便，但是 Guava 还是增加了一些十分好用的方法，保证让你用上一次就爱不释手，</p>
<h3 id="创建集合。"><a href="#创建集合。" class="headerlink" title="创建集合。"></a>创建集合。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 ArrayList 集合</span></span><br><span class="line">List&lt;String&gt; list1 = Lists.newArrayList();</span><br><span class="line"><span class="comment">// 创建一个 ArrayList 集合，同时塞入3个数据</span></span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"><span class="comment">// 创建一个 ArrayList 集合，容量初始化为10</span></span><br><span class="line">List&lt;String&gt; list3 = Lists.newArrayListWithCapacity(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; linkedList1 = Lists.newLinkedList();</span><br><span class="line">CopyOnWriteArrayList&lt;String&gt; cowArrayList = Lists.newCopyOnWriteArrayList();</span><br><span class="line"></span><br><span class="line">HashMap&lt;Object, Object&gt; hashMap = Maps.newHashMap();</span><br><span class="line">ConcurrentMap&lt;Object, Object&gt; concurrentMap = Maps.newConcurrentMap();</span><br><span class="line">TreeMap&lt;Comparable, Object&gt; treeMap = Maps.newTreeMap();</span><br><span class="line"></span><br><span class="line">HashSet&lt;Object&gt; hashSet = Sets.newHashSet();</span><br><span class="line">HashSet&lt;String&gt; newHashSet = Sets.newHashSet(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br></pre></td></tr></table></figure>
<p>Guava 为每一个集合都添加了工厂方法创建方式，上面已经展示了部分集合的工厂方法创建方式。是不是十分的好用呢。而且可以在创建时直接扔进去几个元素，这个简直太赞了，再也不用一个个 <code>add</code> 了。</p>
<h3 id="集合交集并集差集"><a href="#集合交集并集差集" class="headerlink" title="集合交集并集差集"></a>集合交集并集差集</h3><p>过于简单，直接看代码和输出结果吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; newHashSet1 = Sets.newHashSet(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">Set&lt;String&gt; newHashSet2 = Sets.newHashSet(<span class="string">"b"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line">SetView&lt;String&gt; intersectionSet = Sets.intersection(newHashSet1, newHashSet2);</span><br><span class="line">System.out.println(intersectionSet); <span class="comment">// [b, c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line">SetView&lt;String&gt; unionSet = Sets.union(newHashSet1, newHashSet2);</span><br><span class="line">System.out.println(unionSet); <span class="comment">// [a, b, c, d]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// newHashSet1 中存在，newHashSet2 中不存在</span></span><br><span class="line">SetView&lt;String&gt; setView = Sets.difference(newHashSet1, newHashSet2);</span><br><span class="line">System.out.println(setView); <span class="comment">// [a]</span></span><br></pre></td></tr></table></figure>
<h2 id="有数量的集合"><a href="#有数量的集合" class="headerlink" title="有数量的集合"></a>有数量的集合</h2><p>这个真的太有用了，因为我们经常会需要设计可以计数的集合，或者 value 是 <code>List</code> 的 <code>Map</code>集合，如果说你不太明白，看下面这段代码，是否某天夜里你也这样写过。</p>
<ol>
<li><p>统计相同元素出现的次数（下面的代码我已经尽可能精简写法了）。</p>
<p>JDK 原生写法：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 统计相同元素出现的次数。</span></span><br><span class="line">List&lt;String&gt; words = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>);</span><br><span class="line">Map&lt;String, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    Integer count = countMap.get(word);</span><br><span class="line">    count = (count == <span class="keyword">null</span>) ? <span class="number">1</span> : ++count;</span><br><span class="line">    countMap.put(word, count);</span><br><span class="line">&#125;</span><br><span class="line">countMap.forEach((k, v) -&gt; System.out.println(k + <span class="string">":"</span> + v));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result:</span></span><br><span class="line"><span class="comment"> * a:2</span></span><br><span class="line"><span class="comment"> * b:1</span></span><br><span class="line"><span class="comment"> * c:2</span></span><br><span class="line"><span class="comment"> * d:1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>尽管已经尽量优化代码，代码量还是不少的，那么在 Guava 中有什么不一样呢？在 Guava. 中主要是使用 <code>HashMultiset</code> 类，看下面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>);</span><br><span class="line">HashMultiset&lt;String&gt; multiset = HashMultiset.create(arrayList);</span><br><span class="line">multiset.elementSet().forEach(s -&gt; System.out.println(s + <span class="string">":"</span> + multiset.count(s)));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result:</span></span><br><span class="line"><span class="comment"> * a:2</span></span><br><span class="line"><span class="comment"> * b:1</span></span><br><span class="line"><span class="comment"> * c:2</span></span><br><span class="line"><span class="comment"> * d:1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>是的，只要把元素添加进去就行了，不用在乎是否重复，最后都可以使用 <code>count</code> 方法统计重复元素数量。看着舒服，写着优雅，<code>HashMultiset</code> 是 Guava 中实现的 <code>Collection</code> 类，可以轻松统计元素数量。</p>
<ol>
<li><p>一对多，value 是 <code>List</code> 的 <code>Map</code> 集合。</p>
<p>假设一个场景，需要把很多动物按照种类进行分类，我相信最后你会写出类似的代码。</p>
<p>JDK 原生写法：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Set&lt;String&gt;&gt; animalMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">HashSet&lt;String&gt; dogSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">dogSet.add(<span class="string">"旺财"</span>);</span><br><span class="line">dogSet.add(<span class="string">"大黄"</span>);</span><br><span class="line">animalMap.put(<span class="string">"狗"</span>, dogSet);</span><br><span class="line">HashSet&lt;String&gt; catSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">catSet.add(<span class="string">"加菲"</span>);</span><br><span class="line">catSet.add(<span class="string">"汤姆"</span>);</span><br><span class="line">animalMap.put(<span class="string">"猫"</span>, catSet);</span><br><span class="line">System.out.println(animalMap.get(<span class="string">"猫"</span>)); <span class="comment">// [加菲, 汤姆]</span></span><br></pre></td></tr></table></figure>
<p>最后一行查询猫得到了猫类的 “加菲” 和 ”汤姆“。这个代码简直太烦做了，如果使用 Guava 呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use guava</span></span><br><span class="line">HashMultimap&lt;String, String&gt; multimap = HashMultimap.create();</span><br><span class="line">multimap.put(<span class="string">"狗"</span>, <span class="string">"大黄"</span>);</span><br><span class="line">multimap.put(<span class="string">"狗"</span>, <span class="string">"旺财"</span>);</span><br><span class="line">multimap.put(<span class="string">"猫"</span>, <span class="string">"加菲"</span>);</span><br><span class="line">multimap.put(<span class="string">"猫"</span>, <span class="string">"汤姆"</span>);</span><br><span class="line">System.out.println(multimap.get(<span class="string">"猫"</span>)); <span class="comment">// [加菲, 汤姆]</span></span><br></pre></td></tr></table></figure>
<p>HashMultimap 可以扔进去重复的 key 值，最后获取时可以得到所有的 value 值，可以看到输出结果和 JDK 写法上是一样的，但是代码已经无比清爽。</p>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>作为开发中最长使用的数据类型，字符串操作的增强可以让开发更加高效。</p>
<h3 id="字符拼接"><a href="#字符拼接" class="headerlink" title="字符拼接"></a>字符拼接</h3><p>JDK 8 中其实已经内置了字符串拼接方法，但是它只是简单的拼接，没有额外操作，比如过滤掉 null 元素，去除前后空格等。先看一下 JDK 8 中字符串拼接的几种方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK 方式一</span></span><br><span class="line">ArrayList&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="keyword">null</span>);</span><br><span class="line">String join = String.join(<span class="string">","</span>, list);</span><br><span class="line">System.out.println(join); <span class="comment">// a,b,c,null</span></span><br><span class="line"><span class="comment">// JDK 方式二</span></span><br><span class="line">String result = list.stream().collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">System.out.println(result); <span class="comment">// a,b,c,null</span></span><br><span class="line"><span class="comment">// JDK 方式三</span></span><br><span class="line">StringJoiner stringJoiner = <span class="keyword">new</span> StringJoiner(<span class="string">","</span>);</span><br><span class="line">list.forEach(stringJoiner::add);</span><br><span class="line">System.out.println(stringJoiner.toString()); <span class="comment">// a,b,c,null</span></span><br></pre></td></tr></table></figure>
<p>可以看到 null 值也被拼接到了字符串里，这有时候不是我们想要的，那么使用 Guava 有什么不一样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="keyword">null</span>);</span><br><span class="line">String join = Joiner.on(<span class="string">","</span>).skipNulls().join(list);</span><br><span class="line">System.out.println(join); <span class="comment">// a,b,c</span></span><br><span class="line"></span><br><span class="line">String join1 = Joiner.on(<span class="string">","</span>).useForNull(<span class="string">"空值"</span>).join(<span class="string">"旺财"</span>, <span class="string">"汤姆"</span>, <span class="string">"杰瑞"</span>, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(join1); <span class="comment">// 旺财,汤姆,杰瑞,空值</span></span><br></pre></td></tr></table></figure>
<p>可以看到使用 <code>skipNulls()</code> 可以跳过空值，使用 <code>useFornull(String)</code> 可以为空值自定义显示文本。</p>
<h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><p>JDK 中是自带字符串分割的，我想你也一定用过，那就是 String 的 split 方法，但是这个方法有一个问题，就是如果最后一个元素为空，那么就会丢弃，奇怪的是第一个元素为空却不会丢弃，这就十分迷惑，下面通过一个例子演示这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">",a,,b,"</span>;</span><br><span class="line">String[] splitArr = str.split(<span class="string">","</span>);</span><br><span class="line">Arrays.stream(splitArr).forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">"------"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * a</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * b</span></span><br><span class="line"><span class="comment"> * ------</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>你也可以自己测试下，最后一个元素不是空，直接消失了。</p>
<p>如果使用 Guava 是怎样的操作方式呢？Guava 提供了 Splitter 类，并且有一系列的操作方式可以直观的控制分割逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">",a ,,b ,"</span>;</span><br><span class="line">Iterable&lt;String&gt; split = Splitter.on(<span class="string">","</span>)</span><br><span class="line">    .omitEmptyStrings() <span class="comment">// 忽略空值</span></span><br><span class="line">    .trimResults() <span class="comment">// 过滤结果中的空白</span></span><br><span class="line">    .split(str);</span><br><span class="line">split.forEach(System.out::println);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * a</span></span><br><span class="line"><span class="comment"> * b</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在开发中我们可能需要使用小规模的缓存，来提高访问速度。这时引入专业的缓存中间件可能又觉得浪费。现在可以了， Guava 中提供了简单的缓存类，且可以根据预计容量、过期时间等自动过期已经添加的元素。即使这样我们也要预估好可能占用的内存空间，以防内存占用过多。</p>
<p>现在看一下在 Guava 中缓存该怎么用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    CacheLoader cacheLoader = <span class="keyword">new</span> CacheLoader&lt;String, Animal&gt;() &#123;</span><br><span class="line">        <span class="comment">// 如果找不到元素，会调用这里</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Animal <span class="title">load</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    LoadingCache&lt;String, Animal&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">1000</span>) <span class="comment">// 容量</span></span><br><span class="line">        .expireAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS) <span class="comment">// 过期时间</span></span><br><span class="line">        .removalListener(<span class="keyword">new</span> MyRemovalListener()) <span class="comment">// 失效监听器</span></span><br><span class="line">        .build(cacheLoader); <span class="comment">//</span></span><br><span class="line">    loadingCache.put(<span class="string">"狗"</span>, <span class="keyword">new</span> Animal(<span class="string">"旺财"</span>, <span class="number">1</span>));</span><br><span class="line">    loadingCache.put(<span class="string">"猫"</span>, <span class="keyword">new</span> Animal(<span class="string">"汤姆"</span>, <span class="number">3</span>));</span><br><span class="line">    loadingCache.put(<span class="string">"狼"</span>, <span class="keyword">new</span> Animal(<span class="string">"灰太狼"</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    loadingCache.invalidate(<span class="string">"猫"</span>); <span class="comment">// 手动失效</span></span><br><span class="line"></span><br><span class="line">    Animal animal = loadingCache.get(<span class="string">"狼"</span>);</span><br><span class="line">    System.out.println(animal);</span><br><span class="line">    Thread.sleep(<span class="number">4</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 狼已经自动过去，获取为 null 值报错</span></span><br><span class="line">    System.out.println(loadingCache.get(<span class="string">"狼"</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key=猫,value=Animal&#123;name='汤姆', age=3&#125;,reason=EXPLICIT</span></span><br><span class="line"><span class="comment">     * Animal&#123;name='灰太狼', age=4&#125;</span></span><br><span class="line"><span class="comment">     * key=狗,value=Animal&#123;name='旺财', age=1&#125;,reason=EXPIRED</span></span><br><span class="line"><span class="comment">     * key=狼,value=Animal&#123;name='灰太狼', age=4&#125;,reason=EXPIRED</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * com.google.common.cache.CacheLoader$InvalidCacheLoadException: CacheLoader returned null for key 狼.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存移除监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRemovalListener</span> <span class="keyword">implements</span> <span class="title">RemovalListener</span>&lt;<span class="title">String</span>, <span class="title">Animal</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;String, Animal&gt; notification)</span> </span>&#123;</span><br><span class="line">        String reason = String.format(<span class="string">"key=%s,value=%s,reason=%s"</span>, notification.getKey(), notification.getValue(), notification.getCause());</span><br><span class="line">        System.out.println(reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Animal&#123;"</span> +</span><br><span class="line">            <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">", age="</span> + age +</span><br><span class="line">            <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中主要分为 CacheLoader、MyRemovalListener、LoadingCache。</p>
<p>CacheLoader 中重写了 <code>load</code> 方法，这个方法会在查询缓存没有命中时被调用，我这里直接返回了 <code>null</code>，其实这样会在没有命中时抛出 <code>CacheLoader returned null for key</code> 异常信息。</p>
<p>MyRemovalListener 作为缓存元素失效时的监听类，在有元素缓存失效时会自动调用 <code>onRemoval</code> 方法，这里需要注意的是这个方法是同步方法，如果这里耗时较长，会阻塞直到处理完成。</p>
<p>LoadingCache 就是缓存的主要操作对象了，常用的就是其中的 <code>put</code> 和 <code>get</code> 方法了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面介绍了我认为最常用的 Guava 功能，Guava 作为 Google 公司开源的 Java 开发核心库，个人觉得实用性还是很高的。引入后不仅能快速的实现一些开发中常用的功能，而且还可以让代码更加的优雅简洁。我觉得适用于每一个 Java 项目。Guava 的其他的功能你也可以自己去发现。它的 Github 地址是：<a href="https://github.com/google/guava" target="_blank" rel="noopener">https://github.com/google/guava</a>.</p>
<p><strong>参考</strong></p>
<ol>
<li><a href="https://github.com/google/guava/wiki" target="_blank" rel="noopener">https://github.com/google/guava/wiki</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8~14的有哪些重要的新特性</title>
    <url>/2020/05/07/java/Java8-14%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java9"><a href="#Java9" class="headerlink" title="Java9"></a>Java9</h2><p>发布于 2017 年 9 月 21 日 。作为 Java8 之后 3 年半才发布的新版本，Java 9 带 来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入,其他还有诸如集合、Stream 流</p>
<h3 id="Java-平台模块系统"><a href="#Java-平台模块系统" class="headerlink" title="Java 平台模块系统"></a>Java 平台模块系统</h3><p>Java 平台模块系统，也就是 Project Jigsaw，把模块化开发实践引入到了 Java 平台中。在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。</p>
<p>Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。</p>
<h3 id="Jshell"><a href="#Jshell" class="headerlink" title="Jshell"></a>Jshell</h3><p>jshell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。</p>
<p>在 Jshell 中可以直接输入表达式并查看其执行结果</p>
<h3 id="集合、Stream-和-Optional"><a href="#集合、Stream-和-Optional" class="headerlink" title="集合、Stream 和 Optional"></a>集合、Stream 和 Optional</h3><ul>
<li>增加 了 <code>List.of()</code>、<code>Set.of()</code>、<code>Map.of()</code> 和 <code>Map.ofEntries()</code>等工厂方法来创建不可变集合，比如<code>List.of(&quot;Java&quot;, &quot;C++&quot;);</code>、<code>Map.of(&quot;Java&quot;, 1, &quot;C++&quot;, 2)</code>;（这部分内容有点参考 Guava 的味道）</li>
<li><code>Stream</code> 中增加了新的方法 <code>ofNullable</code>、<code>dropWhile</code>、<code>takeWhile</code> 和 <code>iterate</code> 方法。<code>Collectors</code> 中增加了新的方法 <code>filtering</code> 和 <code>flatMapping</code></li>
<li><code>Optional</code> 类中新增了 <code>ifPresentOrElse</code>、<code>or</code> 和 <code>stream</code> 等方法</li>
</ul>
<h3 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h3><p>Java 9 增加了 <code>ProcessHandle</code> 接口，可以对原生进程进行管理，尤其适合于管理长时间运行的进程</p>
<a id="more"></a>
<h3 id="平台日志-API-和服务"><a href="#平台日志-API-和服务" class="headerlink" title="平台日志 API 和服务"></a>平台日志 API 和服务</h3><p>Java 9 允许为 JDK 和应用配置同样的日志实现。新增了 <code>System.LoggerFinder</code>用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 <code>LoggerFinder</code> 实例。</p>
<p>我们可以通过添加自己的 <code>System.LoggerFinder</code> 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。</p>
<h3 id="反应式流-（-Reactive-Streams-）"><a href="#反应式流-（-Reactive-Streams-）" class="headerlink" title="反应式流 （ Reactive Streams ）"></a>反应式流 （ Reactive Streams ）</h3><ul>
<li>在 Java9 中的 <code>java.util.concurrent.Flow</code> 类中新增了反应式流规范的核心接口</li>
<li>Flow 中包含了 <code>Flow.Publisher</code>、<code>Flow.Subscriber</code>、<code>Flow.Subscription</code>和 <code>Flow.Processor</code> 等 4 个核心接口。Java 9 还提供了<code>SubmissionPublisher</code> 作为<code>Flow.Publisher</code> 的一个实现。</li>
</ul>
<h3 id="变量句柄"><a href="#变量句柄" class="headerlink" title="变量句柄"></a>变量句柄</h3><ul>
<li>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等</li>
<li>变量句柄的含义类似于已有的方法句柄<code>MethodHandle</code></li>
<li>由 Java 类<code>java.lang.invoke.VarHandle</code> 来表示，可以使用类 <code>java.lang.invoke.MethodHandles.Lookup</code> 中的静态工厂方法来创建 <code>VarHandle</code> 对 象</li>
</ul>
<h3 id="改进方法句柄（Method-Handle）"><a href="#改进方法句柄（Method-Handle）" class="headerlink" title="改进方法句柄（Method Handle）"></a>改进方法句柄（Method Handle）</h3><ul>
<li>方法句柄从 Java7 开始引入，Java9 在类<code>java.lang.invoke.MethodHandles</code>中新增了更多的静态方法来创建不同类型的方法句柄</li>
</ul>
<h3 id="其它新特性"><a href="#其它新特性" class="headerlink" title="其它新特性"></a>其它新特性</h3><ul>
<li><strong>接口私有方法</strong> ：Java 9 允许在接口中使用私有方法</li>
<li><strong>try-with-resources 增强</strong> ：在 try-with-resources 语句中可以使用 effectively-final 变量（什么是 effectively-final 变量，见这篇文章 <a href="http://ilkinulas.github.io/programming/java/2016/03/27/effectively-final-java.html）" target="_blank" rel="noopener">http://ilkinulas.github.io/programming/java/2016/03/27/effectively-final-java.html）</a></li>
<li><strong>类 <code>CompletableFuture</code> 中增加了几个新的方法（<code>completeAsync</code> ，<code>orTimeout</code> 等）</strong></li>
<li><strong>Nashorn 引擎的增强</strong> ：Nashorn 从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性</li>
<li><strong>I/O 流的新特性</strong> ：增加了新的方法来读取和复制 InputStream 中包含的数据</li>
<li><strong>改进应用的安全性能</strong> ：Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 S HA3-512</li>
<li>……</li>
</ul>
<h2 id="Java10"><a href="#Java10" class="headerlink" title="Java10"></a>Java10</h2><p>发布于 2018 年 3 月 20 日，最知名的特性应该是 var 关键字（局部变量类型推断）的引入了，其他还有垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性</p>
<h3 id="var-关键字"><a href="#var-关键字" class="headerlink" title="var 关键字"></a>var 关键字</h3><ul>
<li><strong>介绍</strong> :提供了 var 关键字声明局部变量：<code>var list = new ArrayList(); // ArrayList</code></li>
<li><strong>局限性</strong> ：只能用于带有构造器的<strong>局部变量</strong>和 for 循环中</li>
</ul>
<p><em>Guide 哥：实际上 Lombok 早就体用了一个类似的关键字，使用它可以简化代码，但是可能会降低程序的易读性、可维护性。一般情况下，我个人都不太推荐使用。</em></p>
<h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p><strong>list，set，map 提供了静态方法<code>copyOf()</code>返回入参集合的一个不可变拷贝（以下为 JDK 的源码）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ImmutableCollections.listCopy(coll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>java.util.stream.Collectors</code>中新增了静态方法，用于将流中的元素收集为不可变的集合</strong></p>
<h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><ul>
<li>新增了<code>orElseThrow()</code>方法来在没有值时抛出异常</li>
</ul>
<h3 id="并行全垃圾回收器-G1"><a href="#并行全垃圾回收器-G1" class="headerlink" title="并行全垃圾回收器 G1"></a>并行全垃圾回收器 G1</h3><p>从 Java9 开始 G1 就了默认的垃圾回收器，G1 是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC,但是 Java9 的 G1 的 FullGC 依然是使用单线程去完成标记清除算法,这可能会导致垃圾回收期在无法回收内存的时候触发 Full GC。</p>
<p>为了最大限度地减少 Full GC 造成的应用停顿的影响，从 Java10 开始，G1 的 FullGC 改为并行的标记清除算法，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。</p>
<h3 id="应用程序类数据共享"><a href="#应用程序类数据共享" class="headerlink" title="应用程序类数据共享"></a>应用程序类数据共享</h3><p>在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用</p>
<p>Java 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS (Application Class-Data Sharing) 支持。其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升</p>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul>
<li><strong>线程-局部管控</strong>：Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程</li>
<li><strong>备用存储装置上的堆分配</strong>：Java 10 中将使得 JVM 能够使用适用于不同类型的存储机制的堆，在可选内存设备上进行堆内存分配</li>
<li><strong>统一的垃圾回收接口</strong>：Java 10 中，hotspot/gc 代码实现方面，引入一个干净的 GC 接口，改进不同 GC 源代码的隔离性，多个 GC 之间共享的实现细节代码应该存在于辅助类中。统一垃圾回收接口的主要原因是：让垃圾回收器（GC）这部分代码更加整洁，便于新人上手开发，便于后续排查相关问题。</li>
</ul>
<h2 id="Java11"><a href="#Java11" class="headerlink" title="Java11"></a>Java11</h2><p>Java11 于 2018 年 9 月 25 日正式发布，这是很重要的一个版本！Java 11 和 2017 年 9 月份发布的 Java 9 以及 2018 年 3 月份发布的 Java 10 相比，其最大的区别就是：在长期支持(Long-Term-Support)方面，<strong>Oracle 表示会对 Java 11 提供大力支持，这一支持将会持续至 2026 年 9 月。这是据 Java 8 以后支持的首个长期版本。</strong></p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>
<h3 id="字符串加强"><a href="#字符串加强" class="headerlink" title="字符串加强"></a>字符串加强</h3><p>Java 11 增加了一系列的字符串处理方法，如以下所示。</p>
<p><em>Guide 哥：说白点就是多了层封装，JDK 开发组的人没少看市面上常见的工具类框架啊!</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//判断字符串是否为空</span><br><span class="line">&quot; &quot;.isBlank();//true</span><br><span class="line">//去除字符串首尾空格</span><br><span class="line">&quot; Java &quot;.strip();// &quot;Java&quot; </span><br><span class="line">//去除字符串首部空格</span><br><span class="line">&quot; Java &quot;.stripLeading();   // &quot;Java &quot;  </span><br><span class="line">//去除字符串尾部空格</span><br><span class="line">&quot; Java &quot;.stripTrailing();  // &quot; Java&quot;  </span><br><span class="line">//重复字符串多少次</span><br><span class="line">&quot;Java&quot;.repeat(3);             // &quot;JavaJavaJava&quot;  </span><br><span class="line"></span><br><span class="line">//返回由行终止符分隔的字符串集合。</span><br><span class="line">&quot;A\nB\nC&quot;.lines().count();    // 3 </span><br><span class="line">&quot;A\nB\nC&quot;.lines().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h3 id="ZGC：可伸缩低延迟垃圾收集器"><a href="#ZGC：可伸缩低延迟垃圾收集器" class="headerlink" title="ZGC：可伸缩低延迟垃圾收集器"></a>ZGC：可伸缩低延迟垃圾收集器</h3><p><strong>ZGC 即 Z Garbage Collector</strong>，是一个可伸缩的、低延迟的垃圾收集器。</p>
<p>ZGC 主要为了满足如下目标进行设计：</p>
<ul>
<li>GC 停顿时间不超过 10ms</li>
<li>即能处理几百 MB 的小堆，也能处理几个 TB 的大堆</li>
<li>应用吞吐能力不会下降超过 15%（与 G1 回收算法相比）</li>
<li>方便在此基础上引入新的 GC 特性和利用 colord</li>
<li>针以及 Load barriers 优化奠定基础</li>
<li>当前只支持 Linux/x64 位平台</li>
</ul>
<p>ZGC 目前 <strong>处在实验阶段</strong>，只支持 Linux/x64 平台</p>
<h3 id="标准-HTTP-Client-升级"><a href="#标准-HTTP-Client-升级" class="headerlink" title="标准 HTTP Client 升级"></a>标准 HTTP Client 升级</h3><p>Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。</p>
<p>并且，Java11 中，Http Client 的包名由 <code>jdk.incubator.http</code> 改为<code>java.net.http</code>，该 API 通过 <code>CompleteableFuture</code> 提供非阻塞请求和响应语义。</p>
<p>使用起来也很简单，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">var request = HttpRequest.newBuilder()  </span><br><span class="line"></span><br><span class="line">    .uri(URI.create(<span class="string">"https://javastack.cn"</span>))  </span><br><span class="line"></span><br><span class="line">    .GET()  </span><br><span class="line"></span><br><span class="line">    .build();  </span><br><span class="line"></span><br><span class="line">var client = HttpClient.newHttpClient();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步  </span></span><br><span class="line"></span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());  </span><br><span class="line"></span><br><span class="line">System.out.println(response.body());  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步  </span></span><br><span class="line"></span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())  </span><br><span class="line"></span><br><span class="line">    .thenApply(HttpResponse::body)  </span><br><span class="line"></span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="简化启动单个源代码文件的方法"><a href="#简化启动单个源代码文件的方法" class="headerlink" title="简化启动单个源代码文件的方法"></a>简化启动单个源代码文件的方法</h3><ul>
<li>增强了 Java 启动器，使其能够运行单一文件的 Java 源代码。此功能允许使用 Java 解释器直接执行 Java 源代码。源代码在内存中编译，然后由解释器执行。唯一的约束在于所有相关的类必须定义在同一个 Java 文件中</li>
<li>对于 Java 初学者并希望尝试简单程序的人特别有用，并且能和 jshell 一起使用</li>
<li>一定能程度上增强了使用 Java 来写脚本程序的能力</li>
</ul>
<h3 id="用于-Lambda-参数的局部变量语法"><a href="#用于-Lambda-参数的局部变量语法" class="headerlink" title="用于 Lambda 参数的局部变量语法"></a>用于 Lambda 参数的局部变量语法</h3><ul>
<li><p>从 Java 10 开始，便引入了局部变量类型推断这一关键特性。类型推断允许使用关键字 var 作为局部变量的类型而不是实际类型，编译器根据分配给变量的值推断出类型</p>
</li>
<li><p>Java 10 中对 var 关键字存在几个限制</p>
</li>
<li><ul>
<li>只能用于局部变量上</li>
<li>声明时必须初始化</li>
<li>不能用作方法参数</li>
<li>不能在 Lambda 表达式中使用</li>
</ul>
</li>
<li><p>Java11 开始允许开发者在 Lambda 表达式中使用 var 进行参数声明</p>
</li>
</ul>
<h3 id="其他特性-1"><a href="#其他特性-1" class="headerlink" title="其他特性"></a>其他特性</h3><ul>
<li>新的垃圾回收器 Epsilon，一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间</li>
<li>低开销的 Heap Profiling：Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息</li>
<li>TLS1.3 协议：Java 11 中包含了传输层安全性（TLS）1.3 规范（RFC 8446）的实现，替换了之前版本中包含的 TLS，包括 TLS 1.2，同时还改进了其他 TLS 功能，例如 OCSP 装订扩展（RFC 6066，RFC 6961），以及会话散列和扩展主密钥扩展（RFC 7627），在安全性和性能方面也做了很多提升</li>
<li>飞行记录器：飞行记录器之前是商业版 JDK 的一项分析工具，但在 Java 11 中，其代码被包含到公开代码库中，这样所有人都能使用该功能了</li>
</ul>
<h2 id="Java12"><a href="#Java12" class="headerlink" title="Java12"></a>Java12</h2><h3 id="增强-Switch"><a href="#增强-Switch" class="headerlink" title="增强 Switch"></a>增强 Switch</h3><ul>
<li><p>传统的 switch 语法存在容易漏写 break 的问题，而且从代码整洁性层面来看，多个 break 本质也是一种重复</p>
</li>
<li><p>Java12 提供了 swtich 表达式，使用类似 lambda 语法条件匹配成功后的执行块，不需要多写 break</p>
</li>
<li><p>作为预览特性加入，需要在<code>javac</code>编译和<code>java</code>运行时增加参数<code>--enable-preview</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数字格式化工具类"><a href="#数字格式化工具类" class="headerlink" title="数字格式化工具类"></a>数字格式化工具类</h3><ul>
<li><p><code>NumberFormat</code> 新增了对复杂的数字进行格式化的支持</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NumberFormat fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);</span><br><span class="line">String result = fmt.format(<span class="number">1000</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// 输出为 1K，计算工资是多少K更方便了。。。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><ul>
<li>Redhat 主导开发的 Pauseless GC 实现，主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等</li>
<li>和 Java11 开源的 ZGC 相比（需要升级到 JDK11 才能使用），Shenandoah GC 有稳定的 JDK8u 版本，在 Java8 占据主要市场份额的今天有更大的可落地性</li>
</ul>
<h3 id="G1-收集器提升"><a href="#G1-收集器提升" class="headerlink" title="G1 收集器提升"></a>G1 收集器提升</h3><ul>
<li><p><strong>Java12 为默认的垃圾收集器 G1 带来了两项更新:</strong></p>
</li>
<li><ul>
<li>可中止的混合收集集合：JEP344 的实现，为了达到用户提供的停顿时间目标，JEP 344 通过把要被回收的区域集（混合收集集合）拆分为强制和可选部分，使 G1 垃圾回收器能中止垃圾回收过程。 G1 可以中止可选部分的回收以达到停顿时间目标</li>
<li>及时返回未使用的已分配内存：JEP346 的实现，增强 G1 GC，以便在空闲时自动将 Java 堆内存返回给操作系统</li>
</ul>
</li>
</ul>
<h2 id="Java13"><a href="#Java13" class="headerlink" title="Java13"></a>Java13</h2><h3 id="引入-yield-关键字到-Switch-中"><a href="#引入-yield-关键字到-Switch-中" class="headerlink" title="引入 yield 关键字到 Switch 中"></a>引入 yield 关键字到 Switch 中</h3><ul>
<li><p><code>Switch</code> 表达式中就多了一个关键字用于跳出 <code>Switch</code> 块的关键字<code>yield</code>，主要用于返回一个值</p>
</li>
<li><p><code>yield</code>和 <code>return</code> 的区别在于：<code>return</code> 会直接跳出当前循环或者方法，而 <code>yield</code> 只会跳出当前 <code>Switch</code> 块，同时在使用 <code>yield</code> 时，需要有 <code>default</code> 条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">descLanguage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Java"</span>: yield <span class="string">"object-oriented, platform independent and secured"</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Ruby"</span>: yield <span class="string">"a programmer's best friend"</span>;</span><br><span class="line">           <span class="keyword">default</span>: yield name +<span class="string">" is a good language"</span>;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><ul>
<li><p>解决 Java 定义多行字符串时只能通过换行转义或者换行连接符来变通支持的问题，引入<strong>三重双引号</strong>来定义多行文本</p>
</li>
<li><p>两个<code>&quot;&quot;&quot;</code>中间的任何内容都会被解释为字符串的一部分，包括换行符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String json =<span class="string">"&#123;\n"</span> +</span><br><span class="line">              <span class="string">"   \"name\":\"mkyong\",\n"</span> +</span><br><span class="line">              <span class="string">"   \"age\":38\n"</span> +</span><br><span class="line">              <span class="string">"&#125;\n"</span>;   <span class="comment">// 未支持文本块之前</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String json = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">               &#123;</span></span><br><span class="line"><span class="string">                   "</span>name<span class="string">":"</span>mkyong<span class="string">",</span></span><br><span class="line"><span class="string">                   "</span>age<span class="string">":38</span></span><br><span class="line"><span class="string">               &#125;</span></span><br><span class="line"><span class="string">               "</span><span class="string">""</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="增强-ZGC-释放未使用内存"><a href="#增强-ZGC-释放未使用内存" class="headerlink" title="增强 ZGC 释放未使用内存"></a>增强 ZGC 释放未使用内存</h3><ul>
<li>在 Java 11 中是实验性的引入的 ZGC 在实际的使用中存在未能主动将未使用的内存释放给操作系统的问题</li>
<li>ZGC 堆由一组称为 ZPages 的堆区域组成。在 GC 周期中清空 ZPages 区域时，它们将被释放并返回到页面缓存 <strong>ZPageCache</strong> 中，此缓存中的 ZPages 按最近最少使用（LRU）的顺序，并按照大小进行组织</li>
<li>在 Java 13 中，ZGC 将向操作系统返回被标识为长时间未使用的页面，这样它们将可以被其他进程重用</li>
</ul>
<h3 id="SocketAPI-重构"><a href="#SocketAPI-重构" class="headerlink" title="SocketAPI 重构"></a>SocketAPI 重构</h3><ul>
<li>Java 13 为 Socket API 带来了新的底层实现方法，并且在 Java 13 中是默认使用新的 Socket 实现，使其易于发现并在排除问题同时增加可维护性</li>
</ul>
<h3 id="动态应用程序类-数据共享"><a href="#动态应用程序类-数据共享" class="headerlink" title="动态应用程序类-数据共享"></a>动态应用程序类-数据共享</h3><ul>
<li>Java 13 中对 Java 10 中引入的 应用程序类数据共享进行了进一步的简化、改进和扩展，即：<strong>允许在 Java 应用程序执行结束时动态进行类归档</strong>，具体能够被归档的类包括：所有已被加载，但不属于默认基层 CDS 的应用程序类和引用类库中的类</li>
</ul>
<h2 id="Java14"><a href="#Java14" class="headerlink" title="Java14"></a>Java14</h2><h3 id="record-关键字"><a href="#record-关键字" class="headerlink" title="record 关键字"></a>record 关键字</h3><ul>
<li><p>简化数据类的定义方式，使用 record 代替 class 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 toString，hashCode,equals 方法</p>
</li>
<li><p>类似于使用 Class 定义类，同时使用了 lomobok 插件，并打上了<code>@Getter,@ToString,@EqualsAndHashCode</code>注解</p>
</li>
<li><p>作为预览特性引入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类具有两个特征</span></span><br><span class="line"><span class="comment"> * 1. 所有成员属性都是final</span></span><br><span class="line"><span class="comment"> * 2. 全部方法由构造方法，和两个成员属性访问器组成（共三个）</span></span><br><span class="line"><span class="comment"> * 那么这种类就很适合使用record来声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">width</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> width; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 使用record声明的类会自动拥有上面类中的三个方法</span></span><br><span class="line"><span class="comment"> * 2. 在这基础上还附赠了equals()，hashCode()方法以及toString()方法</span></span><br><span class="line"><span class="comment"> * 3. toString方法中包括所有成员属性的字符串表示形式及其名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">record <span class="title">Rectangle</span><span class="params">(<span class="keyword">float</span> length, <span class="keyword">float</span> width)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="空指针异常精准提示"><a href="#空指针异常精准提示" class="headerlink" title="空指针异常精准提示"></a>空指针异常精准提示</h3><ul>
<li><p>通过 JVM 参数中添加<code>-XX:+ShowCodeDetailsInExceptionMessages</code>，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.b.c.i = <span class="number">99</span>; <span class="comment">// 假设这段代码会发生空指针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException:</span><br><span class="line">        Cannot read field <span class="string">'c'</span> because <span class="string">'a.b'</span> is <span class="keyword">null</span>.</span><br><span class="line">    at Prog.main(Prog.java:<span class="number">5</span>) <span class="comment">// 增加参数后提示的异常中很明确的告知了哪里为空导致</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="switch-的增强终于转正"><a href="#switch-的增强终于转正" class="headerlink" title="switch 的增强终于转正"></a>switch 的增强终于转正</h3><ul>
<li>JDK12 引入的 switch（预览特性）在 JDK14 变为正式版本，不需要增加参数来启用，直接在 JDK14 中就能使用</li>
<li>主要是用<code>-&gt;</code>来替代以前的<code>:</code>+<code>break</code>；另外就是提供了 yield 来在 block 中返回值</li>
</ul>
<p><em>Before Java 14</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        System.out.println(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        System.out.println(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        System.out.println(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Java 14 enhancements</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="instanceof-增强"><a href="#instanceof-增强" class="headerlink" title="instanceof 增强"></a>instanceof 增强</h3><ul>
<li>instanceof 主要在<strong>类型强转前探测对象的具体类型</strong>，然后执行具体的强转</li>
<li>新版的 instanceof 可以在判断的是否属于具体的类型同时完成转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="string">"我是字符串"</span>;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String str)&#123;</span><br><span class="line"> System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他特性-2"><a href="#其他特性-2" class="headerlink" title="其他特性"></a>其他特性</h3><ul>
<li>从 Java11 引入的 ZGC 作为继 G1 过后的下一代 GC 算法，从支持 Linux 平台到 Java14 开始支持 MacOS 和 Window（个人感觉是终于可以在日常开发工具中先体验下 ZGC 的效果了，虽然其实 G1 也够用）</li>
<li>移除了 CMS 垃圾收集器（功成而退）</li>
<li>新增了 jpackage 工具，标配将应用打成 jar 包外，还支持不同平台的特性包，比如 linux 下的<code>deb</code>和<code>rpm</code>，window 平台下的<code>msi</code>和<code>exe</code></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="关于预览特性"><a href="#关于预览特性" class="headerlink" title="关于预览特性"></a>关于预览特性</h3><ul>
<li>先贴一段 oracle 官网原文：<code>This is a preview feature, which is a feature whose design, specification, and implementation are complete, but is not permanent, which means that the feature may exist in a different form or not at all in future JDK releases. To compile and run code that contains preview features, you must specify additional command-line options.</code></li>
<li>这是一个预览功能，该功能的设计，规格和实现是完整的，但不是永久性的，这意味着该功能可能以其他形式存在或在将来的 JDK 版本中根本不存在。 要编译和运行包含预览功能的代码，必须指定其他命令行选项。</li>
<li>就以<code>switch</code>的增强为例子，从 Java12 中推出，到 Java13 中将继续增强，直到 Java14 才正式转正进入 JDK 可以放心使用，不用考虑后续 JDK 版本对其的改动或修改</li>
<li>一方面可以看出 JDK 作为标准平台在增加新特性的严谨态度，另一方面个人认为是对于预览特性应该采取审慎使用的态度。特性的设计和实现容易，但是其实际价值依然需要在使用中去验证</li>
</ul>
<h3 id="JVM-虚拟机优化"><a href="#JVM-虚拟机优化" class="headerlink" title="JVM 虚拟机优化"></a>JVM 虚拟机优化</h3><ul>
<li>每次 Java 版本的发布都伴随着对 JVM 虚拟机的优化，包括对现有垃圾回收算法的改进，引入新的垃圾回收算法，移除老旧的不再适用于今天的垃圾回收算法等</li>
<li>整体优化的方向是<strong>高效，低时延的垃圾回收表现</strong></li>
<li>对于日常的应用开发者可能比较关注新的语法特性，但是从一个公司角度来说，在考虑是否升级 Java 平台时更加考虑的是<strong>JVM 运行时的提升</strong></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis动态SQL</title>
    <url>/2020/08/02/java/MyBatis%E5%8A%A8%E6%80%81SQL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载：<strong><em>\</em><a href="http://mp.weixin.qq.com/s?__biz=MzI2OTQ4OTQ1NQ==&amp;mid=2247486978&amp;idx=3&amp;sn=f002b9b0e5e2d2b9a7d0a97da76c1dfb&amp;chksm=eadeca42dda94354026df14ce7e323e7f60b78ee973f1ef9cc7c4fcd13da03c1fbc0497130c9&amp;token=352160940&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">点击前往，查看更多</a>**</strong></p>
</blockquote>
<p>MyBatis 令人喜欢的一大特性就是动态 SQL。在使用 JDBC 的过程中， 根据条件进行 SQL 的拼接是很麻烦且很容易出错的。MyBatis 动态 SQL 的出现， 解决了这个麻烦。</p>
<p>MyBatis通过 OGNL 来进行动态 SQL 的使用的。目前， 动态 SQL 支持以下几种标签：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406161.webp" alt="" title="" class="">
                <p></p>
            </figure>
<a id="more"></a>
<h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1 数据准备"></a>1 数据准备</h3><p>为了后面的演示， 创建了一个 Maven 项目 mybatis-dynamic, 创建了对应的数据库和表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`student`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'电话'</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱'</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line">  <span class="string">`locked`</span> tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'状态(0:正常,1:锁定)'</span>,</span><br><span class="line">  <span class="string">`gmt_created`</span> datetime <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'存入数据库的时间'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'修改的时间'</span>,</span><br><span class="line">  <span class="string">`delete`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`student_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci <span class="keyword">COMMENT</span>=<span class="string">'学生表'</span>;</span><br></pre></td></tr></table></figure>
<p>对应的项目结构</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406167.png" alt="" title="" class="">
                <p></p>
            </figure>
<h3 id="2-if-标签"><a href="#2-if-标签" class="headerlink" title="2 if 标签"></a>2 if 标签</h3><p>if 标签是我们最常使用的。在查询、删除、更新的时候很可能会使用到。必须结合 test 属性联合使用。</p>
<h4 id="2-1-在-WHERE-条件中使用-if-标签"><a href="#2-1-在-WHERE-条件中使用-if-标签" class="headerlink" title="2.1 在 WHERE 条件中使用 if 标签"></a>2.1 在 WHERE 条件中使用 if 标签</h4><p>这是常见的一种现象， 我们在进行按条件查询的时候， 可能会有多种情况。</p>
<h5 id="2-1-1-查询条件"><a href="#2-1-1-查询条件" class="headerlink" title="2.1.1 查询条件"></a>2.1.1 查询条件</h5><p>根据输入的学生信息进行条件检索</p>
<ul>
<li>当只输入用户名时， 使用用户名进行模糊检索；</li>
<li>当只输入性别时， 使用性别进行完全匹配</li>
<li>当用户名和性别都存在时， 用这两个条件进行查询匹配查询</li>
</ul>
<h5 id="2-1-2-动态-SQL"><a href="#2-1-2-动态-SQL" class="headerlink" title="2.1.2 动态 SQL"></a>2.1.2 动态 SQL</h5><p>接口函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据输入的学生信息进行条件检索</span></span><br><span class="line"><span class="comment"> * 1. 当只输入用户名时， 使用用户名进行模糊检索；</span></span><br><span class="line"><span class="comment"> * 2. 当只输入邮箱时， 使用性别进行完全匹配</span></span><br><span class="line"><span class="comment"> * 3. 当用户名和性别都存在时， 用这两个条件进行查询匹配的用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> student</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">selectByStudentSelective</span><span class="params">(Student student)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对应的动态 SQL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByStudentSelective"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"com.homejim.mybatis.entity.Student"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">  from student</span><br><span class="line">  where 1=1</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name !=''"</span>&gt;</span></span><br><span class="line">    and name like concat('%', #&#123;name&#125;, '%')</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">    and sex=#&#123;sex&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在此 SQL 语句中， where 1=1 是多条件拼接时的小技巧， 后面的条件查询就可以都用 and 了。</p>
<p>同时， 我们添加了 if 标签来处理动态 SQL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name !=''"</span>&gt;</span></span><br><span class="line">  and name like concat('%', #&#123;name&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">  and sex=#&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此 if 标签的 test 属性值是一个符合 OGNL 的表达式， 表达式可以是 true 或 false。如果表达式返回的是数值， 则0为 false, 非 0 为 true;</p>
<h5 id="2-1-3-测试"><a href="#2-1-3-测试" class="headerlink" title="2.1.3 测试"></a>2.1.3 测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectByStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line">    sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    Student search = <span class="keyword">new</span> Student();</span><br><span class="line">    search.setName(<span class="string">"明"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"只有名字时的查询"</span>);</span><br><span class="line">    List&lt;Student&gt; studentsByName = studentMapper.selectByStudentSelective(search);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; studentsByName.size(); i++) &#123;</span><br><span class="line">        System.out.println(ToStringBuilder.reflectionToString(studentsByName.get(i), ToStringStyle.MULTI_LINE_STYLE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    search.setName(<span class="keyword">null</span>);</span><br><span class="line">    search.setSex((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"只有性别时的查询"</span>);</span><br><span class="line">    List&lt;Student&gt; studentsBySex = studentMapper.selectByStudentSelective(search);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; studentsBySex.size(); i++) &#123;</span><br><span class="line">        System.out.println(ToStringBuilder.reflectionToString(studentsBySex.get(i), ToStringStyle.MULTI_LINE_STYLE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"姓名和性别同时存在的查询"</span>);</span><br><span class="line">    search.setName(<span class="string">"明"</span>);</span><br><span class="line">    List&lt;Student&gt; studentsByNameAndSex = studentMapper.selectByStudentSelective(search);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; studentsByNameAndSex.size(); i++) &#123;</span><br><span class="line">        System.out.println(ToStringBuilder.reflectionToString(studentsByNameAndSex.get(i), ToStringStyle.MULTI_LINE_STYLE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有名字时的查询， 发送的语句和结果</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406163.webp" alt="" title="" class="">
                <p></p>
            </figure>
<p>查询的条件只发送了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">where 1=1 and name like concat('%', ?, '%')</span><br></pre></td></tr></table></figure>
<p>只有性别时的查询， 发送的语句和结果</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406168.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>查询的条件只发送了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">where 1=1 and sex=?</span><br></pre></td></tr></table></figure>
<p>姓名和性别同时存在的查询， 发送的语句和结果</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406174.webp" alt="" title="" class="">
                <p></p>
            </figure>
<p>查询条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">where 1=1 and name like concat('%', ?, '%') and sex=?</span><br></pre></td></tr></table></figure>
<h4 id="2-2-在-UPDATE-更新列中使用-if-标签"><a href="#2-2-在-UPDATE-更新列中使用-if-标签" class="headerlink" title="2.2 在 UPDATE 更新列中使用 if 标签"></a>2.2 在 UPDATE 更新列中使用 if 标签</h4><p>有时候我们不希望更新所有的字段， 只更新有变化的字段。</p>
<h5 id="2-2-1-更新条件"><a href="#2-2-1-更新条件" class="headerlink" title="2.2.1 更新条件"></a>2.2.1 更新条件</h5><p>只更新有变化的字段， 空值不更新。</p>
<h5 id="2-2-1-动态-SQL"><a href="#2-2-1-动态-SQL" class="headerlink" title="2.2.1 动态 SQL"></a>2.2.1 动态 SQL</h5><p>接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新非空属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(Student record)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对应的 SQL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByPrimaryKeySelective"</span> <span class="attr">parameterType</span>=<span class="string">"com.homejim.mybatis.entity.Student"</span>&gt;</span></span><br><span class="line">  update student</span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null"</span>&gt;</span></span><br><span class="line">      `name` = #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null"</span>&gt;</span></span><br><span class="line">      phone = #&#123;phone,jdbcType=VARCHAR&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null"</span>&gt;</span></span><br><span class="line">      email = #&#123;email,jdbcType=VARCHAR&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">      sex = #&#123;sex,jdbcType=TINYINT&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"locked != null"</span>&gt;</span></span><br><span class="line">      locked = #&#123;locked,jdbcType=TINYINT&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtCreated != null"</span>&gt;</span></span><br><span class="line">      gmt_created = #&#123;gmtCreated,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtModified != null"</span>&gt;</span></span><br><span class="line">      gmt_modified = #&#123;gmtModified,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where student_id = #&#123;studentId,jdbcType=INTEGER&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-3-测试"><a href="#2-2-3-测试" class="headerlink" title="2.2.3 测试"></a>2.2.3 测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateByStudentSelective</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line">    sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setStudentId(<span class="number">1</span>);</span><br><span class="line">    student.setName(<span class="string">"明明"</span>);</span><br><span class="line">    student.setPhone(<span class="string">"13838438888"</span>);</span><br><span class="line">    System.out.println(studentMapper.updateByPrimaryKeySelective(student));</span><br><span class="line"></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406177.png" alt="" title="" class="">
                <p></p>
            </figure>
<h4 id="2-3-在-INSERT-动态插入中使用-if-标签"><a href="#2-3-在-INSERT-动态插入中使用-if-标签" class="headerlink" title="2.3 在 INSERT 动态插入中使用 if 标签"></a>2.3 在 INSERT 动态插入中使用 if 标签</h4><p>我们插入数据库中的一条记录， 不是每一个字段都有值的， 而是动态变化的。在这时候使用 if 标签， 可帮我们解决这个问题。</p>
<h5 id="2-3-1-插入条件"><a href="#2-3-1-插入条件" class="headerlink" title="2.3.1 插入条件"></a>2.3.1 插入条件</h5><p>只有非空属性才插入。</p>
<h5 id="2-3-2-动态SQL"><a href="#2-3-2-动态SQL" class="headerlink" title="2.3.2 动态SQL"></a>2.3.2 动态SQL</h5><p>接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非空字段才进行插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(Student record)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对应的SQL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertSelective"</span> <span class="attr">parameterType</span>=<span class="string">"com.homejim.mybatis.entity.Student"</span>&gt;</span></span><br><span class="line">    insert into student</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"studentId != null"</span>&gt;</span></span><br><span class="line">        student_id,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null"</span>&gt;</span></span><br><span class="line">        `name`,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null"</span>&gt;</span></span><br><span class="line">        phone,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null"</span>&gt;</span></span><br><span class="line">        email,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">        sex,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"locked != null"</span>&gt;</span></span><br><span class="line">        locked,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtCreated != null"</span>&gt;</span></span><br><span class="line">        gmt_created,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtModified != null"</span>&gt;</span></span><br><span class="line">        gmt_modified,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"values ("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"studentId != null"</span>&gt;</span></span><br><span class="line">        #&#123;studentId,jdbcType=INTEGER&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null"</span>&gt;</span></span><br><span class="line">        #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null"</span>&gt;</span></span><br><span class="line">        #&#123;phone,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null"</span>&gt;</span></span><br><span class="line">        #&#123;email,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">        #&#123;sex,jdbcType=TINYINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"locked != null"</span>&gt;</span></span><br><span class="line">        #&#123;locked,jdbcType=TINYINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtCreated != null"</span>&gt;</span></span><br><span class="line">        #&#123;gmtCreated,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtModified != null"</span>&gt;</span></span><br><span class="line">        #&#123;gmtModified,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个 SQL 大家应该很熟悉， 毕竟是自动生成的。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 集成邮件服务以及邮件发送的几种方式</title>
    <url>/2020/05/17/java/SpringBoot-%E9%9B%86%E6%88%90%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载：<a href="https://mp.weixin.qq.com/s/SxdiqaFqHyK5hNcJz1uoAQ" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<h1 id="一、SMTP协议简介"><a href="#一、SMTP协议简介" class="headerlink" title="一、SMTP协议简介"></a>一、SMTP协议简介</h1><p>  SMTP是一种提供可靠且有效的<strong>电子邮件传输</strong>的协议。SMTP是建立在<strong>FTP</strong>文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能<strong>跨越网络传输邮件</strong>，即“SMTP邮件中继”。使用SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。</p>
<p> 简单来说：我们使用的这些邮件发送功能，他们之间都有一个专门的电子邮件的服务器，类似于邮局，你将邮件发给邮局，邮局又会根据你的邮寄地址发送给相应的邮局，然后接收方去邮局取邮件。而邮件服务器呢，就是互联网之间的一个邮局，不同的网络之间也能实现电子邮件的发送。</p>
<p> Spring框架在java邮件服务的基础上进行了封装，SpringBoot在Spring的基础上对邮件服务进一步的封装，让SpringBoot发送邮件更为便利，灵活。</p>
 <a id="more"></a>
<h1 id="二、开启SMTP服务并获取授权码"><a href="#二、开启SMTP服务并获取授权码" class="headerlink" title="二、开启SMTP服务并获取授权码"></a>二、开启SMTP服务并获取授权码</h1><p> 这里我们以<strong>QQ邮箱</strong>为例，要想在SpringBoot发送QQ邮件必须先打开QQ邮箱的SMTP功能，默认是关闭的，具体操作如下。进入邮箱→设置→账户，然后找到下面这个： </p>
<p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589687793545.webp" alt="img"></p>
<p> 将第一个开启，这里我已经开启了，就不用再开启了，至于那个POP3协议,这是一种从邮件服务器上读取邮件的协议，通过POP3协议，收信人不需要参与到与邮件服务器之间的邮件读取过程，简化了用户操作. 收信人可以“离线”地进行邮件处理，很方便地接收，阅读邮件。</p>
<p> 然后我们开启之后还需要获取一个授权码，这个授权码我们后面编写邮件配置需要用到。获取授权码可能需要验证身份什么的。将授权码保存下来。 </p>
<p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589687793565.webp" alt="img"></p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="三、依赖导入与配置说明"><a href="#三、依赖导入与配置说明" class="headerlink" title="三、依赖导入与配置说明"></a>三、依赖导入与配置说明</h1><p> <strong>依赖导入</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 为了方便测试我们也需要将<strong>starter-web</strong>的依赖导入进来。</p>
<p> <strong>配置文件</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  mail:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">qzstudynote@qq.com</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">zxcvbnmkj</span></span><br><span class="line"><span class="attr">    properties:</span></span><br><span class="line"><span class="attr">      mail:</span></span><br><span class="line"><span class="attr">        smtp:</span></span><br><span class="line"><span class="attr">          socketFactory:</span></span><br><span class="line"><span class="attr">            class:</span> <span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line"><span class="comment">##         ssl:</span></span><br><span class="line"><span class="comment">##           enable :true</span></span><br><span class="line"><span class="attr">    default-encoding:</span> <span class="string">utf-8</span></span><br></pre></td></tr></table></figure>
<p> <strong>配置说明</strong>：</p>
<ul>
<li>host就是你的邮件服务器地址,</li>
<li>username就是你的邮箱账号，带上后缀</li>
<li>password就是你刚刚复制的授权码，我这里是乱写的；</li>
<li>default-encoding 设置邮件的编码为utf-8；</li>
<li>properties：额外的配置，这里我写了两个，只用其中一个就行了，开启ssl加密，保证安全连接。</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h1 id="四、邮件发送"><a href="#四、邮件发送" class="headerlink" title="四、邮件发送"></a>四、邮件发送</h1><h2 id="1-简单邮件发送"><a href="#1-简单邮件发送" class="headerlink" title="1.简单邮件发送"></a>1.简单邮件发送</h2><p> 编写controller，或者是直接在测试模块添加测试就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSenderImpl javaMailSender;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/mail"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">        <span class="comment">//邮件设置</span></span><br><span class="line">        message.setSubject(<span class="string">"邮件主题"</span>);</span><br><span class="line">        message.setText(<span class="string">"邮件内容"</span>);</span><br><span class="line">        message.setTo(<span class="string">"xxxxxxx@139.com"</span>,<span class="string">"111111111@qq.com"</span>);</span><br><span class="line">        message.setFrom(<span class="string">"qzstudynote@qq.com"</span>);</span><br><span class="line">        javaMailSender.send(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"简单邮件发送成功！"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码说明</strong>：<strong>JavaMailSenderImpl</strong>就是一个SpringBoot中用来发送邮件的一个实现类，我们需要将它注入到bean中，以供使用。它里面有一些方法，这里只展示了简单的几个，其他的也很简单，比如说发送日期，抄送人等等。接受者可以设置多个，如上。</p>
<h2 id="2-带附件内容和正文带图片的邮件发送"><a href="#2-带附件内容和正文带图片的邮件发送" class="headerlink" title="2.带附件内容和正文带图片的邮件发送"></a>2.带附件内容和正文带图片的邮件发送</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/mineMail"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sendMineMail</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">     <span class="comment">//1、创建一个复杂的邮件</span></span><br><span class="line">        MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">        MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//邮件主题</span></span><br><span class="line">        helper.setSubject(<span class="string">"这是一个邮件啊"</span>);</span><br><span class="line">        <span class="comment">//文本中添加图片</span></span><br><span class="line">        helper.addInline(<span class="string">"image1"</span>,<span class="keyword">new</span> FileSystemResource(<span class="string">"D:\\images\\spring\\1.jpg"</span>));</span><br><span class="line">        <span class="comment">//邮件内容</span></span><br><span class="line">        helper.setText(<span class="string">"全栈学习笔记&lt;a href='https://www.cnblogs.com/swzx-1213/'&gt;百度一下&lt;/a&gt;    &lt;img src='cid:image1'&gt;&lt;/img&gt;"</span>,<span class="keyword">true</span>);</span><br><span class="line">        helper.setTo(<span class="string">"xxxxx@139.com"</span>);</span><br><span class="line">        helper.setFrom(<span class="string">"qzstudynote@qq.com"</span>);</span><br><span class="line">        <span class="comment">//附件添加图片</span></span><br><span class="line">        helper.addAttachment(<span class="string">"1.jpg"</span>,<span class="keyword">new</span> File(<span class="string">"D:\\images\\spring\\1.jpg"</span>));</span><br><span class="line">        <span class="comment">//附件添加word文档</span></span><br><span class="line">        helper.addAttachment(<span class="string">"哈哈哈.docx"</span>,<span class="keyword">new</span> File(<span class="string">"D:\\images\\spring\\哈哈哈.docx"</span>));</span><br><span class="line"></span><br><span class="line">        javaMailSender.send(mimeMessage);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"复杂邮件发送！"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>代码说明</strong>：</p>
<ul>
<li><p>创建一个MimeMessage 邮件，但是我们也需要创建一个工具类MimeMessageHelper，相当于代理类吧，邮件的属性配置就由这个工具类来实现。</p>
</li>
<li><p><strong>addInline()</strong>,第一个参数是一个contentId,String类型的，相当于是一个key,第二个参数是一个Resource对象，资源对象，这里我们传了一个本地的图片就用的FileSystemResource对象。当然这里是说的我们用的这个addInline方法的参数是这样，还有其他的参数类型，所谓重载。</p>
</li>
<li><p><strong>setText()</strong>，这里用到的第一个参数就是文本字符串，第二个就是是否解析文本中的html语法。</p>
</li>
<li><p><strong>addAttachment()</strong> 这个方法是用来添加附件的，附件和我们之前添加的图片不一样，附件作为一种未下载的文件，而资源文件则是直接显示到正文中。利用我自己的邮箱进行测试的截图：</p>
</li>
</ul>
<ul>
<li><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589687793569.webp" alt="img" title="" class="">
                <p>img</p>
            </figure>
</li>
</ul>
<h2 id="3-thymeleaf模板作为邮件发送"><a href="#3-thymeleaf模板作为邮件发送" class="headerlink" title="3.thymeleaf模板作为邮件发送"></a>3.thymeleaf模板作为邮件发送</h2><p> 项目中需要引入thymeleaf依赖，并且要在新建的html文件中加入：xmlns:th=”<a href="http://www.thymeleaf.org&quot;" target="_blank" rel="noopener">http://www.thymeleaf.org&quot;</a> ,不会thymeleaf的请移步之前的文章。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 这里在templates下面创建了一个email的html5文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">"这是一个链接"</span> <span class="attr">th:href</span>=<span class="string">"$&#123;link&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">"$&#123;image1&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> controller中再添加一个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/thyMail"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendThymeleafMail</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">        MimeMessageHelper messageHelper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage);</span><br><span class="line">        messageHelper.setSubject(<span class="string">"这是一个thymeleaf模板邮件"</span>);</span><br><span class="line">        messageHelper.setTo(<span class="string">"xxxxxxxx@139.com"</span>);</span><br><span class="line">        messageHelper.setFrom(<span class="string">"qzstudynote@qq.com"</span>);</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.setVariable(<span class="string">"name"</span>,<span class="string">"这是一个新建的thymeleaf模板"</span>);</span><br><span class="line">        context.setVariable(<span class="string">"link"</span>,<span class="string">"https://www.cnblogs.com/swzx-1213/"</span>);</span><br><span class="line">        context.setVariable(<span class="string">"image1"</span>,<span class="string">"https://s1.ax1x.com/2020/04/14/JShDYt.th.jpg"</span>);</span><br><span class="line">        String value = templateEngine.process(<span class="string">"email.html"</span>,context);</span><br><span class="line">        messageHelper.setText(value,<span class="keyword">true</span>);</span><br><span class="line">        javaMailSender.send(mimeMessage);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"模板邮件发送成功"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>代码说明：</strong></p>
<ul>
<li><strong>Context</strong> 属于org.thymeleaf.context这个包。</li>
<li><strong>context.setVariable()</strong>,第一个参数是String,第二个是Object类型。第一个参数就对应thymeleaf模板上面相同名字的参数。</li>
<li><strong>templateEngine.process()</strong>将指定路径的html文件转换成String类型返回。</li>
</ul>
<p> 测试： </p>
<p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589687793585.webp" alt="img"></p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p> 本文讲了基础的邮件发送原理，SMTP协议以及提到的POP3协议的概要内容。然后一起引入依赖，添加项目属性配置，最后讲解了三大类发送邮件的方式。源码获取后台回复【SpringBoot】。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>Sprinig Boot + Redis 实现接口幂等性</title>
    <url>/2020/05/07/java/Sprinig-Boot-Redis-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>幂等性, 通俗的说就是一个接口, 多次发起同一个请求, 必须保证操作只能执行一次 比如:</p>
<ul>
<li>订单接口, 不能多次创建订单</li>
<li>支付接口, 重复支付同一笔订单只能扣一次钱</li>
<li>支付宝回调接口, 可能会多次回调, 必须处理重复回调</li>
<li>普通表单提交接口, 因为网络超时等原因多次点击提交, 只能成功一次 等等</li>
</ul>
<h3 id="二、常见解决方案"><a href="#二、常见解决方案" class="headerlink" title="二、常见解决方案"></a>二、常见解决方案</h3><ol>
<li>唯一索引 – 防止新增脏数据</li>
<li>token机制 – 防止页面重复提交</li>
<li>悲观锁 – 获取数据的时候加锁(锁表或锁行)</li>
<li>乐观锁 – 基于版本号version实现, 在更新数据那一刻校验数据</li>
<li>分布式锁 – redis(jedis、redisson)或zookeeper实现</li>
<li>状态机 – 状态变更, 更新数据时判断状态</li>
</ol>
<h3 id="三、本文实现"><a href="#三、本文实现" class="headerlink" title="三、本文实现"></a>三、本文实现</h3><p>本文采用第2种方式实现, 即通过redis + token机制实现接口幂等性校验</p>
<h3 id="四、实现思路"><a href="#四、实现思路" class="headerlink" title="四、实现思路"></a>四、实现思路</h3><p>为需要保证幂等性的每一次请求创建一个唯一标识<code>token</code>, 先获取<code>token</code>, 并将此<code>token</code>存入redis, 请求接口时, 将此<code>token</code>放到header或者作为请求参数请求接口, 后端接口判断redis中是否存在此<code>token</code>:</p>
<ul>
<li>如果存在, 正常处理业务逻辑, 并从redis中删除此<code>token</code>, 那么, 如果是重复请求, 由于<code>token</code>已被删除, 则不能通过校验, 返回<code>请勿重复操作</code>提示</li>
<li>如果不存在, 说明参数不合法或者是重复请求, 返回提示即可</li>
</ul>
<h3 id="五、项目简介"><a href="#五、项目简介" class="headerlink" title="五、项目简介"></a>五、项目简介</h3><a id="more"></a>
<ul>
<li>springboot</li>
<li>redis</li>
<li><code>@ApiIdempotent</code>注解 + 拦截器对请求进行拦截</li>
<li>@ControllerAdvice全局异常处理</li>
<li>压测工具: jmeter</li>
</ul>
<p><strong>说明:</strong></p>
<ul>
<li>本文重点介绍幂等性核心实现, 关于<strong>springboot如何集成redis</strong>、<strong>ServerResponse</strong>、<strong>ResponseCode</strong>等细枝末节不在本文讨论范围之内, 有兴趣的小伙伴可以查看我的Github项目: <a href="https://github.com/wangzaiplus/springboot/tree/wxw" target="_blank" rel="noopener">https://github.com/wangzaiplus/springboot/tree/wxw</a></li>
</ul>
<h3 id="六、代码实现"><a href="#六、代码实现" class="headerlink" title="六、代码实现"></a>六、代码实现</h3><ol>
<li>pom</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Redis-Jedis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--lombok 本文用到@Slf4j注解, 也可不引用, 自定义log即可--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>JedisUtil</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangzaiplus.test.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.set(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"set key:&#123;&#125; value:&#123;&#125; error"</span>, key, value, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间, 单位: s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.setex(key, expireTime, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"set key:&#123;&#125; value:&#123;&#125; expireTime:&#123;&#125; error"</span>, key, value, expireTime, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"get key:&#123;&#125; error"</span>, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">del</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.del(key.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"del key:&#123;&#125; error"</span>, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">exists</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.exists(key.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exists key:&#123;&#125; error"</span>, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设值key过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间, 单位: s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.expire(key.getBytes(), expireTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"expire key:&#123;&#125; error"</span>, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取剩余时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">ttl</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = getJedis();</span><br><span class="line">            <span class="keyword">return</span> jedis.ttl(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"ttl key:&#123;&#125; error"</span>, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>自定义注解<code>@ApiIdempotent</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangzaiplus.test.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在需要保证 接口幂等性 的Controller的方法上使用此注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApiIdempotent &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>ApiIdempotentInterceptor</code>拦截器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangzaiplus.test.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.annotation.ApiIdempotent;</span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.service.TokenService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口幂等性拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiIdempotentInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenService tokenService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line"></span><br><span class="line">        ApiIdempotent methodAnnotation = method.getAnnotation(ApiIdempotent.class);</span><br><span class="line">        <span class="keyword">if</span> (methodAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            check(request);<span class="comment">// 幂等性校验, 校验通过则放行, 校验失败则抛出异常, 并通过统一异常处理返回友好提示</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        tokenService.checkToken(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>TokenServiceImpl</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangzaiplus.test.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.common.Constant;</span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.common.ResponseCode;</span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.common.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.exception.ServiceException;</span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.service.TokenService;</span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.util.JedisUtil;</span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.util.RandomUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.text.StrBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenServiceImpl</span> <span class="keyword">implements</span> <span class="title">TokenService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_NAME = <span class="string">"token"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JedisUtil jedisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">createToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = RandomUtil.UUID32();</span><br><span class="line">        StrBuilder token = <span class="keyword">new</span> StrBuilder();</span><br><span class="line">        token.append(Constant.Redis.TOKEN_PREFIX).append(str);</span><br><span class="line"></span><br><span class="line">        jedisUtil.set(token.toString(), token.toString(), Constant.Redis.EXPIRE_TIME_MINUTE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ServerResponse.success(token.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String token = request.getHeader(TOKEN_NAME);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;<span class="comment">// header中不存在token</span></span><br><span class="line">            token = request.getParameter(TOKEN_NAME);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;<span class="comment">// parameter中也不存在token</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(ResponseCode.ILLEGAL_ARGUMENT.getMsg());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!jedisUtil.exists(token)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(ResponseCode.REPETITIVE_OPERATION.getMsg());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long del = jedisUtil.del(token);</span><br><span class="line">        <span class="keyword">if</span> (del &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(ResponseCode.REPETITIVE_OPERATION.getMsg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>TestApplication</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangzaiplus.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.interceptor.ApiIdempotentInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.wangzaiplus.test.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplication</span>  <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跨域</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        <span class="keyword">final</span> CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 接口幂等性拦截器</span></span><br><span class="line">        registry.addInterceptor(apiIdempotentInterceptor());</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiIdempotentInterceptor <span class="title">apiIdempotentInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiIdempotentInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK, 目前为止, 校验代码准备就绪, 接下来测试验证</p>
<h3 id="七、测试验证"><a href="#七、测试验证" class="headerlink" title="七、测试验证"></a>七、测试验证</h3><ol>
<li>获取<code>token</code>的控制器<code>TokenController</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangzaiplus.test.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.common.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.service.TokenService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/token"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenService tokenService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">token</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tokenService.createToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>TestController</code>, 注意<code>@ApiIdempotent</code>注解, 在需要幂等性校验的方法上声明此注解即可, 不需要校验的无影响</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangzaiplus.test.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.annotation.ApiIdempotent;</span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.common.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> com.wangzaiplus.test.service.TestService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiIdempotent</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"testIdempotence"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">testIdempotence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testService.testIdempotence();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>获取<code>token</code></p>
<p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_44_08_1.jpg" alt="img"></p>
</li>
</ol>
<p>查看redis</p>
<figure class="image-box">
                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">
                <p>img</p>
            </figure>
<ol>
<li><p>测试接口安全性: 利用jmeter测试工具模拟50个并发请求, 将上一步获取到的token作为参数</p>
<p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_44_13_1.jpg" alt="img"></p>
</li>
</ol>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_44_19_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<ol>
<li><p>header或参数均不传token, 或者token值为空, 或者token值乱填, 均无法通过校验, 如token值为”abcd”</p>
<p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_44_25_1.jpg" alt="img"></p>
</li>
</ol>
<h3 id="八、注意点-非常重要"><a href="#八、注意点-非常重要" class="headerlink" title="八、注意点(非常重要)"></a>八、注意点(非常重要)</h3><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_44_29_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>上图中, 不能单纯的直接删除token而不校验是否删除成功, 会出现并发安全性问题, 因为, 有可能多个线程同时走到第46行, 此时token还未被删除, 所以继续往下执行, 如果不校验<code>jedisUtil.del(token)</code>的删除结果而直接放行, 那么还是会出现重复提交问题, 即使实际上只有一次真正的删除操作, 下面重现一下</p>
<p>稍微修改一下代码:</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_44_34_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>再次请求</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_44_40_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>再看看控制台</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_44_44_1.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>虽然只有一个真正删除掉token, 但由于没有对删除结果进行校验, 所以还是有并发问题, 因此, 必须校验</p>
<h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>其实思路很简单, 就是每次请求保证唯一性, 从而保证幂等性, 通过拦截器+注解, 就不用每次请求都写重复代码, 其实也可以利用spring aop实现, 无所谓</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>String长度有限制吗？是多少？</title>
    <url>/2021/01/24/java/String%E9%95%BF%E5%BA%A6%E6%9C%89%E9%99%90%E5%88%B6%E5%90%97%EF%BC%9F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>话说Java中String是有长度限制的，听到这里很多人不禁要问，String还有长度限制？是的有，而且在JVM编译中还有规范，而且有的家人们在面试的时候也遇到了。</p>
<p>本人就遇到过面试的时候问这个的，而且在之前开发的中也真实地遇到过这个String长度限制的场景（将某固定文件转码成Base64的形式用字符串存储，在运行时需要的时候在转回来，当时文件比较大），那这个规范限制到底是怎么样的，咱们话不多说先䁖䁖去。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>首先要知道String的长度限制我们就需要知道String是怎么存储字符串的，String其实是使用的一个char类型的数组来存储字符串中的字符的。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151612.jpg" alt="存储String的容器原来是它" title="" class="">
                <p>存储String的容器原来是它</p>
            </figure>
<a id="more"></a>
<p>那么String既然是数组存储那数组会有长度的限制吗？是的有限制，但是是在有先提条件下的，我们看看String中返回length的方法。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151630.jpg" alt="String类中的length方法" title="" class="">
                <p>String类中的length方法</p>
            </figure>
<p>由此我们看到返回值类型是int类型，Java中定义数组是可以给数组指定长度的，当然不指定的话默认会根据数组元素来指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] arr1 = new int[10]; // 定义一个长度为10的数组</span><br><span class="line">int[] arr2 = &#123;1,2,3,4,5&#125;; // 那么此时数组的长度为5</span><br></pre></td></tr></table></figure>
<p>整数在java中是有限制的，我们通过源码来看看int类型对应的包装类Integer可以看到，其长度最大限制为2^31 -1，那么说明了数组的长度是0~2^31-1，那么计算一下就是（2^31-1 = 2147483647 = 4GB）</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151731.jpg" alt="Integer的取值范围" title="" class="">
                <p>Integer的取值范围</p>
            </figure>
<p>看到这我们尝试通过编码来验证一下上述观点。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151745.jpg" alt="以字面量形式定义字符串" title="" class="">
                <p>以字面量形式定义字符串</p>
            </figure>
<p>以上是我通过定义字面量的形式构造的10万个字符的字符串，编译之后虚拟机提示报错，说我们的字符串长度过长，不是说好了可以存21亿个吗？为什么才10万个就报错了呢？</p>
<p>其实这里涉及到了JVM编译规范的限制了，其实JVM在编译时，如果我们将字符串定义成了字面量的形式，编译时JVM是会将其存放在常量池中，这时候JVM对这个常量池存储String类型做出了限制，接下来我们先看下手册是如何说的。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151858.jpg" alt="java虚拟机规范截图" title="" class="">
                <p>java虚拟机规范截图</p>
            </figure>
<p>常量池中，每个 cp_info 项的格式必须相同，它们都以一个表示 cp_info 类型的单字节 “tag”项开头。后面 info[]项的内容 由tag 的类型所决定。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151917.jpg" alt="java虚拟机规范手册常量类型表" title="" class="">
                <p>java虚拟机规范手册常量类型表</p>
            </figure>
<p>我们可以看到 String类型的表示是 CONSTANT_String ，我们来看下CONSTANT_String具体是如何定义的。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151932.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>这里定义的 u2 string_index 表示的是常量池的有效索引，其类型是CONSTANT_Utf8_info 结构体表示的，这里我们需要注意的是其中定义的length我们看下面这张图。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151941.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>在class文件中u2表示的是无符号数占2个字节单位，我们知道1个字节占8位，2个字节就是16位 ，那么2个字节能表示的范围就是2^16- 1 = 65535 。范中class文件格式对u1、u2的定义的解释做了一下摘要：</p>
<p>这里对java虚拟机规摘要部分</p>
<h4 id="1、class文件中文件内容类型解释"><a href="#1、class文件中文件内容类型解释" class="headerlink" title="1、class文件中文件内容类型解释"></a>1、class文件中文件内容类型解释</h4><p>定义一组私有数据类型来表示 Class 文件的内容，它们包括 u1，u2 和 u4，分别代 表了 1、2 和 4 个字节的无符号数。</p>
<p>每个 Class 文件都是由 8 字节为单位的字节流组成，所有的 16 位、32 位和 64 位长度的数 据将被构造成 2 个、4 个和 8 个 8 字节单位来表示。</p>
<h4 id="2、程序异常处理的有效范围解释"><a href="#2、程序异常处理的有效范围解释" class="headerlink" title="2、程序异常处理的有效范围解释"></a>2、程序异常处理的有效范围解释</h4><p>start_pc 和 end_pc 两项的值表明了异常处理器在 code[]数组中的有效范围。</p>
<p>start_pc 必须是对当前 code[]数组中某一指令的操作码的有效索引，end_pc 要 么是对当前 code[]数组中某一指令的操作码的有效索引，要么等于 code_length 的值，即当前 code[]数组的长度。start_pc 的值必须比 end_pc 小。</p>
<p>当程序计数器在范围<code>[start_pc, end_pc)</code>内时，异常处理器就将生效。即设 x 为 异常句柄的有效范围内的值，x 满足：<code>start_pc ≤ x &lt; end_pc</code>。</p>
<p>实际上，end_pc 值本身不属于异常处理器的有效范围这点属于 Java 虚拟机历史上 的一个设计缺陷：如果 Java 虚拟机中的一个方法的 code 属性的长度刚好是 65535 个字节，并且以一个 1 个字节长度的指令结束，那么这条指令将不能被异常处理器 所处理。</p>
<p>不过编译器可以通过限制任何方法、实例初始化方法或类初始化方法的<code>code[]</code>数组最大长度为 65534，这样可以间接弥补这个 BUG。</p>
<blockquote>
<p>注意：这里对个人认为比较重要的点做了标记，首先第一个加粗说白了就是说数组有效范围就是【0-65565】但是第二个加粗的地方又解释了，因为虚拟机还需要1个字节的指令作为结束，所以其实真正的有效范围是【0-65564】，这里要注意这里的范围仅限编译时期，如果你是运行时拼接的字符串是可以超出这个范围的。</p>
</blockquote>
<p>接下来我们通过一个小实验来测试一下我们构建一个长度为65534的字符串，看看是否就能编译通过。0期阶段汇总</p>
<p>首先通过一个for循环构建65534长度的字符串，在控制台打印后，我们通过自己度娘的一个在线字符统计工具计算了一下确实是65534个字符，如下：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152003.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152013.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>然后我们将字符复制后以定义字面量的形式赋值给字符串，可以看到我们选择这些字符右下角显示的确实是65534，于是乎运行了一波，果然成功了。</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152035.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152046.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>看到这里我们来总结一下：</p>
<p><strong>问：字符串有长度限制吗？是多少？</strong></p>
<p>答：首先字符串的内容是由一个字符数组 char[] 来存储的，由于数组的长度及索引是整数，且String类中返回字符串长度的方法length() 的返回值也是int ，所以通过查看java源码中的类Integer我们可以看到Integer的最大范围是2^31 -1,由于数组是从0开始的，所以数组的最大长度可以使【0~2^31】通过计算是大概4GB。</p>
<p>但是通过翻阅java虚拟机手册对class文件格式的定义以及常量池中对String类型的结构体定义我们可以知道对于索引定义了u2，就是无符号占2个字节，2个字节可以表示的最大范围是2^16 -1 = 65535。</p>
<p>其实是65535，但是由于JVM需要1个字节表示结束指令，所以这个范围就为65534了。超出这个范围在编译时期是会报错的，但是运行时拼接或者赋值的话范围是在整形的最大范围。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java常用集合源码分析</title>
    <url>/2020/09/26/java/java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java集合源码分析"><a href="#java集合源码分析" class="headerlink" title="java集合源码分析"></a>java集合源码分析</h1><p>大家平时在用java写代码的时候，使用的数据结构最多的就是java自己封装好的集合类。但是当我们使用这些封装好的集合类的时候，不了解底层原理，或多或少就会碰到由于不知道底层原理，导致开发时忽略的细节，造成开发甚至是生产方面的BUG。防微杜渐，产品的质量是计划出来的，未雨绸缪的。所以，下面就java常用集合专题，揭开java集合的神秘面纱。包括ArrayList；LinkedList；HashSet；HashMap；线程安全的ConcurrentHashMap。我会将个人理解与源代码结合，将个人解读写在源代码注释中，边看源码边学习。</p>
<h1 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1 ArrayList"></a>1 ArrayList</h1><h2 id="1-1-整体架构"><a href="#1-1-整体架构" class="headerlink" title="1.1 整体架构"></a>1.1 整体架构</h2><p>ArrayList 整体架构比较简单，就是一个数组结构，比较简单，如下图：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114356.png" alt="图片描述" title="" class="">
                <p>图片描述</p>
            </figure>
<p>图中展示是长度为 10 的数组，从 1 开始计数，index 表示数组的下标，从 0 开始计数，elementData 表示数组本身，源码中除了这两个概念，还有以下三个基本概念：</p>
<ul>
<li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li>
<li>size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；</li>
<li>modCount 统计当前数组被修改的版本次数，数组结构有变动，就会 +1。</li>
</ul>
<p>下面是源码：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始容量大小10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//大小为0实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">	<span class="comment">//默认初始化的空实例，元素增加时自动grow</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    存储arraylist元素的数组缓冲区。</span></span><br><span class="line"><span class="comment">    arraylist的容量是这个数组缓冲区的长度。任何带有		elementdata==defaultcapacity_empty_elementdata的空arraylist将在添加第一个元素时扩展为默认容量*/</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="comment">//当前大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-类注释"><a href="#1-2-类注释" class="headerlink" title="1.2 类注释"></a>1.2 类注释</h2><p>了解一个类，就需要先看类注释，一个完整的类注释，可以让使用者快速了解一个类，往往事半功倍，下面我们来看一下ArrayList的类注释写了什么（因为源码的类注释很长，下面就简短的挑一些重点的说明并总结经行阐述）</p>
<ul>
<li>允许 put null 值，会自动扩容；</li>
<li>size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；</li>
<li>是非线程安全的，多线程情况下，推荐使用线程安全类：Vector(早期的集合，现在不推荐使用了)，Collections.synchronizedList，CopyOnWriteArrayList；</li>
<li>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。</li>
</ul>
<h2 id="1-3-构造函数（初始化）"><a href="#1-3-构造函数（初始化）" class="headerlink" title="1.3 构造函数（初始化）"></a>1.3 构造函数（初始化）</h2><p>我们有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有大小initialCapacity的构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无参数直接初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始数据初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// c.toArray 可能不会正确返回 Object[]（具体问题请自行看toArray源码）</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)&#123;</span><br><span class="line">        	elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用EMPTY_ELEMENTDATA替代数据.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：使用无参数直接初始化，默认是空的数组，只有当在第一次使用add方法的时候，扩容到DEFAULT_CAPACITY（也就是10）。下面我们可以通过常用的方法，来看看这么一个过程。</p>
<h2 id="1-4-方法"><a href="#1-4-方法" class="headerlink" title="1.4 方法"></a>1.4 方法</h2><h3 id="1-4-1-新增和扩容实现"><a href="#1-4-1-新增和扩容实现" class="headerlink" title="1.4.1 新增和扩容实现"></a>1.4.1 新增和扩容实现</h3><p>新增与扩容就是往数组中添加元素，主要分成两步：</p>
<ul>
<li>判断是否需要扩容，如果需要执行扩容操作（默认扩容为原容量大小的1.5倍，直到Integer的最大值）；</li>
<li>直接赋值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">//直接赋值，线程不安全的</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确保容积足够</span></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//记录数组被修改</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容，并把现有数据拷贝到新的数组里面去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity 除以 2 的意思</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 通过复制进行扩容</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-删除"><a href="#1-4-2-删除" class="headerlink" title="1.4.2 删除"></a>1.4.2 删除</h3><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多，就选取根据值删除方式来进行源码说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果要删除的值是 null，找到第一个值是 null 的删除</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果要删除的值不为 null，找到第一个和要删除的值相等的删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="comment">// 这里是根据  equals 来判断值相等的，相等后再根据索引位置进行删除</span></span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要注意的两点是：</p>
<ul>
<li>新增的时候是没有对 null 进行校验的，所以删除的时候也是允许删除 null 值的；</li>
<li>找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，需要我们关注 equals 的具体实现。</li>
</ul>
<p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 记录数组的结构要发生变动了</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去</span></span><br><span class="line">  <span class="comment">// 减 1 的原因，是因为 size 从 1 开始算起，index 从 0开始算起</span></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 numMoved</span></span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">  <span class="comment">//数组最后一个位置赋值 null，帮助 GC</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中，我们可以看出，某一个元素被删除后，为了维护数组结构，我们都会把数组后面的元素往前移动。</p>
<h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><p>可以发现，ArrayList是一个Object的数组；平时我们用需要用泛型去制约好它，不然会造成元数据操作的问题（比如一个ArrayList里面有Integer，String，到时候对数据的操作就会产生问题）。通过上面源码分析，我们发现，扩容是通过这行代码来实现的：<code>Arrays.copyOf(elementData, newCapacity);</code>，这行代码描述的本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据拷贝过去。通过构造函数，我们可以知道，使用没有参数的构造函数构造ArrayList，默认是空数组，当第一次add的时候才会扩容，所以最好在初始话的时候指定好大小，频繁的calculateCapacity扩容会造成一定的性能损耗。</p>
<p>其他的函数也就大同小异，业余时间也可以探索一下其他函数的源码实现。</p>
<h1 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2 LinkedList"></a>2 LinkedList</h1><h2 id="2-1-整体架构"><a href="#2-1-整体架构" class="headerlink" title="2.1 整体架构"></a>2.1 整体架构</h2><p>LinkedList 底层数据结构是一个双向链表，整体结构如下图所示（来源于百度）：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114410.png" alt="图片描述" title="" class="">
                <p>图片描述</p>
            </figure>
<p>上图代表了一个双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如下：</p>
<ul>
<li>链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置；</li>
<li>first 是双向链表的头节点，它的前一个节点是 null。</li>
<li>last 是双向链表的尾节点，它的后一个节点是 null；</li>
<li>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；</li>
<li>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。</li>
</ul>
<h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><p>我们先首先来看一下对于每一个节点，LinkedList保存的是什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">//数据</span></span><br><span class="line">      E item;</span><br><span class="line">      <span class="comment">//类似于c的指针，指向下一个节点</span></span><br><span class="line">      Node&lt;E&gt; next;</span><br><span class="line">      <span class="comment">//指向上一个节点</span></span><br><span class="line">      Node&lt;E&gt; prev;</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">          <span class="keyword">this</span>.item = element;</span><br><span class="line">          <span class="keyword">this</span>.next = next;</span><br><span class="line">          <span class="keyword">this</span>.prev = prev;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-构造函数（初始化）"><a href="#2-3-构造函数（初始化）" class="headerlink" title="2.3 构造函数（初始化）"></a>2.3 构造函数（初始化）</h2><p>LinkedList基本属性中保存了首节点与尾节点与大小，构造函数只有空参构造函数以及指定元素的构造函数两种构造方式，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">双向链表，操作类似于其他链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;    <span class="comment">//初始size</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一个节点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">//上一个节点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//addAll构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-方法"><a href="#2-4-方法" class="headerlink" title="2.4 方法"></a>2.4 方法</h2><h3 id="2-4-1-增加"><a href="#2-4-1-增加" class="headerlink" title="2.4.1 增加"></a>2.4.1 增加</h3><p>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加，addLast从尾部增加。增加原理同链表的原理类似，请看下面动图吧：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114419.gif" alt="在这里插入图片描述" title="" class="">
                <p>在这里插入图片描述</p>
            </figure>
<h3 id="2-4-2-删除"><a href="#2-4-2-删除" class="headerlink" title="2.4.2 删除"></a>2.4.2 删除</h3><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。下面看图：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114426.gif" alt="在这里插入图片描述" title="" class="">
                <p>在这里插入图片描述</p>
            </figure>
<p>补充：上面图片都是以单项列表为例的，其实和双向链表类似，只不过双向链表维护了向前和向后两个指针，也就是执行了单向链表的两次相同的操作。</p>
<h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h2><p>从数据属性来看，LinkedList是一个双向链表，符合链表的各种特性，比如查找的时间复杂度是O（n），头增加和尾增加都是O（1）等。当然如果链表实现了跳表，查找将会变成log级别的查找。跳表的详细知识，有机会我再出一篇文档吧。</p>
<h1 id="3-HashSet"><a href="#3-HashSet" class="headerlink" title="3 HashSet"></a>3 HashSet</h1><h2 id="3-1-整体架构"><a href="#3-1-整体架构" class="headerlink" title="3.1 整体架构"></a>3.1 整体架构</h2><p>HashSet主要是在 Map 的基础上组装起来的类，了解HashSet主要了解HashMap就行，我们学习它主要是学习Set 是如何利用 Map 现有的功能，来达成自己的目标的，也就是说如何基于现有的功能进行创新，然后再看看一些改变的小细节是否值得我们学习。</p>
<h2 id="3-2-类注释"><a href="#3-2-类注释" class="headerlink" title="3.2 类注释"></a>3.2 类注释</h2><p>看源码先看类注释上，我们可以得到的信息有：</p>
<ol>
<li>底层实现基于 HashMap，所以迭代时不能保证按照插入顺序，或者其它顺序进行迭代；</li>
<li>add、remove、contanins、size 等方法的耗时性能，是不会随着数据量的增加而增加的，这个主要跟 HashMap 底层的数组数据结构有关，不管数据量多大，不考虑 hash 冲突的情况下，时间复杂度都是 O (1)；</li>
<li>线程不安全的，如果需要安全请自行加锁，或者使用 Collections.synchronizedSet；</li>
<li>迭代过程中，如果数据结构被改变，会快速失败的，会抛出 ConcurrentModificationException 异常。</li>
</ol>
<h2 id="3-3-HashSet-是如何组合-HashMap-的"><a href="#3-3-HashSet-是如何组合-HashMap-的" class="headerlink" title="3.3 HashSet 是如何组合 HashMap 的"></a>3.3 HashSet 是如何组合 HashMap 的</h2><p>刚才是从类注释 1 中看到，HashSet 的实现是基于 HashMap 的，在 Java 中，要基于基础类进行创新实现，有两种办法：</p>
<ul>
<li>继承基础类，覆写基础类的方法，比如说继承 HashMap , 覆写其 add 的方法；</li>
<li>组合基础类，通过调用基础类的方法，来复用基础类的能力。</li>
</ul>
<p>HashSet 使用的就是组合 HashMap，其优点如下：</p>
<ol>
<li>继承表示父子类是同一个事物，而 Set 和 Map 本来就是想表达两种事物，所以继承不妥，而且 Java 语法限制，子类只能继承一个父类，后续难以扩展。</li>
<li>组合更加灵活，可以任意的组合现有的基础类，并且可以在基础类方法的基础上进行扩展、编排等，而且方法命名可以任意命名，无需和基础类的方法名称保持一致。</li>
</ol>
<p>我们在工作中，如果碰到类似问题，我们的原则也是尽量多用组合，少用继承。</p>
<p>组合就是把 HashMap 当作自己的一个局部变量，以下是 HashSet 的组合实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把 HashMap 组合进来，key 是 Hashset 的 key，value 是下面的 PRESENT</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">// HashMap 中的 value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>从这两行代码中，我们可以看出两点：</p>
<ol>
<li>我们在使用 HashSet 时，比如 add 方法，只有一个入参，但组合的 Map 的 add 方法却有 key，value 两个入参，相对应上 Map 的 key 就是我们 add 的入参，value 就是第二行代码中的 PRESENT，此处设计非常巧妙，用一个默认值 PRESENT 来代替 Map 的 Value；</li>
<li>如果 HashSet 是被共享的，当多个线程访问的时候，就会有线程安全问题，因为在后续的所有操作中，并没有加锁。</li>
</ol>
<p><strong>总结</strong></p>
<p>HashSet 在以 HashMap 为基础进行实现的时候，首先选择组合的方式，接着使用默认值来代替了 Map 中的 Value 值，设计得非常巧妙，给使用者的体验很好，使用起来简单方便，我们在工作中也可以借鉴这种思想，可以把底层复杂实现包装一下，一些默认实现可以自己吃掉，使吐出去的接口尽量简单好用。</p>
<h2 id="3-4-属性及构造函数"><a href="#3-4-属性及构造函数" class="headerlink" title="3.4 属性及构造函数"></a>3.4 属性及构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">     * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">     从源码解释可以看出，Set的数据结构使用的是HashMap，初始大小为16，加载因子为3/4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">有原始集合数据进行初始化的情况下，会对 HashMap 的初始容量进行计算</span></span><br><span class="line"><span class="comment"> 取括号中两个数的最大值（期望的值 / 0.75+1，默认值 16）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-方法"><a href="#3-5-方法" class="headerlink" title="3.5 方法"></a>3.5 方法</h2><p>至于 HashSet 的其他方法就比较简单了，就是对 Map 的 api 进行了一些包装，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全部都是map的key值的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><p>从源码看出，HashSet复用HashMap的代码，使用聚合的方式进行复用，所以下文主要以分析HashMap为主。</p>
<h1 id="4-HashMap"><a href="#4-HashMap" class="headerlink" title="4 HashMap"></a>4 HashMap</h1><h2 id="4-1-整体框架"><a href="#4-1-整体框架" class="headerlink" title="4.1 整体框架"></a>4.1 整体框架</h2><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时，链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构如下图：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114435.png" alt="图片描述" title="" class="">
                <p>图片描述</p>
            </figure>
<p>图中左边竖着的是 HashMap 的数组结构，数组的元素可能是单个 Node，也可能是个链表，也可能是个红黑树，比如数组下标索引为 2 的位置就是一个链表，下标索引为 9 的位置对应的就是红黑树。</p>
<h2 id="4-2-类注释"><a href="#4-2-类注释" class="headerlink" title="4.2 类注释"></a>4.2 类注释</h2><p>从 HashMap 的类注释中，我们可以得到如下信息：</p>
<ul>
<li>允许 null 值，不同于 HashTable ，是线程不安全的；</li>
<li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor；</li>
<li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能；</li>
<li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过 Collections.synchronizedMap 来实现线程安全，Collections.synchronizedMap 的实现是在每个方法上加上了 synchronized 锁；或者使用ConcurrentHashMap，下文也会对ConcurrentHashMap进行简单阐述。</li>
<li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li>
</ul>
<h2 id="4-3-属性"><a href="#4-3-属性" class="headerlink" title="4.3 属性"></a>4.3 属性</h2><p>属性源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认数组初始化大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组最大大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载系数，用于数组数量达到 CAPACITY*LOAD_FACTOR（默认为12）时，对数组进行扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表树化的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树链化的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> * 当数组容量大于 64 时，链表才会转化成红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的节点</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"> //红黑树的节点</span></span><br><span class="line"><span class="class"> <span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h2><h3 id="4-1-1-指定加载因子以及初始大小"><a href="#4-1-1-指定加载因子以及初始大小" class="headerlink" title="4.1.1 指定加载因子以及初始大小"></a>4.1.1 指定加载因子以及初始大小</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-指定初始化大小"><a href="#4-1-2-指定初始化大小" class="headerlink" title="4.1.2 指定初始化大小"></a>4.1.2 指定初始化大小</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-空参构造"><a href="#4-1-3-空参构造" class="headerlink" title="4.1.3 空参构造"></a>4.1.3 空参构造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-4-数据集合构造"><a href="#4-1-4-数据集合构造" class="headerlink" title="4.1.4 数据集合构造"></a>4.1.4 数据集合构造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.putAll and Map constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><p>4.2.1 hash方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hashCode右移16位，正好是32bit的一半。与自己本身做异或操作（相同为0，不同为1）。就是为了混合哈希值的高位和地位，增加低位的随机性。并且混合后的值也变相保持了高位的特征。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-1-新增-put与putVal-："><a href="#4-2-1-新增-put与putVal-：" class="headerlink" title="4.2.1 新增(put与putVal)："></a>4.2.1 新增(put与putVal)：</h3><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增 key，value 大概的步骤如下：</p>
<ol>
<li>空数组有无初始化，没有的话初始化；</li>
<li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li>
<li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li>
<li>如果是链表，递归循环，把新元素追加到队尾；</li>
<li>如果是红黑树，调用红黑树新增的方法；</li>
<li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li>
<li>判断是否需要扩容，需要扩容进行扩容，结束。</li>
</ol>
<p>我们来画一张示意图来描述下：</p>
<p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114448.jpg" alt="图片描述" style="zoom:67%;"></p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入参 hash：通过 hash 算法计算出来的值。</span></span><br><span class="line"><span class="comment">// 入参 onlyIfAbsent：false 表示即使 key 已经存在了，仍然会用新值覆盖原来的值，默认为 false</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n 表示数组的长度，i 为数组索引下标，p 为 i 下标位置的 Node 值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果数组为空，使用 resize 方法初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果当前索引位置有值的处理方法，即我们常说的如何解决 hash 冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e 当前节点的临时变量</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果 key 的 hash 和值都相等，直接把当前下标位置的 Node 值赋值给临时变量</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是红黑树，使用红黑树的方式新增</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 是个链表，把新节点放到链表的尾端</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// e = p.next 表示从头开始，遍历链表</span></span><br><span class="line">                <span class="comment">// p.next == null 表明 p 是链表的尾节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 把新节点放到链表的尾部 </span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 当链表的长度大于等于 8 时，链表转红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 链表遍历过程中，发现有元素和新增的元素相等，结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//更改循环的当前元素，使 p 在遍历过程中，一直往后移动。</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明新节点的新增位置已经找到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 当 onlyIfAbsent 为 false 时，才会覆盖值 </span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录 HashMap 的数据结构发生了变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果 HashMap 的实际大小大于扩容的门槛，开始扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-链表的新增"><a href="#4-2-2-链表的新增" class="headerlink" title="4.2.2 链表的新增"></a>4.2.2 链表的新增</h3><p>链表的新增比较简单，就是把当前节点追加到链表的尾部，和 LinkedList 的追加实现一样的。</p>
<p>当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组大小小于 64 时，只会触发扩容，不会转化成红黑树，</p>
<p><strong>为什么是8</strong></p>
<blockquote>
<p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p>
<p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各个长度的命中概率为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; * <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line">&gt; * <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line">&gt; * <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line">&gt; * <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line">&gt; * <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line">&gt; * <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line">&gt; * <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line">&gt; * <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line">&gt; * <span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写代码，使用 HashMap 时，几乎不会碰到链表转化成红黑树的情况，毕竟概念只有千万分之一。</p>
</blockquote>
<h3 id="4-2-2-红黑树新增节点过程"><a href="#4-2-2-红黑树新增节点过程" class="headerlink" title="4.2.2 红黑树新增节点过程"></a>4.2.2 红黑树新增节点过程</h3><ol>
<li><p>首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种：</p>
<p>1.1. 如果节点没有实现 Comparable 接口，使用 equals 进行判断；</p>
<p>1.2. 如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。</p>
</li>
<li><p>新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大；</p>
</li>
<li><p>自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点；</p>
</li>
<li><p>把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系；</p>
</li>
<li><p>进行着色和旋转，结束</p>
</li>
</ol>
<h3 id="4-2-3-resize（）-扩容并重新计算大小"><a href="#4-2-3-resize（）-扩容并重新计算大小" class="headerlink" title="4.2.3 resize（）:扩容并重新计算大小"></a>4.2.3 resize（）:扩容并重新计算大小</h3><p>当HashMap容量大小不够时，就需要扩容，调用的就是resize()方法，下面对resize进行分析。</p>
<p>先看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// 原索引存放的引用</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// 原索引+oldCap存放的引用</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                       <span class="comment">/*</span></span><br><span class="line"><span class="comment">                       取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作</span></span><br><span class="line"><span class="comment">                     （也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。</span></span><br><span class="line"><span class="comment">                      */</span></span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e; <span class="comment">// 头插法</span></span><br><span class="line">                            loTail = e; <span class="comment">// 头插法</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释</p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114503.jpg)" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114509.jpg" alt="img" title="" class="">
                <p>img</p>
            </figure>
<p>对index计算的解释</p>
<p>1.如果旧表数组index只有一个元素，则直接计算新值<code>newTab[e.hash &amp; (newCap - 1)] = e;</code></p>
<p>2.如果旧表数组index是链表，则执行一下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;                      <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">&gt;                          <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">&gt;                              loHead = e;</span><br><span class="line">&gt;                          <span class="keyword">else</span></span><br><span class="line">&gt;                              loTail.next = e; <span class="comment">// 头插法</span></span><br><span class="line">&gt;                          loTail = e; <span class="comment">// 头插法</span></span><br><span class="line">&gt;                      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 原索引+oldCap</span></span><br><span class="line">&gt;                          <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">&gt;                              hiHead = e;</span><br><span class="line">&gt;                          <span class="keyword">else</span></span><br><span class="line">&gt;                              hiTail.next = e;</span><br><span class="line">&gt;                          hiTail = e;</span><br><span class="line">&gt;                      &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>为什么是e.hash &amp; oldCap？</p>
<p>(e.hash &amp; oldCap) 得到的是 元素的在数组中的位置是否需要移动,示例如下<br>示例1：<br>e.hash=10 0000 1010<br>oldCap=16 0001 0000<br>     &amp;   =0     0000 0000       比较高位的第一位 0<br>结论：元素位置在扩容后数组中的位置没有发生改变</p>
<p>示例2：<br>e.hash=17 0001 0001<br>oldCap=16 0001 0000<br>     &amp;   =1     0001 0000      比较高位的第一位   1<br>结论：元素位置在扩容后数组中的位置发生了改变，新的下标位置是原下标位置+原数组长度</p>
</blockquote>
<h1 id="5-ConcurrentHashMap"><a href="#5-ConcurrentHashMap" class="headerlink" title="5 ConcurrentHashMap"></a>5 ConcurrentHashMap</h1><p>当我们碰到线程不安全场景下，需要使用 Map 的时候，我们第一个想到的 API 估计就是 ConcurrentHashMap，ConcurrentHashMap 内部封装了锁和各种数据结构来保证访问 Map 是线程安全的，接下来我们一一来看下，和 HashMap 相比，多了哪些数据结构，又是如何保证线程安全的。</p>
<h2 id="5-1-结构"><a href="#5-1-结构" class="headerlink" title="5.1 结构"></a>5.1 结构</h2><p>虽然 ConcurrentHashMap 的底层数据结构，和方法的实现细节和 HashMap 大体一致，但两者在类结构上却没有任何关联，我们看下 ConcurrentHashMap 的类图：<br><figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114518.png" alt="图片描述" title="" class="">
                <p>图片描述</p>
            </figure><br>看 ConcurrentHashMap 源码，我们会发现很多方法和代码和 HashMap 很相似，有的同学可能会问，为什么不继承 HashMap 呢？继承的确是个好办法，但尴尬的是，ConcurrentHashMap 都是在方法中间进行一些加锁操作，也就是说加锁把方法切割了，继承就很难解决这个问题。</p>
<h3 id="5-1-1-两者的相同之处："><a href="#5-1-1-两者的相同之处：" class="headerlink" title="5.1.1 两者的相同之处："></a>5.1.1 两者的相同之处：</h3><ol>
<li>数组、链表结构几乎相同，所以底层对数据结构的操作思路是相同的（只是思路相同，底层实现不同）；</li>
<li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都是相同的，HashMap 有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap 时，无需关心两者之间的兼容问题。</li>
</ol>
<h3 id="5-1-2-不同之处："><a href="#5-1-2-不同之处：" class="headerlink" title="5.1.2 不同之处："></a>5.1.2 不同之处：</h3><ol>
<li>红黑树结构略有不同，HashMap 的红黑树中的节点叫做 TreeNode，TreeNode 不仅仅有属性，还维护着红黑树的结构，比如说查找，新增等等；ConcurrentHashMap 中红黑树被拆分成两块，TreeNode 仅仅维护的属性和查找功能，新增了 TreeBin，来维护红黑树结构，并负责根节点的加锁和解锁；</li>
<li>新增 ForwardingNode （转移）节点，扩容的时候会使用到，通过使用该节点，来保证扩容时的线程安全。</li>
</ol>
<p>如下图所示：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114526" alt="img" title="" class="">
                <p>img</p>
            </figure>
<h2 id="5-2-类注释"><a href="#5-2-类注释" class="headerlink" title="5.2 类注释"></a>5.2 类注释</h2><p>我们从类注释上大概可以得到如下信息：</p>
<ol>
<li>所有的操作都是线程安全的，我们在使用时，无需再加锁；</li>
<li>多个线程同时进行 put、remove 等操作时并不会阻塞，可以同时进行，和 HashTable 不同，HashTable 在操作时，会锁住整个 Map；</li>
<li>迭代过程中，即使 Map 结构被修改，也不会抛 ConcurrentModificationException 异常；</li>
<li>除了数组 + 链表 + 红黑树的基本结构外，新增了转移节点，是为了保证扩容时的线程安全的节点；</li>
<li>提供了很多 Stream 流式方法，比如说：forEach、search、reduce 等等。</li>
</ol>
<p>从类注释中，我们可以看出 ConcurrentHashMap 和 HashMap 相比，新增了转移节点的数据结构，至于底层如何实现线程安全，转移节点的具体细节，暂且看不出来，接下来我们细看源码</p>
<h2 id="5-3-属性"><a href="#5-3-属性" class="headerlink" title="5.3 属性"></a>5.3 属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7249069246763182397L</span>;</span><br><span class="line">    <span class="comment">// 表的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认表的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 最大数组大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 默认并发数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 装载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 转化为红黑树的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 由红黑树转化为链表的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 转化为红黑树的表的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 每次进行转移的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 生成sizeCtl所使用的bit位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 进行扩容所允许的最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 记录sizeCtl中的大小所需要进行的偏移位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;    </span><br><span class="line">    <span class="comment">// 一系列的标识</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">/** Number of CPUS, to place bounds on some sizings */</span></span><br><span class="line">    <span class="comment">// 获取可用的CPU个数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">/** For serialization compatibility. */</span></span><br><span class="line">    <span class="comment">// 进行序列化的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">"segments"</span>, Segment[].class),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">"segmentMask"</span>, Integer.TYPE),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">"segmentShift"</span>, Integer.TYPE)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">// 下一个表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base counter value, used mainly when there is no contention,</span></span><br><span class="line"><span class="comment">     * but also as a fallback during table initialization</span></span><br><span class="line"><span class="comment">     * races. Updated via CAS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 基本计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">     * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">     * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">     * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">     * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">     * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 对表初始化和扩容控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next table index (plus one) to split while resizing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 扩容下另一个表的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 旋转锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// counterCell表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// views</span></span><br><span class="line">    <span class="comment">// 视图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">            SIZECTL = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"sizeCtl"</span>));</span><br><span class="line">            TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"transferIndex"</span>));</span><br><span class="line">            BASECOUNT = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"baseCount"</span>));</span><br><span class="line">            CELLSBUSY = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"cellsBusy"</span>));</span><br><span class="line">            Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">            CELLVALUE = U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">            Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">            ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">            <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">            <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">            ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-方法"><a href="#5-4-方法" class="headerlink" title="5.4 方法"></a>5.4 方法</h2><h3 id="5-4-1-新增元素（putVal）"><a href="#5-4-1-新增元素（putVal）" class="headerlink" title="5.4.1 新增元素（putVal）"></a>5.4.1 新增元素（putVal）</h3><p>put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。</p>
<p>　　① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p>
<p>　　② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p>
<p>　　③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p>
<p>　　④ 若该结点的的hash值为<strong>MOVED，则对该桶中的结点进行转移（协助转换）</strong>，否则，进入步骤⑤</p>
<p>　　⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p>
<p>　　⑥ 若<strong>binCount</strong>值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// 键或值为空，抛出异常</span></span><br><span class="line">        <span class="comment">// 键的hash值经过计算获得hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 表为空或者表的长度为0</span></span><br><span class="line">                <span class="comment">// 初始化表</span></span><br><span class="line">                tab = initTable();<span class="comment">//里面使用sizeCtl控制多线程争用问题，cas修改sizeCtl</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123; <span class="comment">// 表不为空并且表的长度大于0，并且该桶不为空</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>))) <span class="comment">// 比较并且交换值，如tab的第i项为空则用新生成的node替换</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 该结点的hash值为MOVED</span></span><br><span class="line">                <span class="comment">// 进行结点的转移（在扩容的过程中）</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 加锁同步</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 找到table表下标为i的节点</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 该table表中该结点的hash值大于0</span></span><br><span class="line">                            <span class="comment">// binCount赋值为1</span></span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123; <span class="comment">// 结点的hash值相等并且key也相等</span></span><br><span class="line">                                    <span class="comment">// 保存该结点的val值</span></span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent) <span class="comment">// 进行判断</span></span><br><span class="line">                                        <span class="comment">// 将指定的value保存至结点，即进行了结点值的更新</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 保存当前结点</span></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 当前结点的下一个结点为空，即为最后一个结点</span></span><br><span class="line">                                    <span class="comment">// 新生一个结点并且赋值给next域</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="comment">// 退出循环</span></span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 结点为红黑树结点类型</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            <span class="comment">// binCount赋值为2</span></span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123; <span class="comment">// 将hash、key、value放入红黑树</span></span><br><span class="line">                                <span class="comment">// 保存结点的val</span></span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) <span class="comment">// 判断</span></span><br><span class="line">                                    <span class="comment">// 赋值结点value值</span></span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; <span class="comment">// binCount不为0</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) <span class="comment">// 如果binCount大于等于转化为红黑树的阈值</span></span><br><span class="line">                        <span class="comment">// 进行转化</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) <span class="comment">// 旧值不为空</span></span><br><span class="line">                        <span class="comment">// 返回旧值</span></span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加binCount的数量</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我想有基础的同学知道在jdk1.7中是采用Segment + HashEntry + ReentrantLock的方式进行实现的，而1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。</p>
<ul>
<li><p>JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而<strong>JDK1.8锁的粒度就是HashEntry（首节点）</strong></p>
</li>
<li><p>JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了</p>
</li>
<li><p>JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</p>
</li>
</ul>
</blockquote>
<h3 id="5-4-2-扩容及协助扩容"><a href="#5-4-2-扩容及协助扩容" class="headerlink" title="5.4.2 扩容及协助扩容"></a>5.4.2 扩容及协助扩容</h3><p>当put的时候，有下面这样一句代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该结点的hash值为MOVED</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) </span><br><span class="line"><span class="comment">// 进行结点的转移（在扩容的过程中）</span></span><br><span class="line">tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure>
<p>所以，每个线程都会去帮助正在扩容的map去扩容——协助扩容。</p>
<p>通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable，扩容后的数组长度为原来的两倍，但是容量是原来的1.5。</p>
<p>节点从table移动到nextTable，大体思想是遍历、复制的过程。</p>
<ol>
<li>首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd。</li>
<li><p>如果f == null，则在table中的i位置放入fwd，这个过程是采用Unsafe.compareAndSwapObjectf方法实现的，很巧妙的实现了节点的并发移动。</p>
</li>
<li><p>如果f是链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上，移动完成，采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。</p>
</li>
<li><p>如果f是TreeBin节点，也做一个反序处理，并判断是否需要untreeify，把处理的结果分别放在nextTable的i和i+n的位置上，移动完成，同样采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。</p>
</li>
</ol>
<p>遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍 ，扩容完成。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A node inserted at head of bins during transfer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">        outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> eh; K ek;</span><br><span class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                        <span class="keyword">continue</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>大家平时都特别喜欢用map这个集合，但是有一个问题得注意一下：jdk1.7HashMap与jdk1.8concurrenthashmap出现的死循环问题（map.computeIfAbsent这个函数，有兴趣的可以去看下源码，有机会为大家解说一波）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>在1.8中ConcurrentHashMap的get操作全程不需要加锁，这也是它比其他并发集合比如hashtable、用Collections.synchronizedMap()包装的hashmap;安全效率高的原因之一。</li>
<li>get操作全程不需要加锁是因为Node的成员val是用volatile修饰的和数组用volatile修饰没有关系。</li>
<li>数组用volatile修饰主要是保证在数组扩容的时候保证可见性。</li>
</ul>
<p>以上就是我对集合类的一些看法，大家有什么问题，及时提出更正！</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>spring的一些问题</title>
    <url>/2020/09/24/java/spring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是三级缓存"><a href="#什么是三级缓存" class="headerlink" title="什么是三级缓存"></a>什么是三级缓存</h1><ol>
<li>第一级缓存：单例缓存池singletonObjects。</li>
<li>第二级缓存：早期提前暴露的对象缓存earlySingletonObjects。（属性还没有值对象也没有被初始化）</li>
<li>第三级缓存：singletonFactories单例对象工厂缓存。</li>
</ol>
<p>三级缓存详解：<a href="http://mp.weixin.qq.com/s?__biz=Mzg2MjEwMjI1Mg==&amp;mid=2247494504&amp;idx=1&amp;sn=12da3bdc73d03bafb6c3de586f828b2f&amp;chksm=ce0e5cebf979d5fd61cc6f5fef26f83436a3799aaf79872fa475ca11f8821f6a723b448dd232&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">根据 Spring 源码写一个带有三级缓存的 IOC</a></p>
<a id="more"></a>
<h1 id="Spring如何解决循环依赖问题"><a href="#Spring如何解决循环依赖问题" class="headerlink" title="Spring如何解决循环依赖问题"></a>Spring如何解决循环依赖问题</h1><p>Spring使用了三级缓存解决了循环依赖的问题。在populateBean()给属性赋值阶段里面Spring会解析你的属性，并且赋值，当发现，A对象里面依赖了B，此时又会走getBean方法，但这个时候，你去缓存中是可以拿的到的。因为我们在对createBeanInstance对象创建完成以后已经放入了缓存当中，所以创建B的时候发现依赖A，直接就从缓存中去拿，此时B创建完，A也创建完，一共执行了4次。至此Bean的创建完成，最后将创建好的Bean放入单例缓存池中。</p>
<p>BeanFactory和ApplicationContext的区别</p>
<ol>
<li>BeanFactory是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。</li>
<li>ApplicationContext应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能。如国际化，访问资源，载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，消息发送、响应机制，AOP等。</li>
<li>BeanFactory在启动的时候不会去实例化Bean，中有从容器中拿Bean的时候才会去实例化。ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化</li>
</ol>
<h1 id="动态代理的实现方式，AOP的实现方式"><a href="#动态代理的实现方式，AOP的实现方式" class="headerlink" title="动态代理的实现方式，AOP的实现方式"></a>动态代理的实现方式，AOP的实现方式</h1><ol>
<li>JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</li>
<li>CGlib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。</li>
</ol>
<h1 id="Transactional错误使用失效场景"><a href="#Transactional错误使用失效场景" class="headerlink" title="@Transactional错误使用失效场景"></a>@Transactional错误使用失效场景</h1><ol>
<li>@Transactional 在private上：当标记在protected、private、package-visible方法上时，不会产生错误，但也不会表现出为它指定的事务配置。可以认为它作为一个普通的方法参与到一个public方法的事务中。</li>
<li>@Transactional 的事务传播方式配置错误。</li>
<li>@Transactional 注解属性 rollbackFor 设置错误：Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。</li>
<li>同一个类中方法调用，导致@Transactional失效：由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</li>
<li>异常被 catch 捕获导致@Transactional失效。</li>
<li>数据库引擎不支持事务。</li>
</ol>
<h1 id="Spring的的事务传播机制"><a href="#Spring的的事务传播机制" class="headerlink" title="Spring的的事务传播机制"></a>Spring的的事务传播机制</h1><ol>
<li>REQUIRED（默认，常用）：支持使用当前事务，如果当前事务不存在，创建一个新事务。eg:方法B用REQUIRED修饰，方法A调用方法B，如果方法A当前没有事务，方法B就新建一个事务（若还有C则B和C在各自的事务中独立执行），如果方法A有事务，方法B就加入到这个事务中，当成一个事务。</li>
<li>SUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。</li>
<li>MANDATORY：强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。</li>
<li>REQUIRES_NEW（常用）：创建一个新事务，如果当前事务存在，把当前事务挂起。eg:方法B用REQUIRES_NEW修饰，方法A调用方法B，不管方法A上有没有事务方法B都新建一个事务，在该事务执行。</li>
<li>NOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起。</li>
<li>NEVER：无事务执行，如果当前有事务则抛出Exception。</li>
<li>NESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</li>
</ol>
<h1 id="Spring中Bean的生命周期"><a href="#Spring中Bean的生命周期" class="headerlink" title="Spring中Bean的生命周期"></a>Spring中Bean的生命周期</h1><ol>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ol>
<h1 id="Spring的后置处理器"><a href="#Spring的后置处理器" class="headerlink" title="Spring的后置处理器"></a>Spring的后置处理器</h1><ol>
<li>BeanPostProcessor：Bean的后置处理器，主要在bean初始化前后工作。（before和after两个回调中间只处理了init-method）</li>
<li>InstantiationAwareBeanPostProcessor：继承于BeanPostProcessor，主要在实例化bean前后工作（TargetSource的AOP创建代理对象就是通过该接口实现）</li>
<li>BeanFactoryPostProcessor：Bean工厂的后置处理器，在bean定义(bean definitions)加载完成后，bean尚未初始化前执行。</li>
<li>BeanDefinitionRegistryPostProcessor：继承于BeanFactoryPostProcessor。其自定义的方法postProcessBeanDefinitionRegistry会在bean定义(bean definitions)将要加载，bean尚未初始化前真执行，即在BeanFactoryPostProcessor的postProcessBeanFactory方法前被调用。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized and volatile</title>
    <url>/2020/05/10/java/synchronized-and-volatile/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用户态与内核态</p>
<p>JDK早期，synchronized 叫做重量级锁， 因为申请锁资源必须通过kernel, 系统调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;hello.asm</span><br><span class="line">;write(int fd, const void *buffer, size_t nbytes)</span><br><span class="line"></span><br><span class="line">section data</span><br><span class="line">    msg db &quot;Hello&quot;, 0xA</span><br><span class="line">    len equ $ - msg</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    mov edx, len</span><br><span class="line">    mov ecx, msg</span><br><span class="line">    mov ebx, 1 ;文件描述符1 std_out</span><br><span class="line">    mov eax, 4 ;write函数系统调用号 4</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">    mov ebx, 0</span><br><span class="line">    mov eax, 1 ;exit函数系统调用号</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>Compare And Swap (Compare And Exchange) / 自旋 / 自旋锁 / 无锁 （无重量锁）</p>
<p>因为经常配合循环操作，直到完成为止，所以泛指一类操作</p>
<p>cas(v, a, b) ，变量v，期待值a, 修改值b</p>
<p>ABA问题，你的女朋友在离开你的这段儿时间经历了别的人，自旋就是你空转等待，一直等到她接纳你为止</p>
<p>解决办法（版本号 AtomicStampedReference），基础类型简单值不需要版本号</p>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>AtomicInteger:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Unsafe:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>
<p>运用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T02_TestUnsafe t = <span class="keyword">new</span> T02_TestUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = T02_TestUnsafe.class.getDeclaredField(<span class="string">"i"</span>);</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jdk8u: unsafe.cpp:</p>
<p>cmpxchg = compare and exchange</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>
<p>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></p>
<p>is_MP = Multi Processor  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"</span><br><span class="line">                    : <span class="string">"=a"</span> (exchange_value)</span><br><span class="line">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span><br><span class="line">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>);</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jdk8u: os.hpp is_MP()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jdk8u: atomic_linux_x86.inline.hpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure>
<p>最终实现：</p>
<p>cmpxchg = cas修改变量值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></table></figure>
<p>硬件：</p>
<p>lock指令在执行后面指令的时候锁定一个北桥信号</p>
<p>（不采用锁总线的方式）</p>
<h1 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h1><h1 id="工具：JOL-Java-Object-Layout"><a href="#工具：JOL-Java-Object-Layout" class="headerlink" title="工具：JOL = Java Object Layout"></a>工具：JOL = Java Object Layout</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>jdk8u: markOop.hpp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br></pre></td></tr></table></figure>
<h1 id="synchronized的横切面详解"><a href="#synchronized的横切面详解" class="headerlink" title="synchronized的横切面详解"></a>synchronized的横切面详解</h1><ol>
<li>synchronized原理</li>
<li>升级过程</li>
<li>汇编实现</li>
<li>vs reentrantLock的区别</li>
</ol>
<h2 id="java源码层级"><a href="#java源码层级" class="headerlink" title="java源码层级"></a>java源码层级</h2><p>synchronized(o) </p>
<h2 id="字节码层级"><a href="#字节码层级" class="headerlink" title="字节码层级"></a>字节码层级</h2><p>monitorenter moniterexit</p>
<h2 id="JVM层级（Hotspot）"><a href="#JVM层级（Hotspot）" class="headerlink" title="JVM层级（Hotspot）"></a>JVM层级（Hotspot）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.insidesync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_Sync1</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.mashibing.insidesync.T01_Sync1$Lock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)  <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)  <span class="number">49</span> ce <span class="number">00</span> <span class="number">20</span> (<span class="number">01001001</span> <span class="number">11001110</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536923721</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.mashibing.insidesync.T02_Sync2$Lock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)  <span class="number">05</span> <span class="number">90</span> <span class="number">2</span>e <span class="number">1</span>e (<span class="number">00000101</span> <span class="number">10010000</span> <span class="number">00101110</span> <span class="number">00011110</span>) (<span class="number">506368005</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)  <span class="number">1</span>b <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00011011</span> <span class="number">00000010</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">539</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)  <span class="number">49</span> ce <span class="number">00</span> <span class="number">20</span> (<span class="number">01001001</span> <span class="number">11001110</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536923721</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes tota</span><br></pre></td></tr></table></figure>
<p>InterpreterRuntime:: monitorenter方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  Handle h_obj(thread, elem-&gt;obj());</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>
<p>synchronizer.cpp</p>
<p>revoke_and_rebias</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS) &#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assert(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  assert(!mark-&gt;has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    assert(lock != mark-&gt;locker(), <span class="string">"must not re-lock the same lock"</span>);</span><br><span class="line">    assert(lock != (BasicLock*)obj-&gt;mark(), <span class="string">"don't relock with same BasicLock"</span>);</span><br><span class="line">    lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn't particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inflate方法：膨胀为重量级锁</p>
<h1 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h1><h2 id="JDK8-markword实现表："><a href="#JDK8-markword实现表：" class="headerlink" title="JDK8 markword实现表："></a>JDK8 markword实现表：</h2><figure class="image-box">
                <img src="C:\work\courses\公开课\面试题\你以为你真的懂Synchronized\lock_step.png" alt="image-20200419213508934" title="" class="">
                <p>image-20200419213508934</p>
            </figure>
<figure class="image-box">
                <img src="C:\work\courses\公开课\面试题\你以为你真的懂Synchronized\markword-64.png" alt="" title="" class="">
                <p></p>
            </figure>
<p><strong>自旋锁什么时候升级为重量级锁？</strong></p>
<p><strong>为什么有自旋锁还需要重量级锁？</strong></p>
<blockquote>
<p>自旋是消耗CPU资源的，如果锁的时间长，或者自旋线程多，CPU会被大量消耗</p>
<p>重量级锁有等待队列，所有拿不到锁的进入等待队列，不需要消耗CPU资源</p>
</blockquote>
<p><strong>偏向锁是否一定比自旋锁效率高？</strong></p>
<blockquote>
<p>不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁</p>
<p>JVM启动过程，会有很多线程竞争（明确），所以默认情况启动时不打开偏向锁，过一段儿时间再打开</p>
</blockquote>
<p>new - 偏向锁 - 轻量级锁 （无锁, 自旋锁，自适应自旋）- 重量级锁</p>
<p>synchronized优化的过程和markword息息相关</p>
<p>用markword中最低的三位代表锁状态 其中1位是偏向锁位 两位是普通锁位</p>
<ol>
<li><p>Object o = new Object()<br>锁 = 0 01 无锁态<br>注意：如果偏向锁打开，默认是匿名偏向状态</p>
</li>
<li><p>o.hashCode()<br>001 + hashcode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">00000001</span> <span class="number">10101101</span> <span class="number">00110100</span> <span class="number">00110110</span></span><br><span class="line"><span class="number">01011001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>
<p>little endian big endian </p>
<p>00000000 00000000 00000000 01011001 00110110 00110100 10101101 00000000</p>
</li>
<li><p>默认synchronized(o)<br>00 -&gt; 轻量级锁<br>默认情况 偏向锁有个时延，默认是4秒<br>why? 因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果设定上述参数<br>new Object () - &gt; 101 偏向锁 -&gt;线程ID为0 -&gt; Anonymous BiasedLock<br>打开偏向锁，new出来的对象，默认就是一个可偏向匿名对象101</p>
</li>
<li><p>如果有线程上锁<br>上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程<br>偏向锁不可重偏向 批量偏向 批量撤销</p>
</li>
<li><p>如果有线程竞争<br>撤销偏向锁，升级轻量级锁<br>线程在自己的线程栈生成LockRecord ，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁</p>
</li>
<li><p>如果竞争加剧<br>竞争加剧：有线程超过10次自旋， -XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半， 1.6之后，加入自适应自旋 Adapative Self Spinning ， JVM自己控制<br>升级重量级锁：-&gt; 向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间</p>
</li>
</ol>
<p>(以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头是无锁)</p>
<p>偏向锁默认是打开的，但是有一个时延，如果要观察到偏向锁，应该设定参数</p>
<p><strong>如果计算过对象的hashCode，则对象无法进入偏向状态！</strong></p>
<blockquote>
<p>轻量级锁重量级锁的hashCode存在与什么地方？</p>
<p>答案：线程栈中，轻量级锁的LR中，或是代表重量级锁的ObjectMonitor的成员中</p>
</blockquote>
<p>关于epoch: (不重要)</p>
<blockquote>
<p><strong>批量重偏向与批量撤销</strong>渊源：从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p>
<p><strong>原理</strong>以class为单位，为每个class维护<strong>解决场景</strong>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p>
<p>一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
</blockquote>
<p>没错，我就是厕所所长</p>
<p>加锁，指的是锁定对象</p>
<p>锁升级的过程</p>
<p>JDK较早的版本 OS的资源 互斥量 用户态 -&gt; 内核态的转换 重量级 效率比较低</p>
<p>现代版本进行了优化</p>
<p>无锁 - 偏向锁 -轻量级锁（自旋锁）-重量级锁</p>
<p>偏向锁 - markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。hashCode备份在线程栈上 线程销毁，锁降级为无锁</p>
<p>有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁</p>
<p>自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin</p>
<p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</p>
<h2 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h2><p>sychronized是可重入锁</p>
<p>重入次数必须记录，因为要解锁几次必须得对应</p>
<p>偏向锁 自旋锁 -&gt; 线程栈 -&gt; LR + 1</p>
<p>重量级锁 -&gt; ? ObjectMonitor字段上</p>
<h2 id="synchronized最底层实现"><a href="#synchronized最底层实现" class="headerlink" title="synchronized最底层实现"></a>synchronized最底层实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123; i++; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">publics <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1000_000</span>; j++) &#123;</span><br><span class="line">            m();</span><br><span class="line">            n();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly T</p>
<p>C1 Compile Level 1 (一级优化)</p>
<p>C2 Compile Level 2 (二级优化)</p>
<p>找到m() n()方法的汇编码，会看到 lock comxchg …..指令</p>
<h2 id="synchronized-vs-Lock-CAS"><a href="#synchronized-vs-Lock-CAS" class="headerlink" title="synchronized vs Lock (CAS)"></a>synchronized vs Lock (CAS)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在高争用 高耗时的环境下synchronized效率更高</span><br><span class="line">在低争用 低耗时的环境下CAS效率更高</span><br><span class="line">synchronized到重量级之后是等待队列（不消耗CPU）</span><br><span class="line">CAS（等待期间消耗CPU）</span><br><span class="line"></span><br><span class="line">一切以实测为准</span><br></pre></td></tr></table></figure>
<h1 id="锁消除-lock-eliminate"><a href="#锁消除-lock-eliminate" class="headerlink" title="锁消除 lock eliminate"></a>锁消除 lock eliminate</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">         StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">         sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。</p>
<h1 id="锁粗化-lock-coarsening"><a href="#锁粗化-lock-coarsening" class="headerlink" title="锁粗化 lock coarsening"></a>锁粗化 lock coarsening</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       StringBuffer sb = <span class="keyword">new</span> StringBuffer():</span><br><span class="line">       <span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">           sb.append(str);</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。</p>
<h1 id="锁降级（不重要）"><a href="#锁降级（不重要）" class="headerlink" title="锁降级（不重要）"></a>锁降级（不重要）</h1><p><a href="https://www.zhihu.com/question/63859501" target="_blank" rel="noopener">https://www.zhihu.com/question/63859501</a></p>
<p>其实，只被VMThread访问，降级也就没啥意义了。所以可以简单认为锁降级不存在！</p>
<h1 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h1><p>一个ALU + 两组Registers + PC</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p>
<h1 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h1><h2 id="1-线程可见性"><a href="#1-线程可见性" class="headerlink" title="1.线程可见性"></a>1.线程可见性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.testvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ThreadVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//do sth</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        &#125;, <span class="string">"server"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-防止指令重排序"><a href="#2-防止指令重排序" class="headerlink" title="2.防止指令重排序"></a>2.防止指令重排序</h2><h3 id="问题：DCL单例需不需要加volatile？"><a href="#问题：DCL单例需不需要加volatile？" class="headerlink" title="问题：DCL单例需不需要加volatile？"></a>问题：DCL单例需不需要加volatile？</h3><h3 id="CPU的基础知识"><a href="#CPU的基础知识" class="headerlink" title="CPU的基础知识"></a>CPU的基础知识</h3><ul>
<li><p>缓存行对齐<br>缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高<br>Disruptor</p>
</li>
<li><p><strong>需要注意，JDK8引入了@sun.misc.Contended注解，来保证缓存行隔离效果</strong><br>要使用此注解，必须去掉限制参数：-XX:-RestrictContended</p>
</li>
<li><p>另外，java编译器或者JIT编译器有可能会去除没用的字段，所以填充字段必须加上volatile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_028_FalseSharing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CacheLinePadding</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MESI</p>
</li>
<li><p>伪共享</p>
</li>
<li><p>合并写<br>CPU内部的4个字节的Buffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_029_WriteCombining;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteCombining</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITERATIONS = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITEMS = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK = ITEMS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayD = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayE = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayF = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">" SingleLoop duration (ns) = "</span> + runCaseOne());</span><br><span class="line">            System.out.println(i + <span class="string">" SplitLoop  duration (ns) = "</span> + runCaseTwo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>指令重排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.c3_jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_Disorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>;</span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.</span></span><br><span class="line">                    <span class="comment">//shortWait(100000);</span></span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread other = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    y = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();other.start();</span><br><span class="line">            one.join();other.join();</span><br><span class="line">            String result = <span class="string">"第"</span> + i + <span class="string">"次 ("</span> + x + <span class="string">","</span> + y + <span class="string">"）"</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(result);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortWait</span><span class="params">(<span class="keyword">long</span> interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            end = System.nanoTime();</span><br><span class="line">        &#125;<span class="keyword">while</span>(start + interval &gt;= end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="系统底层如何实现数据一致性"><a href="#系统底层如何实现数据一致性" class="headerlink" title="系统底层如何实现数据一致性"></a>系统底层如何实现数据一致性</h3><ol>
<li>MESI如果能解决，就使用MESI</li>
<li>如果不能，就锁总线</li>
</ol>
<h3 id="系统底层如何保证有序性"><a href="#系统底层如何保证有序性" class="headerlink" title="系统底层如何保证有序性"></a>系统底层如何保证有序性</h3><ol>
<li>内存屏障sfence mfence lfence等系统原语</li>
<li>锁总线</li>
</ol>
<h3 id="volatile如何解决指令重排序"><a href="#volatile如何解决指令重排序" class="headerlink" title="volatile如何解决指令重排序"></a>volatile如何解决指令重排序</h3><p>1: volatile i</p>
<p>2: ACC_VOLATILE</p>
<p>3: JVM的内存屏障</p>
<p>​    屏障两边的指令不可以重排！保障有序！</p>
<p>​    happends-before </p>
<p>​    as - if - serial</p>
<p>4：hotspot实现</p>
<p>bytecodeinterpreter.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line">          <span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">              OrderAccess::fence();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>orderaccess_linux_x86.inline.hpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> OrderAccess::fence() &#123;</span><br><span class="line">  <span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">    <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">    __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%rsp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%esp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>LOCK 用于在多处理器中执行指令时对共享内存的独占使用。<br>它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。</strong><br><strong>另外还提供了有序的指令无法越过这个内存屏障的作用。</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么String的hashCode选择31作为乘子?</title>
    <url>/2020/09/06/java/%E4%B8%BA%E4%BB%80%E4%B9%88String%E7%9A%84hashCode%E9%80%89%E6%8B%A931%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> String hashCode 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上 hashCode 方法核心的计算逻辑只有三行，也就是代码中的 for 循环。我们可以由上面的 for 循环推导出一个计算公式，hashCode 方法注释中已经给出。如下：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span><br></pre></td></tr></table></figure>
<p>这里说明一下，上面的 s 数组即源码中的 val 数组，是 String 内部维护的一个 char 类型数组。这里我来简单推导一下这个公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设 n=3</span><br><span class="line">i=0 -&gt; h = 31 * 0 + val[0]</span><br><span class="line">i=1 -&gt; h = 31 * (31 * 0 + val[0]) + val[1]</span><br><span class="line">i=2 -&gt; h = 31 * (31 * (31 * 0 + val[0]) + val[1]) + val[2]</span><br><span class="line">       h = 31*31*31*0 + 31*31*val[0] + 31*val[1] + val[2]</span><br><span class="line">       h = 31^(n-1)*val[0] + 31^(n-2)*val[1] + val[2]</span><br></pre></td></tr></table></figure>
<p>上面的公式包括公式的推导并不是本文的重点，大家了解了解即可。接下来来说说本文的重点，即选择31的理由。从网上的资料来看，一般有如下两个原因：</p>
<p>第一 31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。另外一些相近的质数，比如37、41、43等等，也都是不错的选择。那么为啥偏偏选中了31呢？请看第二个原因。</p>
<p>第二 31可以被 JVM 优化，<code>31 * i = (i &lt;&lt; 5) - i</code>。</p>
<p>上面两个原因中，第一个需要解释一下，第二个比较简单，就不说了。下面我来解释第一个理由。一般在设计哈希算法时，会选择一个特殊的质数。至于为啥选择质数，我想应该是可以降低哈希算法的冲突率。至于原因，这个就要问数学家了，我几乎可以忽略的数学水平解释不了这个原因。上面说到，31是一个不大不小的质数，是优选乘子。那为啥同是质数的2和101（或者更大的质数）就不是优选乘子呢，分析如下。</p>
<p>这里先分析质数2。首先，假设<code>n = 6</code>，然后把质数2和 n 带入上面的计算公式。并仅计算公式中次数最高的那一项，结果是<code>2^5 = 32</code>，是不是很小。所以这里可以断定，当字符串长度不是很长时，用质数2做为乘子算出的哈希值，数值不会很大。也就是说，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升。</p>
<p>上面说了，质数2做为乘子会导致哈希值分布在一个较小区间内，那么如果用一个较大的大质数101会产生什么样的结果呢？根据上面的分析，我想大家应该可以猜出结果了。就是不用再担心哈希值会分布在一个小的区间内了，因为<code>101^5 = 10,510,100,501</code>。但是要注意的是，这个计算结果太大了。如果用 int 类型表示哈希值，结果会溢出，最终导致数值信息丢失。尽管数值信息丢失并不一定会导致冲突率上升，但是我们暂且先认为质数101（或者更大的质数）也不是很好的选择。最后，我们再来看看质数31的计算结果：<code>31^5 = 28629151</code>，结果值相对于<code>32</code>和<code>10,510,100,501</code>来说。是不是很nice，不大不小。</p>
<p>上面用了比较简陋的数学手段证明了数字31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。</p>
<p>接下来我会用详细的实验来验证上面的结论，不过在验证前，我们先看看 Stack Overflow 上关于这个问题的讨论，Why does Java’s hashCode() in String use 31 as a multiplier? （地址：<a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier）。其中排名第一的答案引用了《Effective" target="_blank" rel="noopener">https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier）。其中排名第一的答案引用了《Effective</a> Java》中的一段话，这里也引用一下：</p>
<blockquote>
<p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: <code>31 * i == (i &lt;&lt; 5) - i</code>. Modern VMs do this sort of optimization automatically.</p>
</blockquote>
<p>简单翻译一下：</p>
<blockquote>
<p>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：<code>31 * i == (i &lt;&lt; 5) - i</code>，现代的 Java 虚拟机可以自动的完成这个优化。</p>
</blockquote>
<p>排名第二的答案设这样说的：</p>
<blockquote>
<p>As Goodrich and Tamassia point out, If you take over 50,000 English words (formed as the union of the word lists provided in two variants of Unix), using the constants 31, 33, 37, 39, and 41 will produce less than 7 collisions in each case. Knowing this, it should come as no surprise that many Java implementations choose one of these constants.</p>
</blockquote>
<p>这段话也翻译一下：</p>
<blockquote>
<p>正如 Goodrich 和 Tamassia 指出的那样，如果你对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个，所以在上面几个常数中，常数 31 被 Java 实现所选用也就不足为奇了。</p>
</blockquote>
<p>上面的两个答案完美的解释了 Java 源码中选用数字 31 的原因。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>经过上面的分析与实践，我想大家应该明白了 String hashCode 方法中选择使用数字31作为乘子的原因了。本文本质是一篇简单的科普文而已，并没有银弹。如果大家读完后觉得又涨知识了，那这篇文章的目的就达到了。最后，本篇文章的配图画的还是很辛苦的，所以如果大家觉得文章不错，不妨就给个赞吧，就当是对我的鼓励了。</p>
<p>另外，如果文章中有不妥或者错误的地方，也欢迎指出来。</p>
<p>来源：<a href="http://blog.ouyangsihai.cn/" target="_blank" rel="noopener">http://blog.ouyangsihai.cn/</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Spring中的参数校验的一点思考</title>
    <url>/2020/05/07/java/%E5%85%B3%E4%BA%8ESpring%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。</p>
<p>最近工作中很多地方需要对参数做一些校验，刚开始的时候除了Controller层接受的对象我是直接通过一些 Spring 提供好的注解来实现校验比如<code>@Valid</code>、<code>@NotNull</code> 等等，在一些需要对参数做校验的其他地方我都是通过手动编程if else判断的方式来实现。后面重构代码发现有更好的方式来满足我的需求，然后花了半天时间对这部分内容做了一个简单的总结，希望可以对不了解这部分知识的朋友有帮助。</p>
<p>下面我会通过实例程序演示如何在 Java 程序中尤其是 Spring 程序中优雅地的进行参数验证。</p>
<a id="more"></a>
<h2 id="基础知识和依赖"><a href="#基础知识和依赖" class="headerlink" title="基础知识和依赖"></a>基础知识和依赖</h2><h3 id="相关依赖"><a href="#相关依赖" class="headerlink" title="相关依赖"></a>相关依赖</h3><p>如果开发普通 Java 程序的的话，你需要可能需要像下面这样依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            </span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.9.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>             </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>             </span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>             </span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.web<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            </span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 Spring Boot 程序的话只需要<code>spring-boot-starter-web</code> 就够了，它的子依赖包含了我们所需要的东西。除了这个依赖，下面的演示还用到了 lombok ，所以不要忘记添加上相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>        </span><br><span class="line">   	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            </span><br><span class="line">   		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">   		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        </span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>        </span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>           </span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            </span><br><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>下面这个是示例用到的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span><span class="meta">@AllArgsConstructor</span><span class="meta">@NoArgsConstructorpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"classId 不能为空"</span>)    </span><br><span class="line">    <span class="keyword">private</span> String classId;</span><br><span class="line">    <span class="meta">@Size</span>(max = <span class="number">33</span>)    </span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"name 不能为空"</span>)    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Pattern</span>(regexp = <span class="string">"((^Man$|^Woman$|^UGM$))"</span>, message = <span class="string">"sex 值不在可选范围"</span>)    </span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"sex 不能为空"</span>)    </span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"email 格式不正确"</span>)    </span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"email 不能为空"</span>)    </span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正则表达式说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; - ^string : 匹配以 string 开头的字符串</span><br><span class="line">&gt; - string$ ：匹配以 string 结尾的字符串</span><br><span class="line">&gt; - ^string$ ：精确匹配 string 字符串</span><br><span class="line">&gt; - ((^Man$|^Woman$|^UGM$)) : 值只能在 Man,Woman,UGM 这三个值中选择</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面这部分校验注解说明内容参考自：<a href="https://www.cnkirito.moe/spring-validation/[1]" target="_blank" rel="noopener">https://www.cnkirito.moe/spring-validation/[1]</a> ，感谢@徐靖峰[2]。</p>
<p><strong>JSR提供的校验注解</strong>:</p>
<p>•<code>@Null</code> 被注释的元素必须为 null•<code>@NotNull</code> 被注释的元素必须不为 null•<code>@AssertTrue</code> 被注释的元素必须为 true •<code>@AssertFalse</code> 被注释的元素必须为 false•<code>@Min(value)</code> 被注释的元素必须是一个数字，其值必须大于等于指定的最小值•<code>@Max(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值•<code>@DecimalMin(value)</code> 被注释的元素必须是一个数字，其值必须大于等于指定的最小值•<code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值•<code>@Size(max=, min=)</code> 被注释的元素的大小必须在指定的范围内•<code>@Digits (integer, fraction)</code> 被注释的元素必须是一个数字，其值必须在可接受的范围内•<code>@Past</code> 被注释的元素必须是一个过去的日期•<code>@Future</code> 被注释的元素必须是一个将来的日期•<code>@Pattern(regex=,flag=)</code> 被注释的元素必须符合指定的正则表达式</p>
<p><strong>Hibernate Validator提供的校验注解</strong>：</p>
<p>•<code>@NotBlank(message =)</code> 验证字符串非null，且长度必须大于0•<code>@Email</code> 被注释的元素必须是电子邮箱地址•<code>@Length(min=,max=)</code> 被注释的字符串的大小必须在指定的范围内•<code>@NotEmpty</code> 被注释的字符串的必须非空 •<code>@Range(min=,max=,message=)</code> 被注释的元素必须在合适的范围内</p>
<h2 id="验证Controller的输入"><a href="#验证Controller的输入" class="headerlink" title="验证Controller的输入"></a>验证Controller的输入</h2><h3 id="验证请求体-RequestBody"><a href="#验证请求体-RequestBody" class="headerlink" title="验证请求体(RequestBody)"></a>验证请求体(RequestBody)</h3><p><strong>Controller：</strong></p>
<p>我们在需要验证的参数上加上了<code>@Valid</code>注解，如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。默认情况下，Spring会将此异常转换为HTTP Status 400（错误请求）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="meta">@RequestMapping</span>(<span class="string">"/api"</span>)<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/person"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@RequestBody @Valid Person person)</span> </span>&#123;        </span><br><span class="line">    	<span class="keyword">return</span> ResponseEntity.ok().body(person);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ExceptionHandler：</strong></p>
<p>自定义异常处理器可以帮助我们捕获异常，并进行一些简单的处理。如果对于下面的处理异常的代码不太理解的话，可以查看这篇文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485568&amp;idx=2&amp;sn=c5ba880fd0c5d82e39531fa42cb036ac&amp;chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&amp;token=1924773784&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《SpringBoot 处理异常的几种常见姿势》</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>(assignableTypes = &#123;PersonController.class&#125;)<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;   <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException.class)    </span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, String&gt;&gt; handleValidationExceptions(            </span><br><span class="line">    MethodArgumentNotValidException ex) &#123;        </span><br><span class="line">    	Map&lt;String, String&gt; errors = <span class="keyword">new</span> HashMap&lt;&gt;();        </span><br><span class="line">    	ex.getBindingResult().getAllErrors().forEach((error) -&gt; &#123;            </span><br><span class="line">            String fieldName = ((FieldError) error).getField();            </span><br><span class="line">            String errorMessage = error.getDefaultMessage();            </span><br><span class="line">            errors.put(fieldName, errorMessage);        </span><br><span class="line">       &#125;);        </span><br><span class="line">    	<span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);    </span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过测试验证：</strong></p>
<p>下面我通过 MockMvc 模拟请求 Controller 的方式来验证是否生效，当然你也可以通过 Postman 这种工具来验证。</p>
<p>我们试一下所有参数输入正确的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span><span class="meta">@AutoConfigureMockMvcpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonControllerTest</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Test</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_get_person_correctly</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        </span><br><span class="line">    	Person person = <span class="keyword">new</span> Person();        </span><br><span class="line">    	person.setName(<span class="string">"SnailClimb"</span>);        </span><br><span class="line">    	person.setSex(<span class="string">"Man"</span>);        </span><br><span class="line">    	person.setClassId(<span class="string">"82938390"</span>);        </span><br><span class="line">    	person.setEmail(<span class="string">"Snailclimb@qq.com"</span>);</span><br><span class="line">      mockMvc.perform(post(<span class="string">"/api/person"</span>)</span><br><span class="line">           .contentType(MediaType.APPLICATION_JSON_UTF8)                </span><br><span class="line">           .content(objectMapper.writeValueAsString(person)))</span><br><span class="line">           .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"name"</span>).value(<span class="string">"SnailClimb"</span>))</span><br><span class="line">           .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"classId"</span>).value(<span class="string">"82938390"</span>))</span><br><span class="line">           .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"sex"</span>).value(<span class="string">"Man"</span>))</span><br><span class="line">           .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"email"</span>).value(<span class="string">"Snailclimb@qq.com"</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证出现参数不合法的情况抛出异常并且可以正确被捕获。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_check_person_value</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;        </span><br><span class="line">    Person person = <span class="keyword">new</span> Person();        </span><br><span class="line">    person.setSex(<span class="string">"Man22"</span>);        </span><br><span class="line">    person.setClassId(<span class="string">"82938390"</span>);        </span><br><span class="line">    person.setEmail(<span class="string">"SnailClimb"</span>);</span><br><span class="line">    mockMvc.perform(post(<span class="string">"/api/person"</span>)                </span><br><span class="line">         .contentType(MediaType.APPLICATION_JSON_UTF8)                </span><br><span class="line">         .content(objectMapper.writeValueAsString(person)))</span><br><span class="line">         .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"sex"</span>).value(<span class="string">"sex 值不在可选范围"</span>))</span><br><span class="line">         .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"name"</span>).value(<span class="string">"name 不能为空"</span>))</span><br><span class="line">         .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"email"</span>).value(<span class="string">"email 格式不正确"</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Postman 验证结果如下：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/2020_05_07_20_31_18_1.jpg" alt="null" title="" class="">
                <p>null</p>
            </figure>
<h3 id="验证请求参数-Path-Variables-和-Request-Parameters"><a href="#验证请求参数-Path-Variables-和-Request-Parameters" class="headerlink" title="验证请求参数(Path Variables 和 Request Parameters)"></a>验证请求参数(Path Variables 和 Request Parameters)</h3><p><strong>Controller：</strong></p>
<p><strong>一定一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="meta">@RequestMapping</span>(<span class="string">"/api"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/person/&#123;id&#125;"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title">getPersonByID</span><span class="params">(@Valid @PathVariable(<span class="string">"id"</span>)</span> @<span class="title">Max</span><span class="params">(value = <span class="number">5</span>,message = <span class="string">"超过 id 的范围了"</span>)</span> Integer id) </span>&#123;        <span class="keyword">return</span> ResponseEntity.ok().body(id);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/person"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">getPersonByName</span><span class="params">(@Valid @RequestParam(<span class="string">"name"</span>)</span> @<span class="title">Size</span><span class="params">(max = <span class="number">6</span>,message = <span class="string">"超过 name 的范围了"</span>)</span> String name)</span>&#123;         <span class="keyword">return</span> ResponseEntity.ok().body(name);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ExceptionHandler：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(ConstraintViolationException.class)    </span><br><span class="line"><span class="function">ResponseEntity&lt;String&gt; <span class="title">handleConstraintViolationException</span><span class="params">(ConstraintViolationException e)</span> </span>&#123;        </span><br><span class="line">	<span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过测试验证：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_check_param_value</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      mockMvc.perform(get(<span class="string">"/api/person/6"</span>)</span><br><span class="line">          .contentType(MediaType.APPLICATION_JSON_UTF8))                </span><br><span class="line">          .andExpect(status().isBadRequest())                </span><br><span class="line">          .andExpect(content().string(<span class="string">"getPersonByID.id: 超过 id 的范围了"</span>));    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_check_param_value2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    mockMvc.perform(put(<span class="string">"/api/person"</span>)                </span><br><span class="line">    .param(<span class="string">"name"</span>,<span class="string">"snailclimbsnailclimb"</span>)                </span><br><span class="line">    .contentType(MediaType.APPLICATION_JSON_UTF8))                </span><br><span class="line">    .andExpect(status().isBadRequest())                </span><br><span class="line">    .andExpect(content().string(<span class="string">"getPersonByName.name: 超过 name 的范围了"</span>));    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="验证-Service-中的方法"><a href="#验证-Service-中的方法" class="headerlink" title="验证 Service 中的方法"></a>验证 Service 中的方法</h2><p>我们还可以验证任何Spring组件的输入，而不是验证控制器级别的输入，我们可以使用<code>@Validated</code>和<code>@Valid</code>注释的组合来实现这一需求。</p>
<p><strong>一定一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validatePerson</span><span class="params">(@Valid Person person)</span></span>&#123;        <span class="comment">// do something    &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>通过测试验证：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceTest</span> </span>&#123;   </span><br><span class="line">	<span class="meta">@Autowired</span>    </span><br><span class="line">	<span class="keyword">private</span> PersonService service;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span>(expected = ConstraintViolationException.class)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_throw_exception_when_person_is_not_valid</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    	Person person = <span class="keyword">new</span> Person();        </span><br><span class="line">    	person.setSex(<span class="string">"Man22"</span>);        </span><br><span class="line">    	person.setClassId(<span class="string">"82938390"</span>);        </span><br><span class="line">    	person.setEmail(<span class="string">"SnailClimb"</span>);        </span><br><span class="line">    	service.validatePerson(person);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Validator-编程方式手动进行参数验证"><a href="#Validator-编程方式手动进行参数验证" class="headerlink" title="Validator 编程方式手动进行参数验证"></a>Validator 编程方式手动进行参数验证</h2><p>某些场景下可能会需要我们手动校验并获得校验结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test    public void check_person_manually() &#123;        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();        Validator validator = factory.getValidator();        Person person = new Person();        person.setSex(&quot;Man22&quot;);        person.setClassId(&quot;82938390&quot;);        person.setEmail(&quot;SnailClimb&quot;);        Set&lt;ConstraintViolation&lt;Person&gt;&gt; violations = validator.validate(person);        //output:        //email 格式不正确        //name 不能为空        //sex 值不在可选范围        for (ConstraintViolation&lt;Person&gt; constraintViolation : violations) &#123;            System.out.println(constraintViolation.getMessage());        &#125;    &#125;</span><br></pre></td></tr></table></figure>
<p>上面我们是通过 <code>Validator</code> 工厂类获得的 <code>Validator</code> 示例，当然你也可以通过 <code>@Autowired</code> 直接注入的方式。但是在非 Spring Component 类中使用这种方式的话，只能通过工厂类来获得 <code>Validator</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">Validator validate</span><br></pre></td></tr></table></figure>
<h2 id="自定以-Validator"><a href="#自定以-Validator" class="headerlink" title="自定以 Validator"></a>自定以 Validator</h2><p>如果自带的校验注解无法满足你的需求的话，你还可以自定义实现注解。比如我们的Person类多了一个 region 字段，region 字段只能是<code>China</code>、<code>China-Taiwan</code>、<code>China-HongKong</code>这三个中的一个。</p>
<p>第一步你需要创建一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;FIELD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = RegionValidator.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Region &#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "Region 值不在可选范围内"</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步你需要实现 <code>ConstraintValidator</code>接口，并重写<code>isValid</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegionValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">Region</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;        </span><br><span class="line">    	HashSet&lt;Object&gt; regions = <span class="keyword">new</span> HashSet&lt;&gt;();        </span><br><span class="line">    	regions.add(<span class="string">"China"</span>);        </span><br><span class="line">    	regions.add(<span class="string">"China-Taiwan"</span>);        </span><br><span class="line">    	regions.add(<span class="string">"China-HongKong"</span>);        </span><br><span class="line">    	<span class="keyword">return</span> regions.contains(value);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你就可以使用这个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Region</span>    </span><br><span class="line"><span class="keyword">private</span> String region;</span><br></pre></td></tr></table></figure>
<h2 id="使用验证组"><a href="#使用验证组" class="headerlink" title="使用验证组"></a>使用验证组</h2><p>很多时候我们需要使用到验证组，这样说可能不太清楚，说简单点就是对对象操作的不同方法有不同的验证规则，示例如下。</p>
<p>先创建两个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddPersonGroup</span> </span>&#123;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeletePersonGroup</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以这样去使用验证组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull</span>(groups = DeletePersonGroup.class)</span><br><span class="line"><span class="meta">@Null</span>(groups = AddPersonGroup.class)</span><br><span class="line"><span class="keyword">private</span> String group;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validatePerson</span><span class="params">(@Valid Person person)</span> </span>&#123;        <span class="comment">// do something    &#125;</span></span><br><span class="line">    <span class="meta">@Validated</span>(AddPersonGroup.class)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validatePersonGroupForAdd</span><span class="params">(@Valid Person person)</span> </span>&#123;        <span class="comment">// do something    &#125;</span></span><br><span class="line">    <span class="meta">@Validated</span>(DeletePersonGroup.class)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validatePersonGroupForDelete</span><span class="params">(@Valid Person person)</span> </span>&#123;        <span class="comment">// do something    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过测试验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = ConstraintViolationException.class)    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_check_person_with_groups</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    Person person = <span class="keyword">new</span> Person();        </span><br><span class="line">    person.setSex(<span class="string">"Man22"</span>);        </span><br><span class="line">    person.setClassId(<span class="string">"82938390"</span>);        </span><br><span class="line">    person.setEmail(<span class="string">"SnailClimb"</span>);        </span><br><span class="line">    person.setGroup(<span class="string">"group1"</span>);        </span><br><span class="line">    service.validatePersonGroupForAdd(person);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span>(expected = ConstraintViolationException.class)    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_check_person_with_groups2</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">  Person person = <span class="keyword">new</span> Person();        </span><br><span class="line">  person.setSex(<span class="string">"Man22"</span>);        </span><br><span class="line">  person.setClassId(<span class="string">"82938390"</span>);        </span><br><span class="line">  person.setEmail(<span class="string">"SnailClimb"</span>);        </span><br><span class="line">  service.validatePersonGroupForDelete(person);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用验证组这种方式的时候一定要小心，这是一种反模式，还会造成代码逻辑性变差。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>最简单的 6 种防止数据重复提交的方法！</title>
    <url>/2020/08/02/java/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-6-%E7%A7%8D%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载:<a href="https://mp.weixin.qq.com/s/kOADZRd5hI1H-7_zuXJsAw" target="_blank" rel="noopener">点击查看原文</a></p>
</blockquote>
<h2 id="模拟用户场景"><a href="#模拟用户场景" class="headerlink" title="模拟用户场景"></a>模拟用户场景</h2><p>根据朋友的反馈，大致的场景是这样的，如下图所示：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/微信图片_20200802143342.gif" alt="" title="" class="">
                <p></p>
            </figure>
<a id="more"></a>
<p>简化的模拟代码如下（基于 Spring Boot）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被重复请求的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是磊哥就想到：通过前、后端分别拦截的方式来解决数据重复提交的问题。</p>
<h2 id="前端拦截"><a href="#前端拦截" class="headerlink" title="前端拦截"></a>前端拦截</h2><p>前端拦截是指通过 HTML 页面来拦截重复请求，比如在用户点击完“提交”按钮后，我们可以把按钮设置为不可用或者隐藏状态。</p>
<p>执行效果如下图所示：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/微信图片_20200802143537.gif" alt="" title="" class="">
                <p></p>
            </figure>
<p>前端拦截的实现代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    function subCli()&#123;</span></span><br><span class="line"><span class="undefined">        // 按钮设置为不可用</span></span><br><span class="line"><span class="undefined">        document.getElementById("btn_sub").disabled="disabled";</span></span><br><span class="line"><span class="undefined">        document.getElementById("dv1").innerText = "按钮被点击了~";</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"margin-top: 100px;margin-left: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btn_sub"</span> <span class="attr">type</span>=<span class="string">"button"</span>  <span class="attr">value</span>=<span class="string">" 提 交 "</span>  <span class="attr">onclick</span>=<span class="string">"subCli()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dv1"</span> <span class="attr">style</span>=<span class="string">"margin-top: 80px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但前端拦截有一个致命的问题，如果是懂行的程序员或非法用户可以直接绕过前端页面，通过模拟请求来重复提交请求，比如充值了 100 元，重复提交了 10 次变成了 1000 元（瞬间发现了一个致富的好办法）。</p>
<p>所以除了前端拦截一部分正常的误操作之外，后端的拦截也是必不可少。</p>
<h2 id="后端拦截"><a href="#后端拦截" class="headerlink" title="后端拦截"></a>后端拦截</h2><p>后端拦截的实现思路是在方法执行之前，先判断此业务是否已经执行过，如果执行过则不再执行，否则就正常执行。</p>
<p>我们将请求的业务 ID 存储在内存中，并且通过添加互斥锁来保证多线程下的程序执行安全，大体实现思路如下图所示：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/image-20200802143638247.png" alt="" title="" class="">
                <p></p>
            </figure>
<p>然而，将数据存储在内存中，最简单的方法就是使用 <code>HashMap</code> 存储，或者是使用 Guava Cache 也是同样的效果，但很显然 <code>HashMap</code> 可以更快的实现功能，所以我们先来实现一个 <code>HashMap</code> 的防重（防止重复）版本。</p>
<h3 id="1-基础版——HashMap"><a href="#1-基础版——HashMap" class="headerlink" title="1.基础版——HashMap"></a>1.基础版——HashMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通 Map 版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存 ID 集合</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; reqCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断(忽略)...</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="comment">// 重复请求判断</span></span><br><span class="line">            <span class="keyword">if</span> (reqCache.containsKey(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存储请求 ID</span></span><br><span class="line">            reqCache.put(id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现效果如下图所示：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/微信图片_20200802143707.gif" alt="" title="" class="">
                <p></p>
            </figure>
<p><strong>存在的问题</strong>：此实现方式有一个致命的问题，因为 <code>HashMap</code> 是无限增长的，因此它会占用越来越多的内存，并且随着 <code>HashMap</code> 数量的增加查找的速度也会降低，所以我们需要实现一个可以自动“清除”过期数据的实现方案。</p>
<h3 id="2-优化版——固定大小的数组"><a href="#2-优化版——固定大小的数组" class="headerlink" title="2.优化版——固定大小的数组"></a>2.优化版——固定大小的数组</h3><p>此版本解决了 <code>HashMap</code> 无限增长的问题，它使用数组加下标计数器（reqCacheCounter）的方式，实现了固定数组的循环存储。</p>
<p>当数组存储到最后一位时，将数组的存储下标设置 0，再从头开始存储数据，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] reqCache = <span class="keyword">new</span> String[<span class="number">100</span>]; <span class="comment">// 请求 ID 存储集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer reqCacheCounter = <span class="number">0</span>; <span class="comment">// 请求计数器（指示 ID 存储的位置）</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断(忽略)...</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="comment">// 重复请求判断</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.asList(reqCache).contains(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录请求 ID</span></span><br><span class="line">            <span class="keyword">if</span> (reqCacheCounter &gt;= reqCache.length) reqCacheCounter = <span class="number">0</span>; <span class="comment">// 重置计数器</span></span><br><span class="line">            reqCache[reqCacheCounter] = id; <span class="comment">// 将 ID 保存到缓存</span></span><br><span class="line">            reqCacheCounter++; <span class="comment">// 下标往后移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-扩展版——双重检测锁-DCL"><a href="#3-扩展版——双重检测锁-DCL" class="headerlink" title="3.扩展版——双重检测锁(DCL)"></a>3.扩展版——双重检测锁(DCL)</h3><p>上一种实现方法将判断和添加业务，都放入 <code>synchronized</code> 中进行加锁操作，这样显然性能不是很高，于是我们可以使用单例中著名的 DCL（Double Checked Locking，双重检测锁）来优化代码的执行效率，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] reqCache = <span class="keyword">new</span> String[<span class="number">100</span>]; <span class="comment">// 请求 ID 存储集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer reqCacheCounter = <span class="number">0</span>; <span class="comment">// 请求计数器（指示 ID 存储的位置）</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断(忽略)...</span></span><br><span class="line">        <span class="comment">// 重复请求判断</span></span><br><span class="line">        <span class="keyword">if</span> (Arrays.asList(reqCache).contains(id)) &#123;</span><br><span class="line">            <span class="comment">// 重复请求</span></span><br><span class="line">            System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="comment">// 双重检查锁（DCL,double checked locking）提高程序的执行效率</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.asList(reqCache).contains(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录请求 ID</span></span><br><span class="line">            <span class="keyword">if</span> (reqCacheCounter &gt;= reqCache.length) reqCacheCounter = <span class="number">0</span>; <span class="comment">// 重置计数器</span></span><br><span class="line">            reqCache[reqCacheCounter] = id; <span class="comment">// 将 ID 保存到缓存</span></span><br><span class="line">            reqCacheCounter++; <span class="comment">// 下标往后移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：DCL 适用于重复提交频繁比较高的业务场景，对于相反的业务场景下 DCL 并不适用。</p>
</blockquote>
<h3 id="4-完善版——LRUMap"><a href="#4-完善版——LRUMap" class="headerlink" title="4.完善版——LRUMap"></a>4.完善版——LRUMap</h3><p>上面的代码基本已经实现了重复数据的拦截，但显然不够简洁和优雅，比如下标计数器的声明和业务处理等，但值得庆幸的是 Apache 为我们提供了一个 commons-collections 的框架，里面有一个非常好用的数据结构 <code>LRUMap</code> 可以保存指定数量的固定的数据，并且它会按照 LRU 算法，帮你清除最不常用的数据。</p>
<blockquote>
<p>小贴士：LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的数据淘汰算法，选择最近最久未使用的数据予以淘汰。</p>
</blockquote>
<p>首先，我们先来添加 Apache commons collections 的引用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 集合工具类 apache commons collections --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.map.LRUMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大容量 100 个，根据 LRU 算法淘汰数据的 Map 集合</span></span><br><span class="line">    <span class="keyword">private</span> LRUMap&lt;String, Integer&gt; reqCache = <span class="keyword">new</span> LRUMap&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断(忽略)...</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="comment">// 重复请求判断</span></span><br><span class="line">            <span class="keyword">if</span> (reqCache.containsKey(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存储请求 ID</span></span><br><span class="line">            reqCache.put(id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了 <code>LRUMap</code> 之后，代码显然简洁了很多。</p>
<h3 id="5-最终版——封装"><a href="#5-最终版——封装" class="headerlink" title="5.最终版——封装"></a>5.最终版——封装</h3><p>以上都是方法级别的实现方案，然而在实际的业务中，我们可能有很多的方法都需要防重，那么接下来我们就来封装一个公共的方法，以供所有类使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.map.LRUMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 幂等性判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdempotentUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 LRU(Least Recently Used，最近最少使用)算法淘汰数据的 Map 集合，最大容量 100 个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LRUMap&lt;String, Integer&gt; reqCache = <span class="keyword">new</span> LRUMap&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 幂等性判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(String id, Object lockClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockClass) &#123;</span><br><span class="line">            <span class="comment">// 重复请求判断</span></span><br><span class="line">            <span class="keyword">if</span> (reqCache.containsKey(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非重复请求，存储请求 ID</span></span><br><span class="line">            reqCache.put(id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.idempote.util.IdempotentUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController4</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断(忽略)...</span></span><br><span class="line">        <span class="comment">// -------------- 幂等性调用（开始） --------------</span></span><br><span class="line">        <span class="keyword">if</span> (!IdempotentUtils.judge(id, <span class="keyword">this</span>.getClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -------------- 幂等性调用（结束） --------------</span></span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：一般情况下代码写到这里就结束了，但想要更简洁也是可以实现的，你可以通过自定义注解，将业务代码写到注解中，需要调用的方法只需要写一行注解就可以防止数据重复提交了，老铁们可以自行尝试一下（需要磊哥撸一篇的，评论区留言 666）。</p>
</blockquote>
<h2 id="扩展知识——LRUMap-实现原理分析"><a href="#扩展知识——LRUMap-实现原理分析" class="headerlink" title="扩展知识——LRUMap 实现原理分析"></a>扩展知识——LRUMap 实现原理分析</h2><p>既然 <code>LRUMap</code> 如此强大，我们就来看看它是如何实现的。</p>
<p><code>LRUMap</code> 的本质是持有头结点的环回双链表结构，它的存储结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractLinkedMap.LinkEntry entry;</span><br></pre></td></tr></table></figure>
<p>当调用查询方法时，会将使用的元素放在双链表 header 的前一个位置，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key, <span class="keyword">boolean</span> updateToMRU)</span> </span>&#123;</span><br><span class="line">    LinkEntry&lt;K, V&gt; entry = <span class="keyword">this</span>.getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (updateToMRU) &#123;</span><br><span class="line">            <span class="keyword">this</span>.moveToMRU(entry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">moveToMRU</span><span class="params">(LinkEntry&lt;K, V&gt; entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.after != <span class="keyword">this</span>.header) &#123;</span><br><span class="line">        ++<span class="keyword">this</span>.modCount;</span><br><span class="line">        <span class="keyword">if</span> (entry.before == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Entry.before is null. This should not occur if your keys are immutable, and you have used synchronization properly."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entry.before.after = entry.after;</span><br><span class="line">        entry.after.before = entry.before;</span><br><span class="line">        entry.after = <span class="keyword">this</span>.header;</span><br><span class="line">        entry.before = <span class="keyword">this</span>.header.before;</span><br><span class="line">        <span class="keyword">this</span>.header.before.after = entry;</span><br><span class="line">        <span class="keyword">this</span>.header.before = entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry == <span class="keyword">this</span>.header) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can't move header to MRU This should not occur if your keys are immutable, and you have used synchronization properly."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果新增元素时，容量满了就会移除 header 的后一个元素，添加源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addMapping</span><span class="params">(<span class="keyword">int</span> hashIndex, <span class="keyword">int</span> hashCode, K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断容器是否已满 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">        LinkEntry&lt;K, V&gt; reuse = <span class="keyword">this</span>.header.after;</span><br><span class="line">        <span class="keyword">boolean</span> removeLRUEntry = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.scanUntilRemovable) &#123;</span><br><span class="line">            removeLRUEntry = <span class="keyword">this</span>.removeLRU(reuse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(reuse != <span class="keyword">this</span>.header &amp;&amp; reuse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.removeLRU(reuse)) &#123;</span><br><span class="line">                    removeLRUEntry = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                reuse = reuse.after;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reuse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Entry.after=null, header.after="</span> + <span class="keyword">this</span>.header.after + <span class="string">" header.before="</span> + <span class="keyword">this</span>.header.before + <span class="string">" key="</span> + key + <span class="string">" value="</span> + value + <span class="string">" size="</span> + <span class="keyword">this</span>.size + <span class="string">" maxSize="</span> + <span class="keyword">this</span>.maxSize + <span class="string">" This should not occur if your keys are immutable, and you have used synchronization properly."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (removeLRUEntry) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reuse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"reuse=null, header.after="</span> + <span class="keyword">this</span>.header.after + <span class="string">" header.before="</span> + <span class="keyword">this</span>.header.before + <span class="string">" key="</span> + key + <span class="string">" value="</span> + value + <span class="string">" size="</span> + <span class="keyword">this</span>.size + <span class="string">" maxSize="</span> + <span class="keyword">this</span>.maxSize + <span class="string">" This should not occur if your keys are immutable, and you have used synchronization properly."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.reuseMapping(reuse, hashIndex, hashCode, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.addMapping(hashIndex, hashCode, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.addMapping(hashIndex, hashCode, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断容量的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size &gt;= maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容量未满就直接添加数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>.addMapping(hashIndex, hashCode, key, value);</span><br></pre></td></tr></table></figure>
<p>如果容量满了，就调用 <code>reuseMapping</code> 方法使用 LRU 算法对数据进行清除。</p>
<p>综合来说：<strong><code>LRUMap</code> 的本质是持有头结点的环回双链表结构，当使用元素时，就将该元素放在双链表 <code>header</code> 的前一个位置，在新增元素时，如果容量满了就会移除 <code>header</code>的后一个元素</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲了防止数据重复提交的 6 种方法，首先是前端的拦截，通过隐藏和设置按钮的不可用来屏蔽正常操作下的重复提交。但为了避免非正常渠道的重复提交，我们又实现了 5 个版本的后端拦截：HashMap 版、固定数组版、双重检测锁的数组版、LRUMap 版和 LRUMap 的封装版。</p>
<h4 id="参考-amp-鸣谢"><a href="#参考-amp-鸣谢" class="headerlink" title="参考 &amp; 鸣谢"></a>参考 &amp; 鸣谢</h4><p><a href="https://blog.csdn.net/fenglllle/article/details/82659576" target="_blank" rel="noopener">https://blog.csdn.net/fenglllle/article/details/82659576</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点：35 个 Java 代码优化魔鬼细节</title>
    <url>/2021/01/24/java/%E7%9B%98%E7%82%B9%EF%BC%9A35-%E4%B8%AA-Java-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E9%AD%94%E9%AC%BC%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>前言</strong></p>
<p>代码 优化 ，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。</p>
<p>代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。</p>
<p><strong>代码优化的目标是：</strong></p>
<p>减小代码的体积</p>
<p>提高代码运行的效率</p>
<p>代码优化细节</p>
<a id="more"></a>
<p><strong>1、尽量指定类、方法的final修饰符</strong></p>
<p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50% 。</p>
<p><strong>2、尽量重用对象</strong></p>
<p>特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p>
<p><strong>3、尽可能使用局部变量</strong></p>
<p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p>
<p><strong>4、及时关闭流</strong></p>
<p>Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。如果条件允许，即JDK7以上，强烈建议使用try-with-resources。</p>
<p><strong>5、尽量减少对变量的重复计算</strong></p>
<p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152604.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>建议替换为：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152633.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>这样，在list.size很大的时候，就减少了很多的消耗</p>
<p>6、尽量采用懒加载的策略，即在需要的时候才创建*</p>
<p>例如：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152643.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>建议替换为：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152651.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p><strong>7、慎用异常</strong></p>
<p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace的本地同步方法，fillInStackTrace方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p>
<p><strong>8、不要在循环中使用try…catch…，应该把其放在最外层</strong></p>
<p>除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了。</p>
<p><strong>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</strong></p>
<p>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：</p>
<p>（1）StringBuilder // 默认分配16个字符的空间</p>
<p>（2）StringBuilder(int size) // 默认分配size个字符的空间</p>
<p>（3）StringBuilder(String str) // 默认分配16个字符+str.length个字符空间</p>
<p>可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p>
<p>（1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间；</p>
<p>（2）把原来的4096个字符拷贝到新的的字符数组中去。</p>
<p>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</p>
<p><strong>10、当复制大量数据时，使用System.arraycopy命令</strong></p>
<p><strong>11、乘法和除法使用移位操作</strong></p>
<p>例如：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152707.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152724.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p>
<p><strong>12、循环内不要不断创建对象引用</strong></p>
<p>例如：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152820.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152832.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>这样的话，内存中只有一份Object对象引用，每次new Object的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p>
<p><strong>13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</strong></p>
<p><strong>14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</strong></p>
<p><strong>15、不要将数组声明为public static final</strong></p>
<p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变。</p>
<p><strong>16、尽量在合适的场合使用单例</strong></p>
<p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p>
<p>（1）控制资源的使用，通过线程同步来控制资源的并发访问</p>
<p>（2）控制实例的产生，以达到节约资源的目的</p>
<p>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p>
<p><strong>17、尽量避免随意使用静态变量</strong></p>
<p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152842.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止。</p>
<p><strong>18、及时清除不再需要的Session</strong></p>
<p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate方法清除会话。</p>
<p><strong>19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</strong></p>
<p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152858.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p>
<p><strong>20、使用同步代码块替代同步方法</strong></p>
<p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p>
<p><strong>21、将常量声明为static final，并以大写命名</strong></p>
<p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量。</p>
<p><strong>22、不要创建一些不使用的对象，不要导入一些不使用的类</strong></p>
<p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p>
<p><strong>23、程序运行过程中避免使用反射</strong></p>
<p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p>
<p><strong>24、使用数据库连接池和线程池</strong></p>
<p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程。</p>
<p><strong>25、使用带缓冲的输入输出流进行IO操作</strong></p>
<p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率。</p>
<p><strong>26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了。</strong></p>
<p><strong>27、不要让public方法中有太多的形参</strong></p>
<p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p>
<p>1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</p>
<p>2、参数太多势必导致方法调用的出错概率增加</p>
<p>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参。</p>
<p><strong>28、字符串变量和字符串常量equals的时候将字符串常量写在前面</strong></p>
<p>这是一个比较常见的小技巧了，如果有以下代码：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152911.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>建议修改为：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152920.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>这么做主要是可以避免空指针异常。</p>
<p><strong>29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者</strong></p>
<p>平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。</p>
<p>在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152947.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>C/C++判断”i==1″不成立，所以以0表示，即false。但是如果：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153000.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153009.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p>
<p>但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p>
<p><strong>30、不要对数组使用toString方法</strong></p>
<p>看一下对数组使用toString打印出来的是什么：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153019.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>结果是：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153031.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString没有意义，但是对集合toString是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString方法。</p>
<p><strong>31、不要对超出范围的基本数据类型做向下强制转型</strong></p>
<p>这绝不会得到想要的结果：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153040.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>我们可能期望得到其中的某几位，但是结果却是：</p>
<p>1942892530</p>
<p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p>
<p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p>
<p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p>
<p>0111 0011 1100 1110 0010 1111 1111 0010</p>
<p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p>
<p>1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f = 3.5f”</p>
<p>2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int</p>
<p><strong>32、公用的集合类中不使用的数据一定要及时remove掉</strong></p>
<p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p>
<p><strong>33、把一个基本数据类型转为字符串，基本数据类型.toString是最快的方式、String.valueOf次之、数据+””最慢</strong></p>
<p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153049.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>运行结果为：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153059.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString方法。至于为什么，很简单：</p>
<p>1、String.valueOf方法底层调用了Integer.toString方法，但是会在调用前做空判断</p>
<p>2、Integer.toString方法就不说了，直接调用了</p>
<p>3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString方法获取字符串</p>
<p>三者对比下来，明显是2最快、1次之、3最慢。</p>
<p><strong>34、使用最有效率的方式去遍历Map</strong></p>
<p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153110.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>如果你只是想遍历一下这个Map的key值，那用”Set keySet = hm.keySet;”会比较合适一些</p>
<p>35、对资源的close建议分开操作</p>
<p>意思是，比如我有这么一段代码：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153120.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>建议修改为：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153128.jpg" alt="图片" title="" class="">
                <p>图片</p>
            </figure>
<p>虽然有些麻烦，却能避免资源泄露。我想，如果没有修改过的代码，万一XXX.close抛异常了，那么就进入了cath块中了，YYY.close不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为上面的写法之后，就保证了无论如何XXX和YYY都会被close掉。如果JDK7以上，强烈建议使用try-with-resources。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>跟上 Java 8 : 日期和时间实用技巧</title>
    <url>/2020/07/07/java/%E8%B7%9F%E4%B8%8A-Java-8-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>来源：王爵nice，</p>
<p>biezhi.me/2017/07/20/keep-up-with-java8-datetime.html</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651477193&amp;idx=3&amp;sn=db1c998f961b9d780c7d138f1dfc0ba4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">如有好文章投稿，请点击 → 这里了解详情</a></p>
</blockquote>
<p>当你开始使用Java操作日期和时间的时候，会有一些棘手。你也许会通过System.currentTimeMillis() 来返回1970年1月1日到今天的毫秒数。或者使用Date类来操作日期；当遇到加减月份、天数的时候 你又需要用到Calendar类；当需要格式化日期的时候需要使用java.text.DateFormat类。 总而言之在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库，比如: joda-time。</p>
<p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1594112956906.webp" alt="java8-clock"></p>
<a id="more"></a>
<h1 id="现有API存在的问题"><a href="#现有API存在的问题" class="headerlink" title="现有API存在的问题"></a><strong>现有API存在的问题</strong></h1><ul>
<li>线程安全: Date和Calendar不是线程安全的，你需要编写额外的代码处理线程安全问题</li>
<li>API设计和易用性: 由于Date和Calendar的设计不当你无法完成日常的日期操作</li>
<li>ZonedDate和Time: 你必须编写额外的逻辑处理时区和那些旧的逻辑</li>
</ul>
<p>好在JSR 310规范中为Java8添加了新的API， 在java.time包中，新的API纠正了过去的缺陷，</p>
<h1 id="新的日期API"><a href="#新的日期API" class="headerlink" title="新的日期API"></a><strong>新的日期API</strong></h1><ul>
<li>ZoneId: 时区ID，用来确定Instant和LocalDateTime互相转换的规则</li>
<li>Instant: 用来表示时间线上的一个点</li>
<li>LocalDate: 表示没有时区的日期, LocalDate是不可变并且线程安全的</li>
<li>LocalTime: 表示没有时区的时间, LocalTime是不可变并且线程安全的</li>
<li>LocalDateTime: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的</li>
<li>Clock: 用于访问当前时刻、日期、时间，用到时区</li>
<li>Duration: 用秒和纳秒表示时间的数量</li>
</ul>
<p>最常用的就是LocalDate、LocalTime、LocalDateTime了，从它们的名字就可以看出是操作日期 和时间的。这些类是主要用于当时区不需要显式地指定的上下文。在本章节中我们将讨论最常用的api。</p>
<h2 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a><strong>LocalDate</strong></h2><p>LocalDate代表一个IOS格式(yyyy-MM-dd)的日期，可以存储 生日、纪念日等日期。 获取当前的日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"localDate: "</span> + localDate);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>localDate: 2017-07-20</p>
</blockquote>
<p>LocalDate可以指定特定的日期，调用of或parse方法返回该实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate.of(<span class="number">2017</span>, <span class="number">07</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">LocalDate.parse(<span class="string">"2017-07-20"</span>);</span><br></pre></td></tr></table></figure>
<p>当然它还有一些其他方法，我们一起来看看：</p>
<p>为今天添加一天，也就是获取明天</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate tomorrow = LocalDate.now().plusDays(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>从今天减去一个月</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate prevMonth = LocalDate.now().minus(<span class="number">1</span>, ChronoUnit.MONTHS);</span><br></pre></td></tr></table></figure>
<p>下面写两个例子，分别解析日期 2017-07-20，获取每周中的星期和每月中的日：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DayOfWeek thursday = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfWeek();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"周四: "</span> + thursday);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> twenty = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfMonth();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"twenty: "</span> + twenty);</span><br></pre></td></tr></table></figure>
<p>试试今年是不是闰年:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> leapYear = LocalDate.now().isLeapYear();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"是否闰年: "</span> + leapYear);</span><br></pre></td></tr></table></figure>
<p>判断是否在日期之前或之后:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> notBefore = LocalDate.parse(<span class="string">"2017-07-20"</span>).isBefore(LocalDate.parse(<span class="string">"2017-07-22"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"notBefore: "</span> + notBefore);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isAfter = LocalDate.parse(<span class="string">"2017-07-20"</span>).isAfter(LocalDate.parse(<span class="string">"2017-07-22"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"isAfter: "</span> + isAfter);</span><br></pre></td></tr></table></figure>
<p>获取这个月的第一天:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate firstDayOfMonth = LocalDate.parse(<span class="string">"2017-07-20"</span>).with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"这个月的第一天: "</span> + firstDayOfMonth);</span><br><span class="line"></span><br><span class="line">firstDayOfMonth = firstDayOfMonth.withDayOfMonth(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"这个月的第一天: "</span> + firstDayOfMonth);</span><br></pre></td></tr></table></figure>
<p>判断今天是否是我的生日，例如我的生日是 2009-07-20</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate birthday = LocalDate.of(<span class="number">2009</span>, <span class="number">07</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</span><br><span class="line"></span><br><span class="line">MonthDay today = MonthDay.from(LocalDate.now());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"今天是否是我的生日: "</span> + today.equals(birthdayMd));</span><br></pre></td></tr></table></figure>
<h2 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a><strong>LocalTime</strong></h2><p>LocalTime表示一个时间，而不是日期，下面介绍一下它的使用方法。</p>
<p>获取现在的时间，输出15:01:22.144</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime now = LocalTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"现在的时间: "</span> + now);</span><br></pre></td></tr></table></figure>
<p>将一个字符串时间解析为LocalTime，输出15:02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime nowTime = LocalTime.parse(<span class="string">"15:02"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"时间是: "</span> + nowTime);</span><br></pre></td></tr></table></figure>
<p>使用静态方法of创建一个时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime nowTime = LocalTime.of(<span class="number">15</span>, <span class="number">02</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"时间是: "</span> + nowTime);</span><br></pre></td></tr></table></figure>
<p>使用解析字符串的方式并添加一小时，输出16:02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime nextHour = LocalTime.parse(<span class="string">"15:02"</span>).plus(<span class="number">1</span>, ChronoUnit.HOURS);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"下一个小时: "</span> + nextHour);</span><br></pre></td></tr></table></figure>
<p>获取时间的小时、分钟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hour = LocalTime.parse(<span class="string">"15:02"</span>).getHour();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"小时: "</span> + hour);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minute = LocalTime.parse(<span class="string">"15:02"</span>).getMinute();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"分钟: "</span> + minute);</span><br></pre></td></tr></table></figure>
<p>我们也可以通过之前类似的API检查一个时间是否在另一个时间之前、之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isBefore = LocalTime.parse(<span class="string">"15:02"</span>).isBefore(LocalTime.parse(<span class="string">"16:02"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isAfter = LocalTime.parse(<span class="string">"15:02"</span>).isAfter(LocalTime.parse(<span class="string">"16:02"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"isBefore: "</span> + isBefore);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"isAfter: "</span> + isAfter);</span><br></pre></td></tr></table></figure>
<p>输出 isBefore: true, isAfter: false。</p>
<p>在LocalTime类中也将每天的开始和结束作为常量供我们使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(LocalTime.MAX);</span><br><span class="line"></span><br><span class="line">System.out.println(LocalTime.MIN);</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<blockquote>
<p>23:59:59.999999999</p>
<p>00:00</p>
</blockquote>
<p>LocalTime就这些了，下面我们来了解一下LocalDateTime</p>
<h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a><strong>LocalDateTime</strong></h2><p>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</p>
<p>获取当前的日期和时间:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"现在: "</span> + now);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<blockquote>
<p>现在: 2017-07-20T15:17:19.926</p>
</blockquote>
<p>下面使用静态方法和字符串的方式分别创建LocalDateTime对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime.of(<span class="number">2017</span>, Month.JULY, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime.parse(<span class="string">"2017-07-20T15:18:00"</span>);</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">同时`LocalDateTime`也提供了相关API来对日期和时间进行增减操作:</span><br><span class="line"></span><br><span class="line">\```java</span><br><span class="line"></span><br><span class="line">LocalDateTime tomorrow = now.plusDays(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"明天的这个时间: "</span> + tomorrow);</span><br><span class="line"></span><br><span class="line">LocalDateTime minusTowHour = now.minusHours(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"两小时前: "</span> + minusTowHour);</span><br></pre></td></tr></table></figure>
<p>这个类也提供一系列的get方法来获取特定单位:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Month month = now.getMonth();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"当前月份: "</span> + month);</span><br></pre></td></tr></table></figure>
<h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a><strong>日期格式化</strong></h2><p>在日常开发中我们用到最多的也许就是日期、时间的格式化了，那在Java8种该如何操作呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"默认格式化: "</span> + now);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"自定义格式化: "</span> + now.format(dateTimeFormatter));</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.parse(<span class="string">"2017-07-20 15:27:44"</span>, dateTimeFormatter);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"字符串转LocalDateTime: "</span> + localDateTime);</span><br></pre></td></tr></table></figure>
<p>也可以使用DateTimeFormatter的format方法将日期、时间格式化为字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">String dateString = dateTimeFormatter.format(LocalDate.now());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"日期转字符串: "</span> + dateString);</span><br></pre></td></tr></table></figure>
<h2 id="日期周期"><a href="#日期周期" class="headerlink" title="日期周期"></a><strong>日期周期</strong></h2><p>Period类用于修改给定日期或获得的两个日期之间的区别。</p>
<p>给初始化的日期添加5天:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate initialDate = LocalDate.parse(<span class="string">"2017-07-20"</span>);</span><br><span class="line"></span><br><span class="line">LocalDate finalDate = initialDate.plus(Period.ofDays(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"初始化日期: "</span> + initialDate);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"加日期之后: "</span> + finalDate);</span><br></pre></td></tr></table></figure>
<p>周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> between = ChronoUnit.DAYS.between(initialDate, finalDate);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"差距天数: "</span> + between);</span><br></pre></td></tr></table></figure>
<p>上面的代码会返回5，当然你想获取两个日期相差多少小时也是简单的。</p>
<h2 id="与遗留代码转换"><a href="#与遗留代码转换" class="headerlink" title="与遗留代码转换"></a><strong>与遗留代码转换</strong></h2><p>在之前的代码中你可能出现了大量的Date类，如何将它转换为Java8种的时间类呢？</p>
<p>Date和Instant互相转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = Date.from(Instant.now());</span><br><span class="line"></span><br><span class="line">Instant instant = date.toInstant();</span><br></pre></td></tr></table></figure>
<p>Date转换为LocalDateTime</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.from(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">System.out.println(localDateTime);</span><br></pre></td></tr></table></figure>
<p>LocalDateTime转Date</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</span><br></pre></td></tr></table></figure>
<p>LocalDate转Date</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java8</tag>
        <tag>时间API</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 9种数据结构以及它们的内部编码实现</title>
    <url>/2020/05/17/redis/Redis-9%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载：<a href="https://mp.weixin.qq.com/s/oPDm0Jud1AuTDjtOT7BbNw" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<p>90%的人知道Redis 5种最基本的数据结构，只有不到10%的人知道8种基本数据结构（5种基本+bitmap+GeoHash+HyperLogLog），只有不到5%的人知道9种基本数据结构（5.0最新版本数据结构Streams），只有不到1%的人掌握了所有9种基本数据结构以及8种内部编码，掌握这篇文章的知识点，让你<strong>成为面试官眼中Redis方面最靓的仔</strong>！</p>
<blockquote>
<p>说明：本文基于<strong>Redis-3.2.11</strong>版本源码进行分析。</p>
</blockquote>
<a id="more"></a>
<h1 id="一、5种普通数据结构"><a href="#一、5种普通数据结构" class="headerlink" title="一、5种普通数据结构"></a><strong>一、5种普通数据结构</strong></h1><p>这个没什么好说的，对Redis稍微有点了解的都知道5种最基本的数据结构：String，List，Hash，Set，Sorted Set。不过，需要注意的是，这里依然有几个高频面试题。</p>
<ul>
<li>Set和Hash的关系</li>
</ul>
<p>答案就是Set是一个特殊的value为空的Hash。Set类型操作的源码在t_set.c中。以新增一个元素为例（<code>int setTypeAdd(robj *subject, sds value)</code>），如果编码类型是<strong>OBJ_ENCODING_HT</strong>，那么新增源码的源码如下，事实上就是对dict即Hash数据结构进行操作，并且dictSetVal时value是NULL：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (de) &#123;</span><br><span class="line">    dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">    dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，我们在t_hash.c中看到Hash类型新增元素时，当判断编码类型是<strong>OBJ_ENCODING_HT</strong>时，也是调用dict的方法：dictAdd(o-&gt;ptr,f,v)，dictAdd最终也是调用dictSetVal()方法，只不过v即value不为NULL：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，Redis中Set和Hash的关系就很清楚了，当编码是OBJ_ENCODING_HT时，两者都是dict数据类型，只不过Set是value为NULL的特殊的dict。</p>
<ul>
<li>谈谈你对Sorted Set的理解</li>
</ul>
<p>Sorted Set的数据结构是一种跳表，即SkipList，如下图所示，红线是查找10的过程：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248131.webp" alt="SkipList" title="" class="">
                <p>SkipList</p>
            </figure>
<ul>
<li>如何借助Sorted set实现多维排序</li>
</ul>
<p>Sorted Set默认情况下只能根据一个因子score进行排序。如此一来，局限性就很大，举个栗子：热门排行榜需要按照下载量&amp;最近更新时间排序，即类似数据库中的ORDER BY download_count, update_time DESC。那这样的需求如果用Redis的Sorted Set实现呢？</p>
<p>事实上很简单，思路就是将涉及排序的多个维度的列通过一定的方式转换成一个特殊的列，即result = function(x, y, z)，即x，y，z是三个排序因子，例如下载量、时间等，通过自定义函数function()计算得到result，将result作为Sorted Set中的score的值，就能实现任意维度的排序需求了。</p>
<h1 id="二、Redis内部编码"><a href="#二、Redis内部编码" class="headerlink" title="二、Redis内部编码"></a><strong>二、Redis内部编码</strong></h1><p>我们常说的String，List，Hash，Set，Sorted Set只是对外的编码，实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis可以在合适的场景选择更合适的内部编码。</p>
<p>如下图所示（图片纠正：<strong>intset</strong>编码，而不是inset编码），可以看到每种数据结构都有2种以上的内部编码实现，例如String数据结构就包含了raw、int和embstr三种内部编码。同时，有些内部编码可以作为多种外部数据结构的内部实现，例如ziplist就是hash、list和zset共有的内部编码，而set的内部编码可能是hashtable或者intset：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248139.webp" alt="Redis内部编码" title="" class="">
                <p>Redis内部编码</p>
            </figure>Redis内部编码<br><br>Redis这样设计有两个好处：<br><br>1. 可以偷偷的改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动对外数据结构和命令。<br>2. 多种内部编码实现可以在不同场景下发挥各自的优势。例如ziplist比较节省内存，但是在列表元素比较多的情况下，性能会有所下降。这时候Redis会根据配置选项将列表类型的内部实现转换为linkedlist。<br><br>### 1. String的3种内部编码<br><br>由上图可知，String的3种内部编码分别是：int、embstr、raw。int类型很好理解，当一个key的value是整型时，Redis就将其编码为int类型（另外还有一个条件：把这个value当作字符串来看，它的长度不能超过20）。如下所示。这种编码类型为了节省内存。Redis默认会缓存10000个整型值（#define OBJ_SHARED_INTEGERS 10000），这就意味着，如果有10个不同的KEY，其value都是10000以内的值，事实上全部都是共享同一个对象：<br><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set number "7890"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding number</span><br><span class="line">"int"</span><br></pre></td></tr></table></figure>
<p>接下来就是ebmstr和raw两种内部编码的长度界限，请看下面的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，embstr和raw编码的长度界限是44，我们可以做如下验证。长度超过44以后，就是raw编码类型，不会有任何优化，是多长，就要消耗多少内存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name "a1234567890123456789012345678901234567890123"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line">"embstr"</span><br><span class="line">127.0.0.1:6379&gt; set name "a12345678901234567890123456789012345678901234"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line">"raw"</span><br></pre></td></tr></table></figure>
<p>那么为什么有embstr编码呢？它相比raw的优势在哪里？embstr编码将创建字符串对象所需的空间分配的次数从raw编码的两次降低为一次。因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能更好地利用缓存带来的优势。并且释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码对象的字符串对象需要调用两次内存释放函数。如下图所示，左边是embstr编码，右边是raw编码：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248148.webp" alt="embstr V.S. raw" title="" class="">
                <p>embstr V.S. raw</p>
            </figure>
<h3 id="2-ziplist"><a href="#2-ziplist" class="headerlink" title="2. ziplist"></a>2. ziplist</h3><p>由前面的图可知，List，Hash，Sorted Set三种对外结构，在特殊情况下的内部编码都是ziplist，那么这个ziplist有什么神奇之处呢？</p>
<p>以Hash为例，我们首先看一下什么条件下它的内部编码是ziplist：</p>
<ol>
<li>当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）；</li>
<li>所有值都小于hash-max-ziplist-value配置（默认64个字节）；</li>
</ol>
<p>如果是sorted set的话，同样需要满足两个条件：</p>
<ol>
<li>元素个数小于zset-max-ziplist-entries配置，默认128；</li>
<li>所有值都小于zset-max-ziplist-value配置，默认64。</li>
</ol>
<p>实际上，ziplist充分体现了Redis对于存储效率的追求。一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。而ziplist却是将表中<strong>每一项存放在前后连续的地址空间内</strong>，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p>
<p>ziplist的源码在ziplist.c这个文件中，其中有一段这样的描述 – The general layout of the ziplist is as follows:：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>zlbytes</strong>：表示这个ziplist占用了多少空间，或者说占了多少字节，这其中包括了zlbytes本身占用的4个字节；</li>
<li><strong>zltail</strong>：表示到ziplist中最后一个元素的偏移量，有了这个值，pop操作的时间复杂度就是O(1)了，即不需要遍历整个ziplist；</li>
<li><strong>zllen</strong>：表示ziplist中有多少个entry，即保存了多少个元素。由于这个字段占用16个字节，所以最大值是2^16-1，也就意味着，如果entry的数量超过2^16-1时，需要遍历整个ziplist才知道entry的数量；</li>
<li><strong>entry</strong>：真正保存的数据，有它自己的编码；</li>
<li><strong>zlend</strong>：专门用来表示ziplist尾部的特殊字符，占用8个字节，值固定为255，即8个字节每一位都是1。</li>
</ul>
<p>如下就是一个真实的ziplist编码，包含了2和5两个元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]</span><br><span class="line">      |             |          |       |       |     |</span><br><span class="line">   zlbytes        zltail    entries   &quot;2&quot;     &quot;5&quot;   end</span><br></pre></td></tr></table></figure>
<h3 id="3-linkedlist"><a href="#3-linkedlist" class="headerlink" title="3. linkedlist"></a>3. linkedlist</h3><p>这是List的一种编码数据结构非常简单，就是我们非常熟悉的双向链表，对应Java中的LinkedList。</p>
<h3 id="4-skiplist"><a href="#4-skiplist" class="headerlink" title="4. skiplist"></a>4. skiplist</h3><p>这个前面也已经提及，就是经典的跳表数据结构。</p>
<h3 id="5-hashtable"><a href="#5-hashtable" class="headerlink" title="5. hashtable"></a>5. hashtable</h3><p>这个也很容易，对应Java中的HashMap。</p>
<h3 id="6-intset"><a href="#6-intset" class="headerlink" title="6. intset"></a>6. intset</h3><p>Set特殊内部编码，当满足下面的条件时Set的内部编码就是intset而不是hashtable：</p>
<ol>
<li>Set集合中必须是64位有符号的十进制整型；</li>
<li>元素个数不能超过set-max-intset-entries配置，默认512；</li>
</ol>
<p>验证如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd scores 135</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; sadd scores 128</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding scores</span><br><span class="line">"intset"</span><br></pre></td></tr></table></figure>
<p>那么intset编码到底是个什么东西呢？看它的源码定义如下，很明显，就是整型数组，并且是一个<strong>有序的整型数组</strong>。它在内存分配上与ziplist有些类似，是连续的一整块内存空间，而且对于大整数和小整数采取了不同的编码，尽量对内存的使用进行了优化。这样的数据结构，如果执行SISMEMBER命令，即查看某个元素是否在集合中时，事实上使用的是二分查找法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// intset编码查找方法源码（人为简化），标准的二分查找法：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>
<h1 id="三、3种高级数据结构"><a href="#三、3种高级数据结构" class="headerlink" title="三、3种高级数据结构"></a><strong>三、3种高级数据结构</strong></h1><p>Redis中3种高级数据结构分别是bitmap、GEO、HyperLogLog，针对这3种数据结构，笔者之前也有文章介绍过。其中，最重要的就是<strong>bitmap</strong>。</p>
<h3 id="1-bitmap"><a href="#1-bitmap" class="headerlink" title="1. bitmap"></a>1. bitmap</h3><p>这个就是Redis实现的BloomFilter，BloomFilter非常简单，如下图所示，假设已经有3个元素a、b和c，分别通过3个hash算法h1()、h2()和h2()计算然后对一个bit进行赋值，接下来假设需要判断d是否已经存在，那么也需要使用3个hash算法h1()、h2()和h2()对d进行计算，然后得到3个bit的值，恰好这3个bit的值为1，这就能够说明：<strong>d可能存在集合中</strong>。再判断e，由于h1(e)算出来的bit之前的值是0，那么说明：<strong>e一定不存在集合中</strong>：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248166.webp" alt="BloomFilter" title="" class="">
                <p>BloomFilter</p>
            </figure>BloomFilter<br><br>需要说明的是，bitmap并不是一种真实的数据结构，它本质上是String数据结构，只不过操作的粒度变成了位，即bit。因为String类型最大长度为512MB，所以bitmap最多可以存储2^32个bit。<br><br>### 2. GEO<br><br>GEO数据结构可以在Redis中存储地理坐标，并且坐标有限制，由EPSG:900913 / EPSG:3785 / OSGEO:41001 规定如下：<br><br>1. 有效的经度从-180度到180度。<br>2. 有效的纬度从-85.05112878度到85.05112878度。<br><br>当坐标位置超出上述指定范围时，该命令将会返回一个错误。添加地理位置命令如下：<br><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> GEOADD city 114.031040 22.324386 "shenzhen" 112.572154 22.267832 "guangzhou"</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">redis&gt;</span> GEODIST city shenzhen guangzhou</span><br><span class="line">"150265.8106"</span><br></pre></td></tr></table></figure>
<p>但是，需要说明的是，Geo本身不是一种数据结构，它<strong>本质上还是借助于Sorted Set（ZSET）</strong>，并且使用<strong>GeoHash</strong>技术进行填充。Redis中将经纬度使用52位的整数进行编码，放进zset中，score就是GeoHash的52位整数值。在使用Redis进行Geo查询时，其内部对应的操作其实就是zset(skiplist)的操作。通过zset的score进行排序就可以得到坐标附近的其它元素，通过将score还原成坐标值就可以得到元素的原始坐标。</p>
<p>总之，Redis中处理这些地理位置坐标点的思想是：二维平面坐标点 –&gt; 一维整数编码值 –&gt; zset(score为编码值) –&gt; zrangebyrank(获取score相近的元素)、zrangebyscore –&gt; 通过score(整数编码值)反解坐标点 –&gt; 附近点的地理位置坐标。</p>
<ul>
<li>GEOHASH原理</li>
</ul>
<p>使用wiki上的例子，纬度为42.6，经度为-5.6的点，转化为base32的话要如何转呢？<br>首先拿纬度来进行说明，纬度的范围为-90到90，将这个范围划为两段，则为[-90,0]、[0,90]，然后看给定的纬度在哪个范围，在前面的范围的话，就设当前位为0，后面的话值便为1.然后继续将确定的范围1分为2，继续以确定值在前段还是后段来确定bit的值。就这样慢慢的缩小范围，一般最多缩小13次就可以了(经纬度的二进制位相加最多25位，经度13位，纬度12位)。这时的中间值，将跟给定的值最相近。如下图所示：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248175.webp" alt="Geohash" title="" class="">
                <p>Geohash</p>
            </figure>
<p>第1行，纬度42.6位于[0, 90]之间，所以bit=1；第2行，纬度42.6位于[0, 45]之间，所以bit=0；第3行，纬度42.6位于[22.5, 45]之间，所以bit=1，以此类推。这样，取出图中的bit位：1011 1100 1001，同样的方法，将经度(范围-180到180)算出来为 ：0111 1100 0000 0。结果对其如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 经度</span><br><span class="line">0111 1100 0000 0</span><br><span class="line"><span class="meta">#</span> 纬度</span><br><span class="line">1011 1100 1001</span><br></pre></td></tr></table></figure>
<p>得到了经纬度的二进制位后，下面需要将两者进行结合：从经度、纬度的循环，每次取其二进制的一位(不足位取0)，合并为新的二进制数：01101111 11110000 01000001 0。每5位为一个十进制数，结合base32对应表映射为base32值为：ezs42。这样就完成了encode的过程。</p>
<h3 id="3-Streams"><a href="#3-Streams" class="headerlink" title="3. Streams"></a>3. Streams</h3><p>这是Redis5.0引入的全新数据结构，用一句话概括Streams就是Redis实现的内存版kafka。而且，Streams也有<strong>Consumer Groups</strong>的概念。通过Redis源码中对stream的定义我们可知，streams底层的数据结构是<strong>radix tree</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stream</span> &#123;</span></span><br><span class="line">    rax *rax;               <span class="comment">/* The radix tree holding the stream. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> length;        <span class="comment">/* Number of elements inside this stream. */</span></span><br><span class="line">    streamID last_id;       <span class="comment">/* Zero if there are yet no items. */</span></span><br><span class="line">    rax *cgroups;           <span class="comment">/* Consumer groups dictionary: name -&gt; streamCG */</span></span><br><span class="line">&#125; stream;</span><br></pre></td></tr></table></figure>
<p>那么这个radix tree长啥样呢？在Redis源码的rax.h文件中有一段这样的描述，这样看起来是不是就比较直观了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*                    (f) &quot;&quot;</span><br><span class="line">*                    /</span><br><span class="line">*                 (i o) &quot;f&quot;</span><br><span class="line">*                 /   \</span><br><span class="line">*    &quot;firs&quot;  (&quot;rst&quot;)  (o) &quot;fo&quot;</span><br><span class="line">*              /        \</span><br><span class="line">*    &quot;first&quot; []       [t   b] &quot;foo&quot;</span><br><span class="line">*                     /     \</span><br><span class="line">*           &quot;foot&quot; (&quot;er&quot;)    (&quot;ar&quot;) &quot;foob&quot;</span><br><span class="line">*                    /          \</span><br><span class="line">*          &quot;footer&quot; []          [] &quot;foobar&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Radix Tree(基数树) 事实上就几乎相同是传统的二叉树</strong>。仅仅是在寻找方式上，以一个unsigned int类型数为例，利用这个数的每个比特位作为树节点的推断。能够这样说，比方一个数10001010101010110101010，那么依照Radix 树的插入就是在根节点，假设遇到0，就指向左节点，假设遇到1就指向右节点，在插入过程中构造树节点，在删除过程中删除树节点。如下是一个保存了7个单词的Radix Tree：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248187.webp" alt="radix tree" title="" class="">
                <p>radix tree</p>
            </figure>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高级玩法：如何利用SortedSet实现多维度排序</title>
    <url>/2020/05/17/redis/Redis%E9%AB%98%E7%BA%A7%E7%8E%A9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8SortedSet%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%B4%E5%BA%A6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载：<a href="https://mp.weixin.qq.com/s/LpHLnmtHi35SEGiArd0Mag" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<h1 id="一、关于SortedSet"><a href="#一、关于SortedSet" class="headerlink" title="一、关于SortedSet"></a>一、关于SortedSet</h1><p>首先，我们都知道Redis的SortedSet是可以根据score进行排序的，以手机应用商店的热门榜单排序为例，根据下载量倒序排列，其简单用法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd TopApp 12000000 wechat</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd TopApp 8000000 taobao 10000000 alipay</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE TopApp 0 -1</span><br><span class="line">1) "wechat"</span><br><span class="line">2) "alipay"</span><br><span class="line">3) "taobao"</span><br></pre></td></tr></table></figure>
<p>对SortedSet做一下简单总结：</p>
<ol>
<li>默认升序排列，即通过命令<strong>ZRANGE</strong>实现；如果要按照降序排列，需要通过命令<strong>ZREVRANGE</strong>实现；</li>
<li>当score即得分一样时，按照<strong>字典顺序</strong>对member进行排序，字典排序用的是二进制，它比较的是字符串的字节数组，所以实际上是比较ASCII码。</li>
</ol>
<p>简单用法介绍完后，接下来给出几种方案，介绍<strong>如何利用Redis实现多维度排序</strong>。同样的，还是以手机应用商店的热门榜单排序为例：首先按照APP的下载量倒序排序，如果下载量一样，则按照最后更新时间倒序排列。</p>
<a id="more"></a>
<h2 id="1-方案1"><a href="#1-方案1" class="headerlink" title="1. 方案1"></a>1. 方案1</h2><p>介绍的第一个方案，并不需要依赖SortedSet，它的实现非常简单，但是需要产品做简单的妥协，即不能实时更新榜单。其实现方案是：定时每隔1分钟（可以由产品确定时间间隔）通过SQL（select * from tb_apps order by download_count desc, updated_time desc limit 300）或者其他方式计算热门榜单，然后把TOP300用List结构保存到缓存中。</p>
<blockquote>
<p>说明：根据应用商店的用户行为分析，真实用户很少会预览10页以后的数据，即使有这种用户，我们也可以忽略掉。所以只需要将总计10页，即10x30=300个APP信息用List结构保存即可。分页取数据时，通过lrange命令即可轻松实现。</p>
</blockquote>
<p>这种方案虽然简单，但是非常有用。即使不能做到实时，但是并没有影响用户体验。在项目初期需要快速发布，是一个比较推荐的做法。</p>
<h2 id="2-方案2"><a href="#2-方案2" class="headerlink" title="2. 方案2"></a>2. 方案2</h2><p>方案2就是本文重点介绍的利用SortedSet实现多维度排序。</p>
<p>介绍方案之前，我们再看一下SortedSet排序因子score，<strong>它是一个双精度64位的浮点型数字字符串。+inf和-inf都是有效值</strong>，能包括的整数范围是-(2^53) 到 +(2^53)，或者说是-9007199254740992 到 9007199254740992。</p>
<p>那么，我们如何实现多维度排序呢？答案是<strong>构造一个特殊的score</strong>。以本文案例为例，排序影响因子是下载量和更新时间，那么我们可以构造一个这样特殊的浮点类型的score：<strong>整数部分就是下载量，小数部分就是最后更新时间戳</strong>。</p>
<p>talk is cheap，show me the code。假设有5个app的下载量和最后更新时间分别如下（说明：更新时间只精确到秒）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wechat-下载量：12000000，最后更新时间：1564022201；其score为：12000000.1564022201</span><br><span class="line">qq-下载量：12000000，最后更新时间：1564022222；其score为：12000000.1564022222</span><br><span class="line">tiktok-下载量：9808900，最后更新时间：1563552267；其score为：9808900.1563552267</span><br><span class="line">taobao-下载量：11006600，最后更新时间：1564345601；其score为：11006600.1564345601</span><br><span class="line">alipay-下载量：11006600，最后更新时间：1564345600；其score为：11006600.1564345600</span><br></pre></td></tr></table></figure>
<p>接下来，我们通过如下命令将这5个APP用SortedSet数据类型保存到Redis中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd TopApp 12000000.1564022201 wechat 12000000.1564022222 qq 9808900.1563552267 tiktok 11006600.1564345601 taobao 11006600.1564345600 alipay</span><br></pre></td></tr></table></figure>
<p>保存后，我们看一下排序结果是否符合我们的预期：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrange TopApp 0 -1</span><br><span class="line">1) "qq"</span><br><span class="line">2) "wechat"</span><br><span class="line">3) "taobao"</span><br><span class="line">4) "alipay"</span><br><span class="line">5) "tiktok"</span><br></pre></td></tr></table></figure>
<h1 id="二、写在最后"><a href="#二、写在最后" class="headerlink" title="二、写在最后"></a>二、写在最后</h1><p>是不是很完美？</p>
<p>还不完美，这种讨巧的方式只能实现二维排序。如果有三维排序，四维排序呢？这里笔者提供一种实现参考，即<strong>自定义得分权重计算公式</strong>，这个公式包含所有影响排序的因子，例如：downloadCount*1000+updatedTime。这种实现无论排序维度多少都搞得定，但是需要注意的是，在具体实现时一定注意不要让score溢出。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>多维排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Streams：深入剖析Redis5.0全新数据结构</title>
    <url>/2020/05/17/redis/Streams%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Redis5-0%E5%85%A8%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载：<a href="https://mp.weixin.qq.com/s/GpG3t_O_SxLGNklVnoOiYQ" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<p>Redis 5.0 全新的数据类型：streams，官方把它定义为：<strong>以更抽象的方式建模日志的数据结构</strong>。Redis的streams主要是一个append only的数据结构，至少在概念上它是一种在内存中表示的抽象数据类型，只不过它们实现了更强大的操作，以克服日志文件本身的限制。</p>
<p>如果你了解MQ，那么可以把streams当做MQ。如果你还了解kafka，那么甚至可以把streams当做kafka。</p>
<p>另外，这个功能有点类似于redis以前的<strong>Pub/Sub</strong>，但是也有基本的不同：</p>
<ul>
<li><p>streams支持多个客户端（消费者）等待数据（Linux环境开多个窗口执行XREAD即可模拟），并且每个客户端得到的是完全相同的数据。</p>
</li>
<li><p>Pub/Sub是发送忘记的方式，并且不存储任何数据；而streams模式下，所有消息被无限期追加在streams中，除非用于显示执行删除（XDEL）。</p>
</li>
<li><p>streams的Consumer Groups也是Pub/Sub无法实现的控制方式。</p>
<a id="more"></a>
</li>
</ul>
<h3 id="1-streams数据结构"><a href="#1-streams数据结构" class="headerlink" title="1. streams数据结构"></a>1. streams数据结构</h3><p>streams数据结构本身非常简单，但是streams依然是Redis到目前为止最复杂的类型，其原因是实现的一些额外的功能：一系列的阻塞操作允许消费者等待生产者加入到streams的新数据。另外还有一个称为<strong>Consumer Groups</strong>的概念，这个概念最先由kafka提出，Redis有一个类似实现，和kafka的Consumer Groups的目的是一样的：允许一组客户端协调消费相同的信息流！</p>
<p>redis源码中定义streams结构的源码如下，由源码可知，stream的核心数据结构是radix tree：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stream</span> &#123;</span></span><br><span class="line">    rax *rax;               <span class="comment">/* The radix tree holding the stream. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> length;        <span class="comment">/* Number of elements inside this stream. */</span></span><br><span class="line">    streamID last_id;       <span class="comment">/* Zero if there are yet no items. */</span></span><br><span class="line">    rax *cgroups;           <span class="comment">/* Consumer groups dictionary: name -&gt; streamCG */</span></span><br><span class="line">&#125; stream;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码参考：<a href="https://github.com/antirez/redis/blob/5.0.0/src/stream.h；" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/5.0.0/src/stream.h；</a></p>
</blockquote>
<p>至于redis对radix tree的实现，参考源码：<a href="https://github.com/antirez/redis/blob/5.0.0/src/rax.c" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/5.0.0/src/rax.c</a> 和 <a href="https://github.com/antirez/redis/blob/5.0.0/src/rax.h" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/5.0.0/src/rax.h</a> 。网上也有很多radix tree的文章，本篇文章就不做过多的介绍了。下面给出一张从官方源码中的部分截图：</p>
<figure class="image-box">
                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589689130577.webp" alt="radix tree" title="" class="">
                <p>radix tree</p>
            </figure>
<h3 id="2-streams基础"><a href="#2-streams基础" class="headerlink" title="2. streams基础"></a>2. streams基础</h3><p>为了理解streams的目的，以及如何使用它，我们先忽略掉所有高级特性，只把注意力放在数据结构本身，以及那些操作和访问streams的命令。这基本上也是大多数其他Redis数据类型共有的部分，例如Lists，Sets，Sorted Sets等。然而需要注意的是，Lists也有一个更复杂的阻塞式的API，例如BLPOP，BRPOP等。streams这方便的API也没什么不同，只是更复杂，更强大（更牛逼，哈）！</p>
<h3 id="3-streams命令"><a href="#3-streams命令" class="headerlink" title="3. streams命令"></a>3. streams命令</h3><p>废话不多说，先上手玩玩这个全新的数据类型。streams这个数据类型对应有如下13个操作命令，所有命令都以”<strong>X</strong>“开头：</p>
<h4 id="1-XADD"><a href="#1-XADD" class="headerlink" title="1. XADD"></a>1. XADD</h4><p><strong>用法</strong>：XADD key ID field string [field string …]<br>正如其名，这个命令就是用来添加的，给streams追加（append，前面提到过：streams主要是一个append only的数据结构）一个新的entry（和Java里的Map类似，Redis里的streams中的数据也称为entry）。</p>
<p><strong>key</strong>：的含义就是同一类型streams的名称；<br><strong>ID</strong>: streams中entry的唯一标识符，如果执行XADD命令时，传入星号（*），那么，ID会自动生成，且自动生成的ID会在执行XADD后返回，默认生成的ID格式为millisecondsTime+sequenceNumber，即当前毫秒级别的时间戳加上一个自增序号值，例如<code>&quot;1540013735401-0&quot;</code>。并且执行XADD时，不接受少于或等于上一次执行XADD的ID，否则会报错：<code>ERR The ID specified in XADD is equal or smaller than the target stream top item</code>；<br><strong>field&amp;string</strong>：接下来就是若干组field string。可以把它理解为表示属性的json中的key-value。例如，某一streams的key命名为userInfo，且某个用户信息为{“username”:”afei”, “password”:”123456”}，那么执行XADD命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd userInfo * username afei password 123456</span><br><span class="line">"1540014082060-0"</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于命令中ID字段的值是星号，所以自定生成ID，<code>1540014082060-0</code>就是自动生成的ID。 XADD命令也支持显示指定ID，例如：<code>XADD streamname 0-2 foo bar</code>。</p>
</blockquote>
<ul>
<li>时钟回拨</li>
</ul>
<p>需要注意的是，ID的时间戳部分是部署Redis服务器的本地时间，如果发生时钟回拨会怎么样？如果发生始终回拨，生成的ID的时间戳部分就是回拨后的时间，然后加上这个时间的递增序列号。例如当前时间戳1540014082060，然后这时候发生了时钟回拨，且回拨5ms，那么时间戳就是1540014082055。假设以前已经生成了1540014082055-0，1540014082055-1，那么这次由于时钟回拨，生成的ID就是1540014082055-2。所以允许自动生成的ID在发生时钟回拨时少于上次的ID，但是不允许显示指定一个少于上次的ID。</p>
<h4 id="2-XDEL"><a href="#2-XDEL" class="headerlink" title="2. XDEL"></a>2. XDEL</h4><p><strong>用法</strong>：XDEL key ID [ID …]<br>和XADD相反，这是命令用来从streams中删除若干个entry，并且会返回<strong>实际</strong>删除数，这个删除数可能和参数ID个数不等，因为某些ID表示的消息可能不存在。执行命令如下，第二个参数ID是不存在的，所以XDEL的返回结果是1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XDEL userInfo "1540014379642-0" "1540014379642-1"</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h4 id="3-XLEN"><a href="#3-XLEN" class="headerlink" title="3. XLEN"></a>3. XLEN</h4><p><strong>用法</strong>：XLEN key<br>很好理解，这个命令就是用来返回streams中有多少个entry。执行如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XLEN userInfo</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<h4 id="4-streams三种查询模式"><a href="#4-streams三种查询模式" class="headerlink" title="4. streams三种查询模式"></a>4. streams三种查询模式</h4><p>redis提供了三种查询streams数据的模式：</p>
<ol>
<li><strong>范围查询</strong>：因为streams的每个entry，其默认生成的ID是基于时间且递增的；</li>
<li><strong>监听模式</strong>：类比linux中的tailf命令，实时接收新增加到streams中的entry（也有点像一个消息系统，事实上笔者认为它就是借鉴了kafka）；</li>
<li><strong>消费者组</strong>：即Consumer Groups，特殊的监听模式。从一个消费者的角度来看streams，一个streams能被分区到多个处理消息的消费者，对于任意一条消息，同一个消费者组中只有一个消费者可以处理（和kafka的消费者组完全一样）。这样还能够横向扩容消费者，从而提升处理消息的能力，而不需要只让把让一个消费者处理所有消息。</li>
</ol>
<p>接下里分别介绍这三种模式。</p>
<h4 id="5-XRANGE"><a href="#5-XRANGE" class="headerlink" title="5. XRANGE"></a>5. XRANGE</h4><p><strong>用法</strong>：XRANGE key start end [COUNT count]<br>这个命令属于第1种模式，即基于范围查询。这个命令用来返回streams某个顺序范围下的元素，start参数是更小的ID，end参数是更大的ID。有两个特殊的ID用符号”-“和”+”表示，符号”-“表示最小的ID，符号”+”表示最大的ID：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XRANGE userInfo "1540014096298-0" "1540014477236-0"</span><br><span class="line">1) 1) "1540014096298-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "root"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "666666"</span><br><span class="line">2) 1) "1540014477236-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "test"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "111111"</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; XRANGE userInfo - +</span><br><span class="line">1) 1) "1540014082060-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "afei"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "123456"</span><br><span class="line">2) 1) "1540014096298-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "root"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "666666"</span><br><span class="line">3) 1) "1540014477236-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "test"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "111111"</span><br><span class="line">4) 1) "1540014493402-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "u1"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "111111"</span><br></pre></td></tr></table></figure>
<p>XRANGE还能实现遍历某个范围区间的功能，例如我想遍历2018-10-20号新增的用户信息。首先得到2018-10-20 00:00:00对应的时间戳为1539964800000，再得到2018-10-20 23:59:59对应的时间戳为1540051199000，然后执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XRANGE userInfo 1539964800000-0  1540051199000-0 COUNT 5</span><br><span class="line">1) 1) "1540014082060-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "afei"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "123456"</span><br><span class="line">... ...</span><br><span class="line">5) 1) "1540014496505-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "u2"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "111111"</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="meta">#</span> 需要注意的是，接下来再遍历的start参数是上一次遍历结果最大的ID加1，即"1540014496505-0"加1就是"1540014496505-1"。</span><br><span class="line">127.0.0.1:6379&gt; XRANGE userInfo 1540014496505-1  1540051199000-0 COUNT 5</span><br><span class="line">1) 1) "1540014499863-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "u3"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "111111"</span><br></pre></td></tr></table></figure>
<h4 id="6-XREVRANGE"><a href="#6-XREVRANGE" class="headerlink" title="6. XREVRANGE"></a>6. XREVRANGE</h4><p><strong>用法</strong>：XREVRANGE key end start [COUNT count]<br>这个命令也属于第1种模式，且和XRANGE相反，返回一个逆序范围。end参数是更大的ID，start参数是更小的ID。执行示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">XREVRANGE userInfo "1540014477236-0" "1540014096298-0"</span><br></pre></td></tr></table></figure>
<h4 id="7-XREAD"><a href="#7-XREAD" class="headerlink" title="7. XREAD"></a>7. XREAD</h4><p><strong>用法</strong>：XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] ID [ID …]<br>很明显，这个命令就是用来实现第2个模式，即监听模式。其作用是返回streams中从来没有读取的，且比参数ID更大的元素。</p>
<p>这个命令的使用方式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREAD COUNT 10 BLOCK 60000 STREAMS userInfo "1540041139268-0"</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540041264182-0"</span><br><span class="line">         2) 1) "u2"</span><br><span class="line">            2) "p2"</span><br><span class="line">(9.26s)</span><br><span class="line"><span class="meta">#</span> "1540041264182-0"这条消息时通过XADD添加的然后被XREAD监听到的消息。</span><br><span class="line">127.0.0.1:6379&gt; XREAD COUNT 2 STREAMS userInfo 0</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540014082060-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "afei"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "123456"</span><br><span class="line">      2) 1) "1540014096298-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "root"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "666666"</span><br><span class="line"><span class="meta">#</span> 这条命令实现类似XRANGE的功能。</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; XREAD BLOCK 0 STREAMS userInfo $</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540042613437-0"</span><br><span class="line">         2) 1) "u7"</span><br><span class="line">            2) "p7"</span><br><span class="line"><span class="meta">#</span> 说明BLOCK为0表示一致等待知道有新的数据，否则永远不会超时。并且ID的值我们用特殊字符`$`表示，这个特殊字符表示我们只获取最新添加的消息。</span><br></pre></td></tr></table></figure>
<p>此外，XREAD还支持同时监听多个streams，用法如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREAD BLOCK 0 STREAMS userInfo_01 userInfo_02 userInfo_03 userInfo_04  $ $ $ $</span><br><span class="line">1) 1) "userInfo_03"</span><br><span class="line">   2) 1) 1) "1540043348287-0"</span><br><span class="line">         2) 1) "u1"</span><br><span class="line">            2) "p1"</span><br><span class="line">(3.49s)</span><br><span class="line"><span class="meta">#</span> 监听userInfo_01~userInfo_04这4个streams的新的消息。</span><br></pre></td></tr></table></figure>
<p>XREAD除了COUNT和BLOCK，没有其他选项了。所有XREAD是一个非常基本的命令。更多高级特性可以往下看接下来要介绍的XREADGROUP。</p>
<h4 id="8-XREADGROUP"><a href="#8-XREADGROUP" class="headerlink" title="8. XREADGROUP"></a>8. XREADGROUP</h4><p>用法：XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] STREAMS key [key …] ID [ID …]<br>很明显，这就是第三种模式：消费者组模式。</p>
<p>如果你了解kafka的消费者组，那么你就也了解了streams的消费者组。如果不了解也没关系，笔者简单解释一下，假设有三个消费者C1，C2，C3。在streams中总计有7条消息：1， 2， 3， 4， 5， 6， 7，那么消费关系如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 -&gt; C1</span><br><span class="line">2 -&gt; C2</span><br><span class="line">3 -&gt; C3</span><br><span class="line">4 -&gt; C1</span><br><span class="line">5 -&gt; C2</span><br><span class="line">6 -&gt; C3</span><br><span class="line">7 -&gt; C1</span><br></pre></td></tr></table></figure>
<p>消费者组具备如下几个特点：</p>
<ol>
<li>同一个消息不会被投递到一个消费者组下的多个消费者，只可能是一个消费者。</li>
<li>同一个消费者组下，每个消费者都是唯一的，通过大小写敏感的名字区分。</li>
<li>消费者组中的消费者请求的消息，一定是新的，从来没有投递过的消息。</li>
<li>消费一个消息后，需要用命令（XACK）确认，意思是说：这条消息已经给成功处理。正因为如此，当访问streams的历史消息时，每个消费者只能看到投递给它自己的消息。</li>
</ol>
<p>消费者组抽象的想象成如下这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------------------------------------+</span><br><span class="line">| consumer_group_name: afeigroup         |</span><br><span class="line">| consumer_group_stream: somekey         |</span><br><span class="line">| last_delivered_id: 1292309234234-92    |</span><br><span class="line">|                                        |</span><br><span class="line">| consumers:                             |</span><br><span class="line">|    &quot;consumer-1&quot; with pending messages  |</span><br><span class="line">|       1292309234234-4                  |</span><br><span class="line">|       1292309234232-8                  |</span><br><span class="line">|    &quot;consumer-42&quot; with pending messages |</span><br><span class="line">|       ... (and so forth)               |</span><br><span class="line">+----------------------------------------+</span><br></pre></td></tr></table></figure>
<h4 id="9-XACK"><a href="#9-XACK" class="headerlink" title="9. XACK"></a>9. XACK</h4><p><strong>用法</strong>：XACK key group ID [ID …]<br>这是消费者组相关的另一个重要的命令。标记一个处理中的消息为已被正确处理，如此一来，这条消息就会被从消费者组的pending消息集合中删除，类似MQ中的ack。</p>
<h4 id="10-XGROUP"><a href="#10-XGROUP" class="headerlink" title="10. XGROUP"></a>10. XGROUP</h4><p><strong>用法</strong>：XGROUP [CREATE key groupname id-or-<code>$</code>] [SETID key id-or-<code>$</code>] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</p>
<p>这也是消费者组的一个重要命令，这个命令用来管理消费者组，例如创建，删除等。</p>
<p>XREADGROUP，XACK，XGROUP三种命令构成了消费者组相关的操作命令，下面是消费者组一些操作示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 创建一个消费者组</span><br><span class="line">127.0.0.1:6379&gt; XGROUP CREATE userInfo GRP-AFEI $</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span> 需要注意的是，目前XGROUP CREATE的streams必须是一个存在的streams，否则会报错：</span><br><span class="line">127.0.0.1:6379&gt; XGROUP CREATE userinfo GRP-AFEI $</span><br><span class="line">(error) ERR The XGROUP subcommand requires the key to exist. Note that for CREATE you may want to use the MKSTREAM option to create an empty stream automatically.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 名为zhangsan的消费者，需要注意的是streams名称userInfo后面的特殊符号`&gt;`表示这个消费者只接收从来没有被投递给其他消费者的消息，即新的消息。当然我们也可以指定具体的ID，例如指定0表示访问所有投递给该消费者的历史消息，指定1540081890919-1表示投递给该消费者且大于这个ID的历史消息：</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup zhangsan COUNT 1 BLOCK 0 STREAMS userInfo &gt;</span><br><span class="line"><span class="meta">#</span> 名为lisi的消费者：</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup lisi COUNT 1 BLOCK 0 STREAMS userInfo &gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 接下来分别添加两条信息，一条就会被zhangsan消费，另一条被lisi消费：</span><br><span class="line">127.0.0.1:6379&gt; XADD userInfo * username u102102 password p102102</span><br><span class="line">"1540081873370-0"</span><br><span class="line">127.0.0.1:6379&gt; XADD userInfo * username u102103 password p102103</span><br><span class="line">"1540081890919-0"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>现在消费者lisi有一条消息：</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup lisi COUNT 5 BLOCK 0 STREAMS userInfo 0</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540081890919-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "u102103"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "p102103"</span><br><span class="line"><span class="meta">#</span>然后通过命令ack这条消息：</span><br><span class="line">127.0.0.1:6379&gt; XACK userInfo mygroup 1540081890919-0</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span> 再看消费者lisi的pending队列，已经为空：</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup lisi COUNT 5 BLOCK 0 STREAMS userInfo 0</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) (empty list or set)</span><br></pre></td></tr></table></figure>
<h4 id="11-XPENDING"><a href="#11-XPENDING" class="headerlink" title="11. XPENDING"></a>11. XPENDING</h4><p>用法：XPENDING key group [start end count] [consumer]<br>返回streams中消费者组的pending消息，即消费者接收到但是还没有ack的消息，用法参考：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 查看消费者组下总计最多10条pending消息</span><br><span class="line">127.0.0.1:6379&gt; XPENDING userInfo mygroup - + 10</span><br><span class="line">1) 1) "1540083260408-0"</span><br><span class="line">   2) "zhangsan"</span><br><span class="line">   3) (integer) 183551</span><br><span class="line">   4) (integer) 1</span><br><span class="line">2) 1) "1540083266293-0"</span><br><span class="line">   2) "lisi"</span><br><span class="line">   3) (integer) 177666</span><br><span class="line">   4) (integer) 1</span><br><span class="line"><span class="meta">#</span> 查看消费者组下zhangsan这个消费者总计最多10条pending消息</span><br><span class="line">127.0.0.1:6379&gt; XPENDING userInfo mygroup - + 10 zhangsan</span><br><span class="line">1) 1) "1540083260408-0"</span><br><span class="line">   2) "zhangsan"</span><br><span class="line">   3) (integer) 187006</span><br><span class="line">   4) (integer) 1</span><br></pre></td></tr></table></figure>
<h4 id="12-XCLAIM"><a href="#12-XCLAIM" class="headerlink" title="12. XCLAIM"></a>12. XCLAIM</h4><p>用法：XCLAIM key group consumer min-idle-time ID [ID …] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]<br>作用是改变消费者组中消息的所有权，用法参考：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup zhangsan COUNT 5 BLOCK 0 STREAMS userInfo 0</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540083260408-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "u102106"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "p102106"</span><br><span class="line"><span class="meta">#</span> zhangsan本来有1条消息，现在将另一条本来属于lisi的消息的所有权转给它：</span><br><span class="line">127.0.0.1:6379&gt; XCLAIM userInfo mygroup zhangsan 360 1540083266293-0</span><br><span class="line">1) 1) "1540083266293-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "u102107"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "p102107"</span><br><span class="line"><span class="meta">#</span> 现在zhangsan有两条消息了</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup zhangsan COUNT 5 BLOCK 0 STREAMS userInfo 0</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540083260408-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "u102106"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "p102106"</span><br><span class="line">      2) 1) "1540083266293-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "u102107"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "p102107"</span><br></pre></td></tr></table></figure>
<h4 id="13-XINFO"><a href="#13-XINFO" class="headerlink" title="13. XINFO"></a>13. XINFO</h4><p><strong>用法</strong>：XINFO [CONSUMERS key groupname] [GROUPS key] [STREAM key] [HELP]<br>其作用是得到streams和消费者组的一些信息，使用参考：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XINFO CONSUMERS userInfo mygroup </span><br><span class="line">1) 1) "name"</span><br><span class="line">   2) "lisi"</span><br><span class="line">   3) "pending"</span><br><span class="line">   4) (integer) 0</span><br><span class="line">   5) "idle"</span><br><span class="line">   6) (integer) 201086</span><br><span class="line">2) 1) "name"</span><br><span class="line">   2) "zhangsan"</span><br><span class="line">   3) "pending"</span><br><span class="line">   4) (integer) 2</span><br><span class="line">   5) "idle"</span><br><span class="line">   6) (integer) 701954</span><br><span class="line">127.0.0.1:6379&gt; XINFO STREAM userInfo</span><br><span class="line"> 1) "length"</span><br><span class="line"> 2) (integer) 22</span><br><span class="line"> 3) "radix-tree-keys"</span><br><span class="line"> 4) (integer) 1</span><br><span class="line"> 5) "radix-tree-nodes"</span><br><span class="line"> 6) (integer) 2</span><br><span class="line"> 7) "groups"</span><br><span class="line"> 8) (integer) 2</span><br><span class="line"> 9) "last-generated-id"</span><br><span class="line">10) "1540082298051-0"</span><br><span class="line">11) "first-entry"</span><br><span class="line">12) 1) "1540014082060-0"</span><br><span class="line">    2) 1) "username"</span><br><span class="line">       2) "afei"</span><br><span class="line">       3) "password"</span><br><span class="line">       4) "123456"</span><br><span class="line">13) "last-entry"</span><br><span class="line">14) 1) "1540082298051-0"</span><br><span class="line">    2) 1) "username"</span><br><span class="line">       2) "u102105"</span><br><span class="line">       3) "password"</span><br><span class="line">       4) "p102105"</span><br></pre></td></tr></table></figure>
<h4 id="14-XTRIM"><a href="#14-XTRIM" class="headerlink" title="14. XTRIM"></a>14. XTRIM</h4><p><strong>用法</strong>：XTRIM key MAXLEN [~] count<br>修剪streams到一个确定的size。Trims the stream to (approximately if ‘~’ is passed) a certain size，用法参考：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> streams只保留10条消息，其返回结果表示被剪去多少条消息：</span><br><span class="line">127.0.0.1:6379&gt; XTRIM userInfo MAXLEN 10</span><br><span class="line">(integer) 14</span><br></pre></td></tr></table></figure>
<p>说明：streams目前的修剪策略比较简单，比如连根据ID范围修剪都没有实现。根据具体某一个ID删除，可以通过XDEL实现。</p>
<h3 id="4-持久化，复制以及消息安全性"><a href="#4-持久化，复制以及消息安全性" class="headerlink" title="4. 持久化，复制以及消息安全性"></a>4. 持久化，复制以及消息安全性</h3><p>和其他数据类型一样，streams也会异步复制到slave，并也会持久化到AOF和RDB文件中。然而，消费者组的全部状态是被传播（propagated ）到AOF，RDB和slave中。</p>
<p>需要注意的是，Redis的streams和消费者组使用Redis默认复制进行持久化和复制，因此：<strong>如果消息的持久性在您的应用程序中很重要，则必须将AOF与强fsync策略一起使用</strong>。<br>默认情况下，异步复制不保证能复制每一个数据添加或使用者组状态更改：在故障转移之后，可能会丢失某些内容，具体取决于slave从master接收数据的能力。</p>
<ul>
<li>长度为0的streams</li>
</ul>
<p>这是streams和其他redis数据类型的不同，其他数据类型，例如Lists，Sets等，如果所有元素都被删除，那么key也不存在。而streams允许所有entry都被删除。</p>
<p>存在这种不对称性的原因是因为streams可能具有关联的消费者组，并且我们不希望由于streams中不再有任何entry而丢失消费者组定义的状态。 目前，即使没有关联的消费者群体，也不会删除该streams。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>streams</tag>
        <tag>redis5.0</tag>
      </tags>
  </entry>
  <entry>
    <title>我的one_year</title>
    <url>/2019/02/19/%E5%BF%83%E5%BE%97/%E6%88%91%E7%9A%84one-year/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>年已经过了，今天是元宵节，南方人生活在北方，虽然没有什么元宵啊，汤圆啊，或者大鱼大肉，来到学校也是冷冷清清的。有闲情，来回顾一下去年一整年所做和所得。</p>
<p>首先，从懵懂少年，有着雄心却有些迷茫的少年开始了实际行动。思想不在是以前那么幼稚，开始了真正的思考。</p>
<p>自己找所需去学习，开始为自己以后的路所打算。点点滴滴，慢慢在积累，但总觉得还是有些晚了的感觉。下面，开始我的数落数落。。。</p>
<a id="more"></a>
<h1 id="进阶之路"><a href="#进阶之路" class="headerlink" title="进阶之路"></a>进阶之路</h1><h2 id="python以及它的爬虫"><a href="#python以及它的爬虫" class="headerlink" title="python以及它的爬虫"></a>python以及它的爬虫</h2><p>大一下学期那个暑假，我就开始接触python以及怎么爬虫。当时还仅仅是一个懵懂状态，网上教学参差不齐，五花八门，根本不知道那个是真正有用或者值得信赖！所以，学的是那么的杂乱无章，加上没有把电脑带回家，实践也就无从谈起。所以，好后悔浪费了那时的一个暑假。只能所学到了一些皮毛！</p>
<p>后来，我才发现，必须得真正系统的学习才行。所以，大二下学期，我就开始跟着我从淘宝上买来的课程，一步一步去系统学习。可能也是年龄的增长，或者说是更系统化了，所以，更清楚的明白一门语言该怎么学习。有大相径庭。但是，真正的精髓就在那个不同。python语法简单，但是没有像c 那样更接近底层，所以，速度上会慢，这就是那个不同。</p>
<p>学着学着，慢慢把python基础给学习完了。那时候，听说大多数人把python基础学完之后就开始学习爬虫，我暑假也尝试过，但是没有那么的要紧，所以就缓了下来（因为我开始弄算法，去参加一些算法的竞赛，开始了java的学习）。直到这个寒假，我才重拾旧本，开始继续的“有趣”玩耍。</p>
<p><strong>下面是我的一些python的简单小案例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: smile丶</span></span><br><span class="line"><span class="comment"># @Date:   2019-02-11 14:08:51</span></span><br><span class="line"><span class="comment"># @Last Modified by:   smile丶</span></span><br><span class="line"><span class="comment"># @Last Modified time: 2019-02-19 15:57:16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">#cdsn新闻首页所有链接爬取</span></span><br><span class="line"><span class="string">url="http://www.csdn.net/"</span></span><br><span class="line"><span class="string">data=urllib.request.urlopen(url).read()</span></span><br><span class="line"><span class="string">data2=data.decode("utf-8","ignore")</span></span><br><span class="line"><span class="string">pat='href="(https://blog.csdn.net/.*?)"'</span></span><br><span class="line"><span class="string">allurl=re.compile(pat).findall(data2)</span></span><br><span class="line"><span class="string">index=1;</span></span><br><span class="line"><span class="string">for i in allurl:</span></span><br><span class="line"><span class="string">	file="C:/Users/Administrator/Desktop/爬虫/csdnnews/"+str(index)+".html";</span></span><br><span class="line"><span class="string">	urllib.request.urlretrieve(i,file)</span></span><br><span class="line"><span class="string">	print(str(index)+"success")</span></span><br><span class="line"><span class="string">	index=index+1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">#sinanews新浪新闻首页所有链接爬取</span></span><br><span class="line"><span class="string">url="https://news.sina.com.cn/"</span></span><br><span class="line"><span class="string">data=urllib.request.urlopen(url).read()</span></span><br><span class="line"><span class="string">data2=data.decode("utf-8","ignore")</span></span><br><span class="line"><span class="string">pat='href="(https://news.sina.com.cn/.*?)"'</span></span><br><span class="line"><span class="string">allurl=re.compile(pat).findall(data2)</span></span><br><span class="line"><span class="string">index=1;</span></span><br><span class="line"><span class="string">for i in allurl:</span></span><br><span class="line"><span class="string">	file="C:/Users/Administrator/Desktop/爬虫/sinanews/"+str(index)+".html";</span></span><br><span class="line"><span class="string">	urllib.request.urlretrieve(i,file)</span></span><br><span class="line"><span class="string">	print(str(index)+"success")</span></span><br><span class="line"><span class="string">	index=index+1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""JD商品图片爬取简单版"""</span></span><br><span class="line">keyword=<span class="string">"连衣裙"</span></span><br><span class="line"><span class="comment">#编码</span></span><br><span class="line">keyword=urllib.request.quote(keyword)</span><br><span class="line"><span class="comment">#仿浏览器访问</span></span><br><span class="line">headers=(<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.81 Safari/537.36"</span>)</span><br><span class="line">opener=urllib.request.build_opener()</span><br><span class="line">opener.addheaders=[headers]</span><br><span class="line">urllib.request.install_opener(opener)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">	url=<span class="string">'https://search.jd.com/Search?keyword='</span>+keyword+<span class="string">'&amp;enc=utf-8&amp;page='</span>+str((i+<span class="number">1</span>)*<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">	<span class="comment">#print(url)</span></span><br><span class="line">	data=urllib.request.urlopen(url).read().decode(<span class="string">"utf-8"</span>,<span class="string">"ignore"</span>)</span><br><span class="line">	<span class="comment">#正则</span></span><br><span class="line">	pat=<span class="string">' source-data-lazy-img="//(.*?)" '</span></span><br><span class="line">	images=re.compile(pat).findall(data)</span><br><span class="line">	index=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> images:</span><br><span class="line">		file=<span class="string">"C:/Users/Administrator/Desktop/爬虫/JDIMG/连衣裙/"</span>+str(i)+str(index)+<span class="string">".jpg"</span></span><br><span class="line">		index=index+<span class="number">1</span></span><br><span class="line">		urllib.request.urlretrieve(<span class="string">"http://"</span>+j,filename=file)</span><br><span class="line">		print(<span class="string">"第"</span>+str(i)+<span class="string">"页"</span>+<span class="string">"第"</span>+str(index)+<span class="string">"张图成功！"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># !-*-coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># ! @Time     : 16:27</span></span><br><span class="line"><span class="comment"># ! @Author   :smile丶</span></span><br><span class="line"><span class="comment"># ! @File     :糗事百科爬取.py,糗事百科爬取热门段子爬取（re与requests）</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"user-agent"</span> : UserAgent().chrome</span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">"https://www.qiushibaike.com/hot/"</span></span><br><span class="line">resp = requests.get(url,headers=headers)</span><br><span class="line">resp.encoding=<span class="string">"utf-8"</span></span><br><span class="line">info = resp.text</span><br><span class="line">infos=re.findall(<span class="string">r'&lt;div class="content"&gt;\W+&lt;span&gt;\W+(.+)'</span>,info)</span><br><span class="line"><span class="comment"># 写入到文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"段子.txt"</span>,<span class="string">"a"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    index=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> infos:</span><br><span class="line">        result=re.sub(<span class="string">r'&lt;br/&gt;'</span>,<span class="string">"\n"</span>,i)</span><br><span class="line">        <span class="comment"># print(result)</span></span><br><span class="line">        f.write(<span class="string">"第"</span>+str(index)+<span class="string">"个段子：\n\n"</span>+result+<span class="string">"\n\n\n"</span>)</span><br><span class="line">        index+=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># !-*-coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># !@Time     : 17:18</span></span><br><span class="line"><span class="comment"># !@Author   :smile丶</span></span><br><span class="line"><span class="comment"># !@File     :JD商品图片爬取（selenium+xpath+多线程）</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="comment">#无头打开</span></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">"--headless"</span>)</span><br><span class="line">chrome = webdriver.Chrome(chrome_options=options)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"user-agent"</span> : UserAgent().chrome</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    chrome.get(url)</span><br><span class="line">    js = <span class="string">'document.documentElement.scrollTop=100000'</span></span><br><span class="line">    chrome.execute_script(js)</span><br><span class="line">    sleep(<span class="number">10</span>)</span><br><span class="line">    html = chrome.page_source</span><br><span class="line">    <span class="comment"># 解析</span></span><br><span class="line">    e = etree.HTML(html)</span><br><span class="line">    info = etree.tostring(e)</span><br><span class="line">    info.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(keyword,pages)</span>:</span></span><br><span class="line">    urls=Queue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,pages):</span><br><span class="line">        res = <span class="string">"https://search.jd.com/Search?keyword="</span>+keyword+<span class="string">"&amp;enc=utf-8&amp;page="</span>+str(<span class="number">2</span>*(i+<span class="number">1</span>)<span class="number">-1</span>)+<span class="string">"&amp;wq="</span>+keyword</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        urls.put(res)</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_imgs</span><span class="params">(imgs,keyword)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> imgs:</span><br><span class="line">        <span class="keyword">if</span> i != <span class="string">"done"</span>:</span><br><span class="line">            url=<span class="string">"http:"</span>+i</span><br><span class="line">            resp = requests.get(url, headers=headers)</span><br><span class="line">            result = resp.content</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"./imgs/"</span>+keyword+<span class="string">"/"</span>+str(uuid.uuid1())+<span class="string">".jpg"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(result)</span><br><span class="line">                f.close()</span><br><span class="line"><span class="comment"># 多线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">begin_go</span><span class="params">( Thread )</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,urls,keyword)</span>:</span></span><br><span class="line">        Thread.__init__(self)</span><br><span class="line">        self.urls=urls</span><br><span class="line">        self.keyword=keyword</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.urls.empty() == <span class="keyword">False</span>:</span><br><span class="line">            e = get_html(urls.get())</span><br><span class="line">            imgs1 = e.xpath(<span class="string">'//li[@class="gl-item"]/div/div[@class="p-img"]/a/img/@src'</span>)</span><br><span class="line">            imgs2 = e.xpath(<span class="string">'//li[@class="gl-item"]/div/div[@class="p-img"]/a/img/@data-lazy-img'</span>)</span><br><span class="line">            imgs = imgs1 + imgs2</span><br><span class="line">            save_imgs(imgs,keyword)</span><br><span class="line">            print(<span class="string">"爬取完成"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    keyword = input(<span class="string">"请输入搜索的商品名："</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">"./imgs/"</span>+keyword):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.mkdir(<span class="string">"./imgs/"</span>+keyword)</span><br><span class="line">    urls = get_url(keyword, <span class="number">10</span>)</span><br><span class="line">    crawl_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        crawl1 = begin_go(urls,keyword)</span><br><span class="line">        crawl_list.append(crawl1)</span><br><span class="line">        crawl1.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> crawl <span class="keyword">in</span> crawl_list:</span><br><span class="line">        crawl.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"按爬取完成，进入imgs查看结果，按CTRL+C退出吧。。。"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="linux（redhat和centos）以及它的进阶之路"><a href="#linux（redhat和centos）以及它的进阶之路" class="headerlink" title="linux（redhat和centos）以及它的进阶之路"></a>linux（redhat和centos）以及它的进阶之路</h2><p>大三上学期，我们学习了操作系统，我也从红帽竞赛的学习中对linux有了些许兴趣。后来，通过对linux的学习，我才发现linux是如此的简洁与清晰，不像windows那样，没有卸载不干净的东西，没有那么高的配置要求，简简单单，足矣！</p>
<p>下面是我简单配置的linux（基于centos）记录</p>
<p>还有一个关于linux的比赛和recha什么的证书我就不列出来了，感觉比较low。希望以后能即将linux作为我的PC的OS吧！</p>
<h2 id="java以及java进阶"><a href="#java以及java进阶" class="headerlink" title="java以及java进阶"></a>java以及java进阶</h2><p>我想我应该把大部分时间都花在了java上吧！一个学期有些水课我都在课上看java的教学视频。从java基础，到java web，再到mybatis，再到现在的maven+ssm框架以及redis的缓存技术，从sublime text3到my eclipse，再到现在的IDEA。一路走来，发现一入java深似海。</p>
<p>深入理解jvm，泛型，网络编程等等。。。仔细一看，后面还有很多的不可预知，例如nginx什么的。。。现在学无止境，就应该择优学习！</p>
<p>下面是我上传到github的简单学习的小项目</p>
<p><a href="https://github.com/sjsmi1e/springmybatis" target="_blank" rel="noopener">https://github.com/sjsmi1e/springmybatis</a></p>
<p>算法什么的我就不说了，前面有写了挺多这方面的知识，现在人工智能算法特别火，希望能在以后的学习中继续探讨更深奥的算法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一年过去了，有收获也有遗憾，希望在新的一年，我能找到一个心仪的工作，去到我心之所向的那个地方，然后能见到那个谁谁谁，有机会的话~~~</p>
<p>书山有路勤为径，学海无涯苦作舟！新的一年，新的征程，加油吧，少年！</p>
]]></content>
      <categories>
        <category>进阶之路</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>我的秋招</title>
    <url>/2019/09/21/%E5%BF%83%E5%BE%97/%E6%88%91%E7%9A%84%E7%A7%8B%E6%8B%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>经过一年的努力吧（感觉自己说努力有点不好意思O(∩_∩)O），从大三一直到这周，成功签约西安农行软开（还差学校签字返还）。特此作此总结，记录下自己的汗水。</p>
<h1 id="春招"><a href="#春招" class="headerlink" title="春招"></a>春招</h1><p>从大三下学期一开始，我就开始了校园招聘的路程，虽然那时候是春招，我大三也只能找一些实习，但是有实习岂不是很好，简历不就更好看了吗？但是啊，最后也只有以失败告终，0offer。但是也收获到了许多，比如经过的几次面试。</p>
<p>记得那是大三刚开始，因为整个宿舍（六个人）只有我和我的下铺有就业的意向，其他人都是考研。所以，我们就计划着一起开始筹备春招。当时觉得自己知识体系应该已经差不多了，所以信心满满，然而，当头棒喝。我专攻的是Java后台开发，但当有笔试传来的时候，发现出的题目竟然像是在看天书，天书，什么概念，就是有头无尾，几乎不懂的。本以为以前写过算法，参加过ACM，算法题应该不成什么大问题，然而，算法题就是最大的问题。当时就觉得自己得复习甚至是学习一波。因为当时有一些知识点是学校一起老师讲过的，因为没怎么看，也没怎么常用，所以就忘记了。</p>
<a id="more"></a>
<p>后来，经过一段时间的沉沦（暂停简历投递），学习得差不多了，又继续开始了笔试之战。终于有一次，过了三七互娱的笔试，迎来了面试。信心满满，因为我总结了在微信上看到的Java面试100题。然而问到的时候才发现，那100题背出来是没有用的，不懂原理仅仅只是知其一不知其二，面试问得尴尬的一匹，什么都不会。面完后，最多的还是以学习为主，发现以前学的Java只是皮毛，还有很多东西需要自己去掌握。然后，我就开始指定了Java学习计划：逐个知识点突破。边学习边投简历，边完成学校的各种课设。当时可以说是忙上加忙。忙归忙，在学习的时候，发现自己在白忙的样子，过了大半学期，依旧还是0offer。当时，参加培训班的同学一个个拿到了或多或少的offer，知道这个消息之后，当时就觉得自己的世界是如此的渺茫。曾经有一段时间精神是恍惚的，总觉得自己是那么的菜，曾经比自己差的同学经过培训之后，拿到了大厂offer，心里感到一阵落寞，唉😔。</p>
<p>我知道，我不能沉沦，因为家里还需要我去奋斗。想到这一点，我就提起了一点劲吧。看到web老师在群里发有谁想参加互联网+的联系她，当时我觉得自己可能还需要一个奖去丰富甚至是激励自己，所以自告奋勇地对老师说自己参加了。最重要的是，经过这个，我遇见了我的那个她。记得当时上实验课，来时问我做这个项目目前有什么难处，我就说我们没有懂经济的同学，然后，老师找来了那个她。之后和她的经历我就不多在这个学习平台浪费经历了，去看我们的信去，😄O(∩_∩)O。最后，在这说一点，有了她的陪伴，我觉得我的心不再那么迷茫，也没有了以前的空荡，心里得到了许多慰藉，感谢我的那个她，爱无限♥~~~所以，之后的下半学期，我没有在投递简历，开始了内化过程。</p>
<h1 id="暑假"><a href="#暑假" class="headerlink" title="暑假"></a>暑假</h1><p>暑假，我就开始了疯狂的训练模式，每天几乎都很有计划的样子，开始逐个击破我当时在春招总结下来的问题。早上，康康叫我起床，她去上班实习，我在宿舍复习。虽然相隔，但是依旧心连心，感觉别有一番风味。就这样，虽然枯燥无味，还挺辛苦的，但是未了将来，这点不足为惧。未了缓解压力，我们俩晚上去散心，散步，挺好的~就这样，在暑假，我完成了大部分的复习，详情请看：<a href="https://github.com/sjsmi1e/javaBaseView" target="_blank" rel="noopener">https://github.com/sjsmi1e/javaBaseView</a></p>
<p>大约在八月份的时候，准确来说是七月第，我就加入了秋招大军的队伍，开始了提前批的投递。可能提前批招的都是大佬级人物吧，我连个笔试几乎都收不到。当时有一些低落的，但是看到网上的面经，发现都是985或者211的研究生大佬的面经，我就知道，那个时间不属于我。所以，我就等待着正式的秋招。于时在八月份之后，陆陆续续我有开始了投递，也开始了笔试风波。在笔试中遨游，也在代码中穿梭。这是我这个暑假面试写的代码：<a href="https://github.com/sjsmi1e/QiuZhaoWrittenExamination" target="_blank" rel="noopener">https://github.com/sjsmi1e/QiuZhaoWrittenExamination</a>  当时觉得笔试能A出算法题，是多么的开心，是多么的欣慰，因为为了算法笔试题，我刷完了剑指offer，leetcode的DP（简单和中等难度），树，所有简单题。但是笔试过了一段时间，发现连一个面试都没有，就觉得自己时多么的无助，委屈，垃圾。曾几次的怀疑自己，到底适不适合进入中大厂。。。一直到九月份，我都没有任何面试机会，当时，真觉得我就要被毁灭了。。。</p>
<h1 id="秋招"><a href="#秋招" class="headerlink" title="秋招"></a>秋招</h1><p>我的第一份offer，是农行的offer。记得是8月中旬投的吧，去牛客搜索了一个内推。然后在八月底开始了笔试。她陪我去的，我们来到西北大学，她在食堂等我，我在里面考试。考完试，我觉得她绝对无聊透顶了，手机几乎都用到没电了，不过非常感谢她，能腾出时间来陪我，太感谢她了~所以，我就过了笔试，进入了面试环节。那天6点她叫我起床，给了我100元，冲去了面试场地。风尘仆仆来，风尘仆仆回，借来的西装也许不习惯，穿着走在街上还有点不好意思，但依旧很完美~记得面试过程中，我是5号，当前面一个个面试者站起来，说自己怎么怎么地，哇，好强啊，我什么都没有。。。到我起来自我介绍的时候，有些底气不足，也有些紧张，所以，就有那么一些不是很好。后来也就中规中矩，不过有一点，西电西交的研究生竟然连数据库的char或者varchar都不知道，可能他们不太关注数据库吧，但是他们的简历真的很强。这里不方便透露面试问题，所以就不阐述了。我面试完之后，我真担心自己过不了，其实过了好多天都没有消息，就早已经不报什么希望了。可能后来的论述或者其他什么的为我加分了吧，我竟然过了。当时收到体检通知的，当时我是如此的开心。后来体检通过了，今天签约了，就觉得过程是那么的奇幻，好像在做梦一样。从收到体检通知到昨晚，我一直都在担心，银行随时都会反悔，因为我觉得我是那么的不优秀。现在，心也就放下来了。感谢西安，感谢农行，感谢面试官，感谢康康，感谢自己！</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>在签约农行的时候，我也面试了其他几家大厂，下面把面经记录一下：</p>
<h2 id="JD"><a href="#JD" class="headerlink" title="JD"></a>JD</h2><p>因为我简历上面说掌握多线，所以一面上来就多线程</p>
<ol>
<li>创建线程的方式</li>
<li>run与start的区别</li>
<li>volite关键字怎么保证变量可见性，是线程安全的吗</li>
<li>发生死锁的情况</li>
<li>集合类举例哪些线程安全，哪些线程不安全</li>
<li>手写一种单例模式实现方式，为什么要用这种方式</li>
<li>jdk1.7以前hashtable实现线程安全的原理</li>
<li>jdk1.7concurrentHashMap 怎么实现线程安全的</li>
<li>NIO对比于BIO优势是什么</li>
<li>redis为什么能作为缓存，处理请求为什么能达到那么快（多路复用）</li>
<li>你了解什么分布式的东西（然后我回答zk）<br>zk用来干什么————分布式锁（原理是什么）</li>
<li>你用过redis做分布式锁吗，需要注意的情况有什么</li>
<li>jion与union区别</li>
<li>数据库的隔离级别</li>
<li>mysql是怎么在RR情况下解决幻读的（MVCC）</li>
<li>自己实现一个工具类，让一个对线转成JSON字符串<br>一面结束。。。</li>
</ol>
<p>二面：<br>上来就问项目上的问题，然后我项目用了websocket，说一下websocket的原理机制（答的不是很好）</p>
<ol>
<li>创建线程的方式</li>
<li>你常用的jdk包有哪些（集合包，juc），然后我说我用过线程池，他问线程池有哪几种，一般都分别用于什么场景下</li>
<li>你了解过AQS吗</li>
<li>你了解什么数据结构（然后我说的基本都知道，然后嘴贱说了红黑树，然后GG）</li>
<li>你手写一个递归函数吧</li>
<li>tcp/ip的每一层使用到的设备<br>二面结束。。。</li>
</ol>
<h2 id="科大讯飞"><a href="#科大讯飞" class="headerlink" title="科大讯飞"></a>科大讯飞</h2><p>一面</p>
<ol>
<li>list与linked的区别，优势与劣势</li>
<li>你了解排序算法吗，说一下选择排序，与冒泡排序的区别<br>挺多的，但都是些基础问题，不写了，下面写一些我没想到的</li>
<li>spring是怎么把一个类加载到自己的容器的，用到了什么方法<br>一面结束。。。<br>二面</li>
<li>你知道接口和抽象类的区别吗？什么时候用接口，什么时候用抽象类</li>
<li>如果给你两个方法名和参数列表相同，但是返回类型不同，他们是重载吗？如果不是，会发生哪些错误</li>
<li>讲一下适配器模式，在什么场景下应用</li>
<li>你了解过网络吗？为什么要有MAC地址，用IP地址不行吗</li>
<li>你们学过编译原理吗（额，怎么说，我简历上面写了。。。但是我不会）</li>
<li>然后就问一些其他方面的（你是哪的人，了解科大讯飞吗。。。等等）<br>二面结束。。。</li>
</ol>
<h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>一面</p>
<ol>
<li>run与start的区别</li>
<li>sychronized三种情况下锁定的对象是什么</li>
<li>volited的作用，原理是什么</li>
<li>计算机网络：常用的HTTP请求头有哪些</li>
<li>spring容器有哪些组件</li>
<li>spring事务传播机制</li>
<li>手写算法：括号匹配问题，写完了后（我用了stack），如何实现o（1）空间的方法</li>
<li>异常的接口，实现类（exception，error），（运行时异常，检查异常）<br>一面结束。。。</li>
</ol>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>行了，这次就写到这吧，没有什么过多的，希望接下来自己在生活中学习上加油(ง •_•)ง</p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2018暑期ccpc网络赛总结</title>
    <url>/2018/08/25/%E7%AE%97%E6%B3%95/2018%E6%9A%91%E6%9C%9Fccpc%E7%BD%91%E7%BB%9C%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从12：00到17:00，是这次网络赛的时间。我与小伙伴们约好在食堂来一场惊心动魄的脑脑裂比赛。从11:00开始准备，吃饭，预热，开始答题。</p>
<p>由于以前了解过ACM，也参加过4C，所以也有一些经验吧。只是第一次，本以为是ccpc，中国的，可以有点中文题目，没想到全是英文题，让我这样的英文渣额。。。不过还好，能读懂一些的！</p>
<p>煎熬中度过，漫度中煎熬。一些题似懂非懂，有思路，但数据范围的卡壳，导致更换思路。。。最后，受大佬启发，完成了一道</p>
<p>a^n+b^n=c^n的题目：<br><a id="more"></a></p>
<p><strong>1004 Find Integer<br>Problem<br>people in USSS love math very much, and there is a famous math problem .<br>give you two integers , ,you are required to find integers , such that + .<br>Input<br>one line contains one integer ;<br>next lines contains two integers , ; , ,<br>Output<br>print two integers , if , exits; , , ;<br>else print two integers -1 -1 instead.<br>Sample Input<br>1 2 3<br>Sample Output<br>4 5</strong></p>
<p>思路：显而易见，对于a^n+b^n=c^n，当N&gt;2时，是没有整数解的（费马大定理），所以问题主要就来到求a^2+b^2=c^2；第一次，我们用O(N)的暴力去解，发现超时，所以第一时间就想到剪枝，寻找其中规律，发现，a*b%6==0；于是，就6个6个找，再用本源勾股在进一步剪枝，a的倍数计算；但发现还是TL了。。。我的天！！！绝望。。。最后呢，有一位大佬说其实有一个公式的，所以，我去研究了一番，发现：</p>
<p><strong>题意：<br>给出直角三角形的一条边，求另外两条边。无解输出-1.<br>思路：<br>1、2无解。<br>n为偶数，(n <em> n / 4 - 1) ^ 2 + n </em> n = (n <em> n / 4 + 1) ^2<br>n为奇数，((n </em> n - 1) / 2) ^ 2 + n <em> n = ((n </em> n + 1) / 2) ^ 2</strong></p>
<p>天哪，所以，，，就所以了。最后题目还卡了一下cin与cout的输出时间限制，改成printf与scanf就ok了。</p>
<p>以下是AC代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> n,a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;a);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>);</span><br><span class="line">          <span class="comment">//  cout&lt;&lt;"-1 -1"&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a*a/<span class="number">4</span><span class="number">-1</span>,a*a/<span class="number">4</span>+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,(a*a<span class="number">-1</span>)/<span class="number">2</span>,(a*a+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a+<span class="number">1</span>,a+<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;a+1&lt;&lt;" "&lt;&lt;a+2&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面有这样一道题：</p>
<p>**1010 YJJ’s Salesman<br>Problem<br>YJJ is a salesman who has traveled through western country. YJJ is always on journey. Either is he at the destination, or on the way to destination. One day, he is going to travel from city A to southeastern city B. Let us assume that A is on the rectangle map and B . YJJ is so busy so he never turn back or go twice the same way, he will only move to east, south or southeast, which means, if YJJ is at now , he will only forward to , or . On the rectangle map from to , there are several villages scattering on the map. Villagers will do business deals with salesmen from northwestern, but not northern or western. In mathematical language, this means when there is a village on , only the one who was from to will be able to earn dollars.(YJJ may get different number of dollars from different village.) YJJ has no time to plan the path, can you help him to find maximum of dollars YJJ can get.<br>Input<br>The first line of the input contains an integer ,which is the number of test cases.<br>In each case, the first line of the input contains an integer .The following lines, the -th line contains 3 integers, , which indicate that there is a village on and he can get dollars in that village. The positions of each village is distinct.<br>Output<br>The maximum of dollars YJJ can get.<br>(0,0) ( , ) 109 109<br>(x,y) (0 ≤ x ≤ ,0 ≤ y ≤ ) 109 109 (x +1,y) (x,y +1) (x +1,y +1) (0,0) ( , ) 109 109<br>k ( , ) xk yk (1 ≤ ≤ ,1 ≤ ≤ ) xk 109 yk 109 ( −1, −1) xk yk ( , ) xk yk vk<br>T (1 ≤ T ≤ 10)<br>N (1 ≤ N ≤ ) 105 N k , , xk yk vk (0 ≤ ≤ ) vk 103 ( , ) xk yk vk<br>Sample Input<br>1 </p>
<p>3</p>
<p>1 1 1</p>
<p>1 2 2</p>
<p>3 3 1<br>Sample Output<br>3<br>**</p>
<p>一看这题目就是搜索+dp，思路简单；但看数字，1e9，开个二维数组，绝对爆内存，所以，我想到把二维压成一维去做，不知道有没有错误，代码码到一半，后面再慢慢研究一下，发AC代码。</p>
<p>总的来说，英语还有待加强，做题不够多，自然就GOOD GAME了。。。 </p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2018/08/18/%E7%AE%97%E6%B3%95/KMP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>kmp即字符串匹配，时间复杂度O(M+N)。</strong></p>
<p>核心为求匹配的字符串的next[]数组（以当前位置结束的最长前缀的位置），代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>,len=<span class="built_in">strlen</span>(str2);</span><br><span class="line">		a[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;len)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">-1</span>||str2[i]==str2[j])</span><br><span class="line">				a[++i]=++j;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				j=a[j];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>裸题：hdu1686</strong><br>查一串字符串中某个单词的出现次数。 </p>
<p>输入<br>第一行输入一个 T ，代表数据数目。</p>
<p>每组数据第一行输入需要查找的单词。</p>
<p>第二行输入这个较长的字符串（长度小于1000010）。</p>
<p>输出<br>每组数据输出一个 n ，代表要这个单词出现的次数。</p>
<p>样例输入<br>3<br>ABCD<br>ABCD<br>AZA<br>AZAZAZA<br>HIDSJ<br>FJOSJWHABNMDS<br>样例输出<br>1<br>3<br>0</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">char</span> str1[maxn],str2[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>,len=<span class="built_in">strlen</span>(str2);</span><br><span class="line">		a[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;len)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">-1</span>||str2[i]==str2[j])</span><br><span class="line">				a[++i]=++j;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				j=a[j];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">0</span>,l1=<span class="built_in">strlen</span>(str1),l2=<span class="built_in">strlen</span>(str2);</span><br><span class="line">	<span class="keyword">while</span>(i&lt;l1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>||str1[i]==str2[j])</span><br><span class="line">			i++,j++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j=a[j];</span><br><span class="line">		<span class="keyword">if</span>(j==l2)ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;str2&gt;&gt;str1;</span><br><span class="line">		getnext();</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;kmp()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>hdu2594 </strong></p>
<p>题意：<br>给两个字符串s1,s2，求最长的s1前缀匹配s2后缀的字符串，以及长度</p>
<p>输入<br>输入有多组数据。</p>
<p>每组数据有两行，分别为两个人的名字（名字全由英文组成，名字长度不超过50000）。</p>
<p>输出<br>求出前一个人的名字的前缀，与后一个人的名字的前缀，最大的相同数目。</p>
<p>若不为0，还需输出其相同的几位字母，并且字母在数字前面，中间由空格隔开。</p>
<p>样例输入<br>mike<br>aniom<br>kiava<br>dvakia<br>dasds<br>fdsgh<br>样例输出<br>m 1<br>kia 3<br>0<br><strong>思路：先把两串合并在一起，然后求next[]数组，然后判断next[]最后一位，如果长度&gt;最短串的长度，就缩进到前面（即切断过长的部分）</strong></p>
<p>代码：</p>
<p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200010</span>;</span><br><span class="line"><span class="built_in">string</span> str1,str2,str3;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>,len=str3.size();</span><br><span class="line">		a[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;len)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">-1</span>||str3[i]==str3[j])</span><br><span class="line">				a[++i]=++j;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				j=a[j];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;str2)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		str3=str1+str2;</span><br><span class="line">		<span class="keyword">int</span> lena=str1.size();</span><br><span class="line">		<span class="keyword">int</span> lenb=str2.size();</span><br><span class="line">		<span class="keyword">int</span> lenc=str3.size();</span><br><span class="line">		<span class="keyword">int</span> ab=min(lena,lenb);</span><br><span class="line">		getnext();</span><br><span class="line">		<span class="keyword">while</span>(a[lenc]&gt;ab)</span><br><span class="line">			lenc=a[lenc];</span><br><span class="line">		<span class="keyword">if</span>(a[lenc])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a[lenc];i++)</span><br><span class="line">							<span class="built_in">cout</span>&lt;&lt;str1[i];</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;a[lenc]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;a[lenc]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		str1.clear();</span><br><span class="line">		str2.clear();</span><br><span class="line">		str3.clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> hdu4763</strong><br>题意描述：给定一个字符串，找出长度最大的子串，使开始、中间、结尾至少都包含它？</p>
<p>思路：</p>
<p>从大到小枚举子串长度，先判断结尾和开始是否一样，如果一样，则使用kmp判断中间是否含有子串，如果有就是答案</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnxt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(nxt,<span class="number">-1</span>,<span class="keyword">sizeof</span>(nxt));</span><br><span class="line">    nxt[<span class="number">0</span>] = <span class="number">-1</span>; <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span>||s[i] == s[j])nxt[++i] = ++j;</span><br><span class="line">        <span class="keyword">else</span> j = nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = nxt[len<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(p&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[len<span class="number">-1</span>] == s[p])&#123;</span><br><span class="line">            st.insert(p+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p = nxt[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = nxt[i];</span><br><span class="line">        <span class="keyword">while</span>(p&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[p] &amp;&amp; st.find(p+<span class="number">1</span>)!=st.end())&#123;</span><br><span class="line">                <span class="keyword">if</span>(len - <span class="number">1</span> -p &gt; i &amp;&amp; p &lt; i-p)&#123;</span><br><span class="line">                    ans = max(ans,p+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p = nxt[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        st.clear();</span><br><span class="line">        len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        getnxt();</span><br><span class="line">        getback();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上为kmp总结例题。 </p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>dfs&amp;dfs</title>
    <url>/2018/08/06/%E7%AE%97%E6%B3%95/dfs%E4%B8%8Ebfs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>dfs（深度优先搜索）</p>
<p>bfs（广度优先搜索）</p>
<p><strong>前言</strong><br>作为初学者，可能会想，搜索吗，就是作用在图上啊，树上什么的算法。其实，搜索（这里主要说dfs和bfs），就是以一种特定方式，在大多数场景寻找真正想要结果的方式。而dfs就是以一种现已一种单一方式走到黑，然后通过回溯等得到答案的过程。而bfs则是先看有多少种方式可以走，然后先记录每一种方式，在一一按这种方式一层一层遍历，直到得到最后结果。这两种搜索大体上没什么差别，都是搜索出所有可能满足自己的答案而已。有的人可能会说，bfs适合求最短路径，dfs适合求所有答案，其实，两个都可以相互转化（这里不多说，其实我也不怎么懂，哈哈~），只不过方便与否的问题罢了。</p>
<p>下面就对这两种经典搜索进行简单探讨。<br><a id="more"></a><br>dfs（深度优先搜索）<br>模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void bfs()&#123;</span><br><span class="line">		if:(...)&#123;//需要的结果</span><br><span class="line">			...</span><br><span class="line">		//做出操作</span><br><span class="line">		return;//结束 </span><br><span class="line">		&#125; </span><br><span class="line">		...</span><br><span class="line">		dfs();</span><br><span class="line">		...//具体要怎么搜索 </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这就是走到黑方式，就像对123进行全排列，123,132,213,231,312,321；</p>
<p>按照顺序排列就是方式，然后逐个改变。</p>
<p>多说这种无益，来一道最简单的bfs的题目吧：</p>
<p>**有一款游戏叫做《绝地求生：大逃杀》。<br>绝地求生，是一款开放世界策略射击游戏，采用虚幻4引擎制作。 是一款大逃杀类型的游戏，每一局游戏将有100名玩家参与，他们将被投放在绝地岛(battlegrounds)的上空，游戏开始跳伞时所有人都一无所有。 游戏展开的方式是：玩家赤手空拳地分布在岛屿的各个角落，利用岛上多样的武器与道具。 随着时间的流逝，岛上的安全地带越来越少，特定地区也会发生轰炸的情况，最终只有一人存活获得胜利。游戏的每一局比赛都会随机转换安全区，这样玩家的很新鲜与紧张感会更加强烈。</p>
<p>小东同学玩游戏也坚决不忘算法的学习，有一天，他面临了这样的情况，小东要前往安全区，他决定冒险通过一片大平原，虽然跑向两边的山上更安全，但是时间来不及了。在小东同学奔跑的过程中，浑然不知两边的山上各有一个人趴在那里埋伏猎物，他们同时发现小东，同时开枪！小东意识到危险了！伴随了若干声枪声，砰砰砰！小东已经倒地了…</p>
<p>小东挂掉之前一秒，意识到了一件事，两边的人同时开枪，那么我又多少种中弹顺序呢？比如我有100血，而一个人用冲锋枪每发子弹能伤害我30血，另一个人用步枪每发子弹能伤害我45血，那导致我死亡的中弹顺序可能是，30 30 30 45，也可能是 45 45 30，也有可能是45 30 45，等等。当然，血量小于或等于0都算被击倒。</p>
<p>同时要注意，如果两人每次对自己造成的伤害是相同的，但仍被看作不同的死亡顺序，比如玩家有100血量，左右两边的人每次能造成50血量的伤害，那么答案为4，情况分别为：</p>
<p>50 50（左边敌人打中了两枪）。</p>
<p>50 50（右边敌人打中了两枪）</p>
<p>50 50（左边敌人开了第一枪）</p>
<p>50 50（右边敌人开了第一枪）</p>
<p>输入<br>本题有多组测试数据。每组占一行，由三个正整数m n hp组成（10=&lt;m&lt;hp&lt;90,10&lt;=n&lt;hp&lt;90）。m代表左边的敌人每次对玩家造成的伤害，n代表右边的敌人每次对玩家造成的伤害，hp代表玩家的血量。</p>
<p>输出<br>对于每组输入数据，输出一行，结果为玩家有多少种死亡顺序，即中弹顺序。</p>
<p>样例输入<br>45 30 100<br>50 50 100<br>12 23 80<br>样例输出<br>9<br>4<br>34**<br>思路：看题意是求出所有方式，所以用dfs比较方便，然后，走到黑，先以第一种方式减血（第一个例子，-45，-45，-45。。。），然后就回溯，继续操作，看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>,l,r,hp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> hp,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(hp&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">		ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(hp-l,l,r);</span><br><span class="line">	dfs(hp-r,l,r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;hp)&#123;</span><br><span class="line">		dfs(hp,l,r);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就来看bfs：</p>
<p>bfs（广度优先搜索）<br>模板：</p>
<pre><code>void bfs(){
    if(){
        return;//首先判断当前位置是否为结果 
    }
    while(){
        ...//循环每一种方试直到最后的结果 
    } 
    return ; 
}
</code></pre><p>对于bfs，用得最多的试队列，来插入（记录方法）与弹出（此方法遍历完毕）来进行搜索， 最经典的迷宫问题（求最短路径）：</p>
<p>**平面迷宫<br>时间限制: 1 Sec  内存限制: 128 MB</p>
<p>题目描述<br>老王同学深陷一个迷宫，他现在想要逃出去。迷宫 是这样的，在m行n列的矩阵当中，“.”表示可以通过的道路，“#”表示墙，是障碍物所以不能通过。迷宫中S代表起始点，E代表出口。老王每次只向上、向下、向左、向右移动一个单位距离，每次移动一个距离话费的时间是1分钟。请问老王最少花多少时间可以离开迷宫，或者根本就不能离开迷宫？</p>
<p>输入<br>本题有多组测试数据，对于每组测试数据：</p>
<p>两个整数mn表示m行n列的迷宫，0&lt;mn&lt;=100</p>
<p>接下来是m行n列的迷宫，其中S表示入口，E表示出口，#表示墙，.表示通路。</p>
<p>输出<br>如果老王逃出去话费X分钟，则输出：</p>
<p>Escaped in x minute(s).</p>
<p>如果老王不能逃出去，则输出：</p>
<p>Trapped!</p>
<p>样例输入<br>3 3<br>S..<br>.#.<br>..E</p>
<p>3 3<br>S#.<br>.#.<br>.#E<br>样例输出<br>Escaped in 4 minute(s).<br>Trapped!<br> **</p>
<p>思路也不必多说，搜索所有路径，找到最短的，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">101</span>][<span class="number">101</span>],d[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">char</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">	<span class="keyword">char</span> tq=q.front();</span><br><span class="line">	q.pop();</span><br><span class="line">	<span class="keyword">if</span>(tq==<span class="string">'E'</span>)	</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> tx=x+dir[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> ty=y+dir[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">map</span>[tx][ty]==<span class="string">'.'</span>&amp;&amp;v[tx][ty]==<span class="number">0</span>&amp;&amp;tx&gt;=<span class="number">0</span>&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=<span class="number">0</span>&amp;&amp;ty&lt;m)&#123;</span><br><span class="line">			q.push(<span class="built_in">map</span>[tx][ty]);</span><br><span class="line">			d[tx][ty]=d[x][y]+<span class="number">1</span>;</span><br><span class="line">			v[tx][ty]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">		<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">		<span class="keyword">int</span> ex,ey,sx,sy;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;<span class="built_in">map</span>[i][j];</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'S'</span>)&#123;</span><br><span class="line">					sx=i;</span><br><span class="line">					sy=j;</span><br><span class="line">					q.push(<span class="built_in">map</span>[i][j]);</span><br><span class="line">					v[i][j]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'E'</span>)&#123;</span><br><span class="line">					ex=i;</span><br><span class="line">					ey=j;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		bfs(sx,sy);</span><br><span class="line">		<span class="keyword">if</span>(d[ex][ey]==<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Trapped!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Escaped in "</span>&lt;&lt;d[ex][ey]&lt;&lt;<span class="string">" minute(s)."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能会有错哦，好久以前写的，不知道是对的还是错的，但知道方式与思路就行！</p>
<p>其实dfs与bfs都大相径庭，所以，当你用熟练了，几乎都能互用，只是代码多少的问题而已！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>判断素数与欧拉筛</title>
    <url>/2018/08/18/%E7%AE%97%E6%B3%95/%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0%E4%B8%8E%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于一个数，判断是否为素数，按照性质暴力枚举每一个，时间复杂度就是O（n），今天，不讨论这个，讨论一下更高效的方法。</p>
<p><strong>## 一、 ##</strong><br>这是我在一篇博客看到的方法，时间复杂度为O（sqr（n）/3）：</p>
<p><a href="https://blog.csdn.net/huang_miao_xin/article/details/51331710（方法3）" target="_blank" rel="noopener">https://blog.csdn.net/huang_miao_xin/article/details/51331710（方法3）</a></p>
<p>首先看一个关于质数分布的规律：大于等于5的质数一定和6的倍数相邻。例如5和7，11和13,17和19等等；</p>
<p>证明：令x≥1，将大于等于5的自然数表示如下：</p>
<p>······ 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ······<br><a id="more"></a></p>
<p>可以看到，不在6的倍数两侧，即6x两侧的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。这里有个题外话，关于孪生素数，有兴趣的道友可以再另行了解一下，由于与我们主题无关，暂且跳过。这里要注意的一点是，在6的倍数相邻两侧并不是一定就是质数。</p>
<p>此时判断质数可以6个为单元快进，即将方法（2）循环中i++步长加大为6，加快判断速度，原因是，假如要判定的数为n，则n必定是6x-1或6x+1的形式，对于循环中6i-1，6i，6i+1,6i+2，6i+3，6i+4，其中如果n能被6i，6i+2，6i+4整除，则n至少得是一个偶数，但是6x-1或6x+1的形式明显是一个奇数，故不成立；另外，如果n能被6i+3整除，则n至少能被3整除，但是6x能被3整除，故6x-1或6x+1（即n）不可能被3整除，故不成立。综上，循环中只需要考虑6i-1和6i+1的情况，即循环的步长可以定为6，每次判断循环变量k和k+2的情况即可，理论上讲整体速度应该会是方法（2）的3倍。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime_3</span><span class="params">( <span class="keyword">int</span> num )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                 <span class="comment">//两个较小数另外处理</span></span><br><span class="line">                 <span class="keyword">if</span>(num ==<span class="number">2</span>|| num==<span class="number">3</span> )</span><br><span class="line">                                 <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">                 <span class="comment">//不在6的倍数两侧的一定不是质数</span></span><br><span class="line">                 <span class="keyword">if</span>(num %<span class="number">6</span>!= <span class="number">1</span>&amp;&amp;num %<span class="number">6</span>!= <span class="number">5</span>)</span><br><span class="line">                                 <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">                 <span class="keyword">int</span> tmp =<span class="built_in">sqrt</span>( num);</span><br><span class="line">                 <span class="comment">//在6的倍数两侧的也可能不是质数</span></span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">5</span>;i &lt;=tmp; i+=<span class="number">6</span> )</span><br><span class="line">                                 <span class="keyword">if</span>(num %i== <span class="number">0</span>||num %(i+ <span class="number">2</span>)==<span class="number">0</span> )</span><br><span class="line">                                                 <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">                 <span class="comment">//排除所有，剩余的是质数</span></span><br><span class="line">                 <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、米勒拉宾素数测试"><a href="#二、米勒拉宾素数测试" class="headerlink" title="二、米勒拉宾素数测试"></a>二、米勒拉宾素数测试</h2><p>米勒拉宾素数测试可以快速测出单个数是否为素数。</p>
<p>**步骤：</p>
<p>首先判断这个数n的奇偶性</p>
<p>若为偶数仅有2是质数</p>
<p>奇数则进入测试</p>
<p>测试方法：</p>
<p>首先确定几个基底a,范围在[2,n-1]</p>
<p>因为n是奇数,所以n-1必定为偶数</p>
<p>则n-1可以表示为(2^s)*d</p>
<p>s、d分别求出来</p>
<p>设t为a^d模n的数,有如下几个约定：</p>
<p>1.若t=-1或1时则该数n可能为质数</p>
<p>2.若此时t=n-1,则该数可能为质数</p>
<p>3.d*2&gt;n-1时n必为合数</p>
<p>4.若上述皆不满足则让d*2,返回2**</p>
<p>多组测试之后就能判断是否为质数,而且错误率相当低！！</p>
<p>　　还有一篇博客：<a href="https://www.cnblogs.com/cons/p/5188910.html，说的很清楚。" target="_blank" rel="noopener">https://www.cnblogs.com/cons/p/5188910.html，说的很清楚。</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t,n,ans;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> mod)</span><span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>,a=x;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MR_prime</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span><span class="comment">//米勒拉宾</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">0</span>,d=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(n%a)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//倍数必为合数</span></span><br><span class="line">    <span class="keyword">while</span>(!(d&amp;<span class="number">1</span>))<span class="comment">//找到奇数</span></span><br><span class="line">    &#123;</span><br><span class="line">        d&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k=qpow(a,d,n);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//同余1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++,k=k*k%n) <span class="keyword">if</span>(k==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//同余-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">3</span>||n==<span class="number">7</span>||n==<span class="number">61</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(n&amp;<span class="number">1</span>)||n%<span class="number">3</span>==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//删掉大量已知情况</span></span><br><span class="line">    <span class="keyword">if</span>(MR_prime(<span class="number">2</span>,n)&amp;&amp;MR_prime(<span class="number">7</span>,n)&amp;&amp;MR_prime(<span class="number">61</span>,n)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">            <span class="keyword">if</span>(check_prime(n)) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、欧拉筛（朴素筛和埃拉托斯特尼筛的优化）"><a href="#三、欧拉筛（朴素筛和埃拉托斯特尼筛的优化）" class="headerlink" title="三、欧拉筛（朴素筛和埃拉托斯特尼筛的优化）"></a>三、欧拉筛（朴素筛和埃拉托斯特尼筛的优化）</h2><p>•从2开始枚举i，若没有被删除，则加入素数表</p>
<p>•枚举素数表的所有素数j，筛去i*j，直到枚举到某个j能整除i</p>
<p>时间复杂度为线性O（n）。</p>
<p>一般用于求一个区间的素数。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> pri[maxn];</span><br><span class="line"><span class="keyword">bool</span> ispri[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">		ispri[i]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)</span><br><span class="line">		pri[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findpri</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ispri[i])</span><br><span class="line">		&#123;</span><br><span class="line">			pri[j++]=i;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i*pri[k]&gt;=maxn)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			ispri[i*pri[k]]=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[k]==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>判断素数</tag>
      </tags>
  </entry>
  <entry>
    <title>分治与归并</title>
    <url>/2018/08/09/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E4%B8%8E%E5%BD%92%E5%B9%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。</p>
<p>求出子问题的解，就可得到原问题的解。就像前面的我说过的二分查找，也有类似的思想。</p>
<p>其实，学习中也有许多类似的问题可以用到分治与归并，快排与归并排序就是这样。<br><a id="more"></a><br>下里面容我记录一下我昨天下午敲的快排与归并的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//快排 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickshort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> st=l,ed=r;</span><br><span class="line">	<span class="keyword">if</span>(st&gt;=ed)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> temp=arr[l];</span><br><span class="line">	<span class="keyword">while</span>(st&lt;ed)&#123;</span><br><span class="line">		<span class="keyword">while</span>(st&lt;ed&amp;&amp;arr[ed]&gt;=temp)&#123;</span><br><span class="line">			ed--;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[st]=arr[ed];</span><br><span class="line">		<span class="keyword">while</span>(st&lt;ed&amp;&amp;arr[st]&lt;=temp)&#123;</span><br><span class="line">			st++;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[ed]=arr[st];</span><br><span class="line">	&#125;</span><br><span class="line">	arr[st]=temp;</span><br><span class="line">	quickshort(arr,l,st<span class="number">-1</span>);</span><br><span class="line">	quickshort(arr,st+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入要排序数的个数：(不大于1000)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入要排序的数："</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">	quickshort(arr,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序后的数："</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="comment">//归并 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> beg,<span class="keyword">int</span> mid,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(end&lt;=beg)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> beg1=beg,beg2=mid,a[end-beg];</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(beg1&lt;mid&amp;&amp;beg2&lt;end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[beg1]&lt;=arr[beg2])</span><br><span class="line">			a[i++]=arr[beg1++];</span><br><span class="line">		<span class="keyword">if</span>(arr[beg1]&gt;arr[beg2])</span><br><span class="line">			a[i++]=arr[beg2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(beg1&lt;mid)&#123;</span><br><span class="line">		a[i++]=arr[beg1++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(beg2&lt;end)&#123;</span><br><span class="line">		a[i++]=arr[beg2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(arr+beg,a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">order</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> length=<span class="number">1</span>;length&lt;=n;length*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> beg=<span class="number">0</span>,mid=beg+length,end=mid+length;</span><br><span class="line">		<span class="keyword">for</span>(;beg&lt;n;beg+=end,mid=beg+length,end=mid+length)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mid&gt;n)</span><br><span class="line">				mid=n;</span><br><span class="line">			<span class="keyword">if</span>(end&gt;n)</span><br><span class="line">				end=n;</span><br><span class="line">			merge(beg,mid,end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入要排序数的个数：(不大于1000)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入要排序的数："</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">	order(n);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"排序后的数："</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下里接入正题，分治与归并能解决的问题。</p>
<p>**逆序对<br>定义：</p>
<p>设 A 为一个有 n 个数字的有序集 (n&gt;1)，其中所有数字各不相同。</p>
<p>如果存在正整数 i, j 使得 1 ≤ i &lt; j ≤ n 而且 A[i] &gt; A[j]，则 &lt;A[i], A[j]&gt; 这个有序对称为 A 的一个逆序对，也称作逆序数。**</p>
<p>求的时候呢，具体思路是</p>
<p>在归并的过程中计算每个小区间的逆序对数，进而计算出大区间的逆序对数</p>
<p>代码入下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000</span>],l[<span class="number">10000</span>],r[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> ll,<span class="keyword">int</span> mid,<span class="keyword">int</span> rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">0</span>,n=<span class="number">0</span>,i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=ll;i&lt;=mid;i++)</span><br><span class="line">        l[m++]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(i=mid+<span class="number">1</span>;i&lt;=rr;i++)</span><br><span class="line">        r[n++]=a[i];</span><br><span class="line">    i=j=<span class="number">0</span>;</span><br><span class="line">    k=ll;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m&amp;&amp;j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i]&lt;=r[j])</span><br><span class="line">            a[k++]=l[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[k++]=r[j++];</span><br><span class="line">            t+=m-i;<span class="comment">//小区间逆序个数 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m)</span><br><span class="line">        a[k++]=l[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;n)</span><br><span class="line">        a[k++]=r[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        mergesort(l,mid);</span><br><span class="line">        mergesort(mid+<span class="number">1</span>,r);</span><br><span class="line">        cmp(l,mid,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        mergesort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> HUD1394</strong><br>Minimum Inversion Number<br>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 6743    Accepted Submission(s): 4112</p>
<p>Problem Description</p>
<p>The inversion number of a given number sequence a1, a2, …, an is the number of pairs (ai, aj) that satisfy i &lt; j and ai &gt; aj.</p>
<p>For a given sequence of numbers a1, a2, …, an, if we move the first m &gt;= 0 numbers to the end of the seqence, we will obtain another sequence. There are totally n such sequences as the following:</p>
<p>a1, a2, …, an-1, an (where m = 0 - the initial seqence)<br>a2, a3, …, an, a1 (where m = 1)<br>a3, a4, …, an, a1, a2 (where m = 2)<br>…<br>an, a1, a2, …, an-1 (where m = n-1)</p>
<p>You are asked to write a program to find the minimum inversion number out of the above sequences.</p>
<p>Input</p>
<p>The input consists of a number of test cases. Each case consists of two lines: the first line contains a positive integer n (n &lt;= 5000); the next line contains a permutation of the n integers from 0 to n-1.</p>
<p>Output</p>
<p>For each case, output the minimum inversion number on a single line.</p>
<p>Sample Input</p>
<p>10 1 3 6 9 0 8 5 7 4 2</p>
<p>Sample Output</p>
<p>16</p>
<p>题意：</p>
<p>一个由0..n-1组成的序列，每次可以把队首的元素移到队尾，<br>          求形成的n个序列中最小逆序对数目</p>
<p>超时思路：刚开始我以为会挺简单，就直接枚举每一次移动新序列的逆序对数取最小就行，可是这样做肯定会超时，我提交的时候就想到了（哈哈哈，勇于尝试）。</p>
<p>AC思路：如果求出第一种情况的逆序列，其他的可以通过递推来搞出来，一开始是t[1],t[2],t[3]….t[N]</p>
<p>它的逆序列个数是N个，如果把t[1]放到t[N]后面，逆序列个数会减少t[1]个，相应会增加N-(t[1]+1)个  </p>
<p>例如：0123 逆序对数：0</p>
<pre><code>1230 逆序对数：0-0+4-（0+1）=3

2301逆序对数：3-1+4-（1+1）=4

......
</code></pre><p>注意，这道题是从0~n的序列才有这种推论。</p>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5000</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],temp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> beg,<span class="keyword">int</span> mid,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(end&lt;=beg)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> beg1=beg,beg2=mid,i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(beg1&lt;mid&amp;&amp;beg2&lt;end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b[beg1]&lt;=b[beg2])&#123;</span><br><span class="line">			temp[i++]=b[beg1++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			temp[i++]=b[beg2++];</span><br><span class="line">			cnt+=mid-beg1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">while</span>(beg1&lt;mid)</span><br><span class="line">			temp[i++]=b[beg1++];</span><br><span class="line">		<span class="keyword">while</span>(beg2&lt;end)</span><br><span class="line">			temp[i++]=b[beg2++];</span><br><span class="line">	<span class="built_in">memcpy</span>(b+beg,temp,<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (end-beg));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">order</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> length=<span class="number">1</span>;length&lt;=n;length*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> beg=<span class="number">0</span>,mid=beg+length,end=mid+length;beg&lt;n;beg=end,mid=beg+length,end=mid+length)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mid&gt;n)</span><br><span class="line">				mid=n;</span><br><span class="line">			<span class="keyword">if</span>(end&gt;n)</span><br><span class="line">				end=n;</span><br><span class="line">			merge(beg,mid,end);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		b[i]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">int</span> tcnt=<span class="number">999999999</span>;<span class="comment">//这个9必须多，第一次我提交9写少了，WA了。所以，以后用0x3f3f3f吧 </span></span><br><span class="line">	order(n);</span><br><span class="line">	tcnt=min(tcnt,cnt);	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt = cnt - a[i] + n - <span class="number">1</span> - a[i];</span><br><span class="line">            tcnt=min(tcnt,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;tcnt&lt;&lt;<span class="built_in">endl</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最大和连续子序列问题：</strong><br>给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个， </p>
<p>例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和 为20。<br>要求编写程序得到最大和。</p>
<p>这种题解法很多，这里主要说一下分治解法：</p>
<p>直接看代码：</p>
<p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">MaximumSubarray</span>&#123;</span></span><br><span class="line">	    <span class="keyword">int</span> low;</span><br><span class="line">	    <span class="keyword">int</span> high;</span><br><span class="line">	    <span class="keyword">int</span> sum;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function">MaximumSubarray <span class="title">findMaxCrossingSubarr</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> left_sum=<span class="number">0x80000000</span>;<span class="comment">//最小负数</span></span><br><span class="line">	    <span class="keyword">int</span> right_sum=<span class="number">0x80000000</span>;<span class="comment">//最小负数</span></span><br><span class="line">	    <span class="keyword">int</span> max_left=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">int</span> max_right=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	    MaximumSubarray maxSubarr=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&gt;=low;--i)&#123;</span><br><span class="line">        sum+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;left_sum)&#123;</span><br><span class="line">            left_sum=sum;</span><br><span class="line">            max_left=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=high;++i)&#123;</span><br><span class="line">        sum+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;right_sum)&#123;</span><br><span class="line">            right_sum=sum;</span><br><span class="line">            max_right=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxSubarr.low=max_left;</span><br><span class="line">    maxSubarr.high=max_right;</span><br><span class="line">    maxSubarr.sum=left_sum+right_sum;</span><br><span class="line">    <span class="keyword">return</span> maxSubarr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/***********************************</span></span><br><span class="line"><span class="comment">func:求给定数组的最大子数组</span></span><br><span class="line"><span class="comment">para:A:数组;low:左下标;high:右下标</span></span><br><span class="line"><span class="comment">***********************************/</span></span><br><span class="line"><span class="function">MaximumSubarray <span class="title">findMaxSubarr</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    MaximumSubarray maxSubarrLeft=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    MaximumSubarray maxSubarrRight=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    MaximumSubarray maxSubarrCross=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(high==low)&#123;          <span class="comment">//特殊情况：只有一个元素</span></span><br><span class="line">        maxSubarrLeft.low=low;</span><br><span class="line">        maxSubarrLeft.high=high;</span><br><span class="line">        maxSubarrLeft.sum=A[low];</span><br><span class="line">        <span class="keyword">return</span> maxSubarrLeft;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    maxSubarrLeft=findMaxSubarr(A,low,mid);</span><br><span class="line">    maxSubarrRight=findMaxSubarr(A,mid+<span class="number">1</span>,high);</span><br><span class="line">    maxSubarrCross=findMaxCrossingSubarr(A,low,mid,high);</span><br><span class="line">    <span class="keyword">if</span>(maxSubarrLeft.sum&gt;maxSubarrRight.sum&amp;&amp;maxSubarrLeft.sum&gt;maxSubarrCross.sum)</span><br><span class="line">        <span class="keyword">return</span> maxSubarrLeft;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(maxSubarrRight.sum&gt;maxSubarrLeft.sum&amp;&amp; maxSubarrRight.sum&gt;maxSubarrCross.sum)</span><br><span class="line">        <span class="keyword">return</span> maxSubarrRight;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> maxSubarrCross;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,arr[<span class="number">100000</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>;i&lt;n;j++,i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">			arr[j]=arr[i]-arr[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;arr[i]&lt;&lt;" ";</span></span><br><span class="line">	MaximumSubarray resMaxSubarr=findMaxSubarr(arr,<span class="number">0</span>,n<span class="number">-2</span>);</span><br><span class="line"> <span class="comment">//   cout&lt;&lt;"maximum subarray is:"&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;resMaxSubarr.low&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;resMaxSubarr.high&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;resMaxSubarr.sum&lt;&lt;<span class="built_in">endl</span>;	</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 以上是我关于分治与归并的总结！！！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>周末之ACM之旅：焦作网络赛与青岛网络赛</title>
    <url>/2018/09/16/%E7%AE%97%E6%B3%95/%E5%91%A8%E6%9C%AB%E4%B9%8BACM%E4%B9%8B%E6%97%85%EF%BC%9A%E7%84%A6%E4%BD%9C%E7%BD%91%E7%BB%9C%E8%B5%9B%E4%B8%8E%E9%9D%92%E5%B2%9B%E7%BD%91%E7%BB%9C%E8%B5%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h1><p>  这两天呢，几乎赖床般的，十点半左右起床，然后做好准备，拿好电脑，走向创客，和伙伴讨论，解题。也不知是没睡好还是怎么的，五点做完题后是特别的困，打英雄联盟都能连跪的（也不排除楼下的奥斯卡影帝的给与吧），脑力消耗，几万亿个脑细胞就这样莫得了。。。天是阴沉，也是凉爽，“空山新雨后，天气晚来秋！”啊。<br><a id="more"></a></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="ACM-ICPC-2018-焦作赛区网络预赛"><a href="#ACM-ICPC-2018-焦作赛区网络预赛" class="headerlink" title="ACM-ICPC 2018 焦作赛区网络预赛"></a>ACM-ICPC 2018 焦作赛区网络预赛</h2><h3 id="Mathematical-Curse"><a href="#Mathematical-Curse" class="headerlink" title="Mathematical Curse"></a>Mathematical Curse</h3><p>B. Mathematical Curse<br>A prince of the Science Continent was imprisoned in a castle because of his contempt for mathematics when he was young, and was entangled in some mathematical curses. He studied hard until he reached adulthood and decided to use his knowledge to escape the castle.</p>
<p>There are NN rooms from the place where he was imprisoned to the exit of the castle. In the i^{th}ith room, there is a wizard who has a resentment value of a[i]a[i]. The prince has MM curses, the j^{th}jth curse is f[j]f[j], and f[j]f[j] represents one of the four arithmetic operations, namely addition(‘+’), subtraction(‘-‘), multiplication(‘*’), and integer division(‘/‘). The prince’s initial resentment value is KK. Entering a room and fighting with the wizard will eliminate a curse, but the prince’s resentment value will become the result of the arithmetic operation f[j]f[j] with the wizard’s resentment value. That is, if the prince eliminates the j^{th}jth curse in the i^{th}ith room, then his resentment value will change from xx to (x\ f[j]\ a[i]x f[j] a[i]), for example, when x=1, a[i]=2, f[j]=x=1,a[i]=2,f[j]=’+’, then xx will become 1+2=31+2=3.</p>
<p>Before the prince escapes from the castle, he must eliminate all the curses. He must go from a[1]a[1] to a[N]a[N] in order and cannot turn back. He must also eliminate the f[1]f[1] to f[M]f[M] curses in order(It is guaranteed that N\ge MN≥M). What is the maximum resentment value that the prince may have when he leaves the castle?</p>
<p>Input<br>The first line contains an integer T(1 \le T \le 1000)T(1≤T≤1000), which is the number of test cases.</p>
<p>For each test case, the first line contains three non-zero integers: N(1 \le N \le 1000), M(1 \le M \le 5)N(1≤N≤1000),M(1≤M≤5) and K(-1000 \le K \le 1000K(−1000≤K≤1000), the second line contains NN non-zero integers: a[1], a[2], …, a<a href="-1000 \le a[i] \le 1000">N</a>a[1],a[2],…,a<a href="−1000≤a[i]≤1000">N</a>, and the third line contains MM characters: f[1], f[2], …, f[M](f[j] =f[1],f[2],…,f[M](f[j]=’+’,’-‘,’*’,’/‘, with no spaces in between.</p>
<p>Output<br>For each test case, output one line containing a single integer.</p>
<p>样例输入复制</p>
<p>3<br>2 1 5<br>2 3<br>/<br>3 2 1<br>1 2 3<br>++<br>4 4 5<br>1 2 3 4<br>+-*/<br>样例输出复制</p>
<p>2<br>6<br>3</p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>在给定的N个数中依次使用M个运算符，初始值为K，求最大值。</p>
<h4 id="题解（学习一位大神的题解）："><a href="#题解（学习一位大神的题解）：" class="headerlink" title="题解（学习一位大神的题解）："></a>题解（学习一位大神的题解）：</h4><p>动态规划，设状态dp[i][j]表示取前i个数，j个字符时能获得的最值（最大和最小值都要维护）</p>
<p>设mul(dp,i,j)表示之前的结果为dp，第i个数字第j个运算符运算后的结果</p>
<p>有转移方程：</p>
<p>dpmax[i][j]=max(dpmax[i-1][j]，mul(dpmax[i-1][j-1],i,j)，mul(dpmin[i-1][j-1],i,j))</p>
<p>//别忘了负数乘以负数可能会转移到最大值。最小值同理。</p>
<p>dpmin同上（详见代码）</p>
<p>边界自然是</p>
<p>dpmax=-inf</p>
<p>dpmin=inf</p>
<p>dp[i][0]=k</p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dpmin[<span class="number">1005</span>][<span class="number">10</span>];</span><br><span class="line">ll dpmax[<span class="number">1005</span>][<span class="number">10</span>];</span><br><span class="line">ll <span class="keyword">const</span> inf=<span class="number">0x3f3f3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> numb[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll v,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(s[j])&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:<span class="keyword">return</span> v+numb[i];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:<span class="keyword">return</span> v-numb[i];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:<span class="keyword">return</span> v*numb[i];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:<span class="keyword">return</span> v/numb[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,numb+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dpmax[i][j]=-inf;</span><br><span class="line">                dpmin[i][j]=inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dpmin[<span class="number">0</span>][<span class="number">0</span>]=dpmax[<span class="number">0</span>][<span class="number">0</span>]=k;</span><br><span class="line">        getchar();</span><br><span class="line">        gets(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dpmin[i][<span class="number">0</span>]=k;</span><br><span class="line">            dpmax[i][<span class="number">0</span>]=k;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                dpmin[i][j]=dpmin[i<span class="number">-1</span>][j]; </span><br><span class="line">                dpmax[i][j]=dpmax[i<span class="number">-1</span>][j]; </span><br><span class="line">                <span class="keyword">if</span>(dpmax[i<span class="number">-1</span>][j<span class="number">-1</span>]!=-inf)</span><br><span class="line">                    dpmax[i][j]=max(dpmax[i][j],mul(dpmax[i<span class="number">-1</span>][j<span class="number">-1</span>],i,j));</span><br><span class="line">                <span class="keyword">if</span>(dpmin[i<span class="number">-1</span>][j<span class="number">-1</span>]!=inf)</span><br><span class="line">                    dpmax[i][j]=max(dpmax[i][j],mul(dpmin[i<span class="number">-1</span>][j<span class="number">-1</span>],i,j));</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span>(dpmin[i<span class="number">-1</span>][j<span class="number">-1</span>]!=inf)</span><br><span class="line">                    dpmin[i][j]=min(dpmin[i][j],mul(dpmin[i<span class="number">-1</span>][j<span class="number">-1</span>],i,j));    </span><br><span class="line">                <span class="keyword">if</span>(dpmax[i<span class="number">-1</span>][j<span class="number">-1</span>]!=-inf)</span><br><span class="line">                    dpmin[i][j]=min(dpmin[i][j],mul(dpmax[i<span class="number">-1</span>][j<span class="number">-1</span>],i,j));</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dpmax[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Give-Candies"><a href="#Give-Candies" class="headerlink" title="Give Candies"></a>Give Candies</h3><p>There are N children in kindergarten. Miss Li bought them N candies. To make the process more interesting, Miss Li comes up with the rule: All the children line up according to their student number (1…N), and each time a child is invited, Miss Li randomly gives him some candies (at least one). The process goes on until there is no candy. Miss Li wants to know how many possible different distribution results are there.</p>
<p>Input<br>The first line contains an integer T, the number of test case.</p>
<p>The next TT lines, each contains an integer N.</p>
<p>1≤T≤100</p>
<p>1≤N≤10^100000</p>
<p>Output<br>For each test case output the number of possible results (mod 1000000007).</p>
<p>样例输入复制</p>
<p>1<br>4<br>样例输出复制</p>
<p>8</p>
<h4 id="题目大意-："><a href="#题目大意-：" class="headerlink" title="题目大意 ："></a>题目大意 ：</h4><p>一个老师买了N个苹果分给N位同学（这N个同学编了不同的号码），问一共有多少种分发？</p>
<h4 id="题解-："><a href="#题解-：" class="headerlink" title="题解 ："></a>题解 ：</h4><p>很容易发现答案就是2^n-1，但是，N有10^100000，会发现快速幂也会超时。所以，就有费马小定理，如下：</p>
<p>ans=2^(n-1)%mod=2^((n-1)%(mod-1)+(n-1)/(mod-1)<em>(mod-1))%mod=2^((n-1)%(mod-1))%mod</em>2^((n-1)/(mod-1)*(mod-1))%mod=2^((n-1)%(mod-1))%mod</p>
<h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ipow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) num = (num*<span class="number">10</span>+(s[i]-<span class="string">'0'</span>))%(mod<span class="number">-1</span>);</span><br><span class="line">        num = (num<span class="number">-1</span>+mod<span class="number">-1</span>) % (mod<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ipow(<span class="number">2</span>, num) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Save-the-Room"><a href="#Save-the-Room" class="headerlink" title="Save the Room"></a>Save the Room</h3><p>Bob is a sorcerer. He lives in a cuboid room which has a length of A, a width of B and a height of C, so we represent it as A <em> B </em> C. One day, he finds that his room is filled with unknown dark energy. Bob wants to neutralize all the dark energy in his room with his light magic. He can summon a 1 <em> 1 </em> 2 cuboid at a time to neutralize dark energy. But the cuboid must be totally in dark energy to take effect. Can you foresee whether Bob can save his room or not?</p>
<p>Input<br>Input has T test cases. T≤100</p>
<p>For each line, there are three integers A, B, C</p>
<p>1≤A,B,C≤100</p>
<p>Output<br>For each test case, if Bob can save his room, print”Yes”, otherwise print”No”.</p>
<p>样例输入复制</p>
<p>1 1 2<br>1 1 4<br>1 1 1<br>样例输出复制</p>
<p>Yes<br>Yes<br>No</p>
<h4 id="题目大意-：-1"><a href="#题目大意-：-1" class="headerlink" title="题目大意 ："></a>题目大意 ：</h4><p>给一个方体的长宽高，填入1<em>1</em>2的小方体，问能否填满</p>
<h4 id="题解-：-1"><a href="#题解-：-1" class="headerlink" title="题解 ："></a>题解 ：</h4><p>感觉有点水，也不水（哈哈~），应该一会就能发现答案就是 a<em>b</em>c%2=0就YES</p>
<h4 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("test.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.in","w+",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> A, B, C;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B&gt;&gt;C)</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(A%<span class="number">2</span>==<span class="number">0</span>||B%<span class="number">2</span>==<span class="number">0</span>||C%<span class="number">2</span>==<span class="number">0</span>)  flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest-Online"><a href="#The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest-Online" class="headerlink" title="The 2018 ACM-ICPC Asia Qingdao Regional Contest, Online"></a>The 2018 ACM-ICPC Asia Qingdao Regional Contest, Online</h2><h3 id="XOR-Clique"><a href="#XOR-Clique" class="headerlink" title="XOR Clique"></a>XOR Clique</h3><p>BaoBao has a sequence a​1​​,a​2​​,…,a​n​​. He would like to find a subset S of {1,2,…,n} such that ∀i,j∈S, a​i​​⊕a​j​​&lt;min(a​i​​,a​j​​) and ∣S∣ is maximum, where ⊕ means bitwise exclusive or.</p>
<p>Input</p>
<p>There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:</p>
<p>The first line contains an integer n (1≤n≤10​5​​), indicating the length of the sequence.</p>
<p>The second line contains n integers: a​1​​,a​2​​,…,a​n​​ (1≤a​i​​≤10​9​​), indicating the sequence.</p>
<p>It is guaranteed that the sum of n in all cases does not exceed 10​5​​.</p>
<p>Output</p>
<p>For each test case, output an integer denoting the maximum size of S.</p>
<p>Sample Input</p>
<p>3<br>3<br>1 2 3<br>3<br>1 1 1<br>5<br>1 2323 534 534 5<br>Sample Output</p>
<p>2<br>3<br>2</p>
<h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>给N个数，从中选取一些书作为集合S，并且 ∀i,j∈S, a​i​​⊕a​j​​&lt;min(a​i​​,a​j​​)，求max（|S|）。</p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>思路应该比较简单，就是求这N个数里面2进制最高位位数有数时对应范围的数的个数谁最多，例如最高第三位有数，则100~111，最高第二位有数时，10~11；</p>
<h4 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tj=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tflag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if(a[i]==1&amp;&amp;i==1)</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            if(a[i]==1&amp;&amp;a[i-1]==1)&#123;</span></span><br><span class="line"><span class="comment">                tflag++;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(a[i]==1&amp;&amp;a[i+1]!=1)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                flag=max(flag,tflag);</span></span><br><span class="line"><span class="comment">                tflag=0;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pow</span>(<span class="number">2</span>,tj)&lt;=a[i])</span><br><span class="line">           &#123;        </span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                       &#123;</span><br><span class="line">                            tj++;</span><br><span class="line">                           <span class="keyword">if</span>(<span class="built_in">pow</span>(<span class="number">2</span>,tj)&gt;a[i])</span><br><span class="line">                           &#123;</span><br><span class="line">                               flag=max(flag,tflag);</span><br><span class="line">                               tflag=<span class="number">0</span>;</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;<span class="built_in">pow</span>(<span class="number">2</span>,tj))&#123;</span><br><span class="line">                tflag++;</span><br><span class="line">               <span class="comment">//cout&lt;&lt;tflag&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        flag=max(tflag,flag);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;flag&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Halting-Problem"><a href="#Halting-Problem" class="headerlink" title="Halting Problem"></a>Halting Problem</h3><p>In computability theory, the halting problem is the problem of determining, from a description of an arbitrary computer program, whether the program will finish running (i.e., halt) or continue to run forever.</p>
<p>Alan Turing proved in 1936 that a general algorithm to solve the halting problem cannot exist, but DreamGrid, our beloved algorithm scientist, declares that he has just found a solution to the halting problem in a specific programming language – the Dream Language!</p>
<p>Dream Language is a programming language consists of only 5 types of instructions. All these instructions will read from or write to a 8-bit register r, whose value is initially set to 0. We now present the 5 types of instructions in the following table. Note that we denote the current instruction as the i-th instruction.</p>
<p>Instruction    Description<br>add v    Add v to the register r. As r is a 8-bit register, this instruction actually calculates (r+v)mod256 and stores the result into r, i.e. r←(r+v)mod256. After that, go on to the (i+1)-th instruction.<br>beq v k    If the value of r is equal to v, jump to the k-th instruction, otherwise go on to the (i+1)-th instruction.<br>bne v k    If the value of r isn’t equal to v, jump to the k-th instruction, otherwise go on to the (i+1)-th instruction.<br>blt v k    If the value of r is strictly smaller than v, jump to the k-th instruction, otherwise go on to the (i+1)-th instruction.<br>bgt v k    If the value of r is strictly larger than v, jump to the k-th instruction, otherwise go on to the (i+1)-th instruction.<br>A Dream Language program consisting of n instructions will always start executing from the 1st instruction, and will only halt (that is to say, stop executing) when the program tries to go on to the (n+1)-th instruction.</p>
<p>As DreamGrid’s assistant, in order to help him win the Turing Award, you are asked to write a program to determine whether a given Dream Language program will eventually halt or not.</p>
<p>Input</p>
<p>There are multiple test cases. The first line of the input is an integer T, indicating the number of test cases. For each test case:</p>
<p>The first line contains an integer n (1≤n≤10​4​​), indicating the number of instructions in the following Dream Language program.</p>
<p>For the following n lines, the i-th line first contains a string s (s∈{“add”,“beq”,“bne”,“blt”,“bgt”}), indicating the type of the i-th instruction of the program.</p>
<p>If s equals to “add”, an integer v follows (0≤v≤255), indicating the value added to the register;<br>Otherwise, two integers v and k follow (0≤v≤255, 1≤k≤n), indicating the condition value and the destination of the jump.<br>It’s guaranteed that the sum of n of all test cases will not exceed 10​5​​.</p>
<p>Output</p>
<p>For each test case output one line. If the program will eventually halt, output “Yes” (without quotes); If the program will continue to run forever, output “No” (without quotes).</p>
<p>Sample Input</p>
<p>4<br>2<br>add 1<br>blt 5 1<br>3<br>add 252<br>add 1<br>bgt 252 2<br>2<br>add 2<br>bne 7 1<br>3<br>add 1<br>bne 252 1<br>beq 252 1<br>Sample Output</p>
<p>Yes<br>Yes<br>No<br>No<br>Hint</p>
<p>For the second sample test case, note that r is a 8-bit register, so after four “add 1” instructions the value of r will change from 252 to 0, and the program will halt.</p>
<p>For the third sample test case, it’s easy to discover that the value of r will always be even, so it’s impossible for the value of r to be equal to 7, and the program will run forever.</p>
<h4 id="题意：-1"><a href="#题意：-1" class="headerlink" title="题意："></a>题意：</h4><p>就是一般的模拟，然后判断是否为无限循环或者不是无限循环</p>
<h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><p>就是用一个二维数组记录下是否经过这一步，经过则为无限循环。</p>
<h4 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> llong;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> p, v, k;</span><br><span class="line">&#125; node;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> book[MAXN][<span class="number">260</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t, n, i, r, sgn;</span><br><span class="line">	<span class="keyword">char</span> str[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">int</span> p, v, k;</span><br><span class="line">	node a[MAXN];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">if</span>(str[<span class="number">1</span>] == <span class="string">'d'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">				getchar();</span><br><span class="line">				p = <span class="number">1</span>;</span><br><span class="line">				a[i] = (node)&#123;p, v, k&#125;;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v, &amp;k);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">if</span>(str[<span class="number">1</span>] == <span class="string">'e'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">1</span>] == <span class="string">'n'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p = <span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">1</span>] == <span class="string">'l'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p = <span class="number">4</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">1</span>] == <span class="string">'g'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p = <span class="number">5</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			a[i] = (node)&#123;p, v, k&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(book, <span class="literal">false</span>, <span class="keyword">sizeof</span>(book));</span><br><span class="line">		i = <span class="number">1</span>; r = <span class="number">0</span>;</span><br><span class="line">		book[i][r] = <span class="literal">true</span>;</span><br><span class="line">		sgn = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">		&#123;</span><br><span class="line">			p = a[i].p;</span><br><span class="line">			v = a[i].v;</span><br><span class="line">			k = a[i].k;</span><br><span class="line">			<span class="keyword">if</span>(p == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				r += k;</span><br><span class="line">				r %= <span class="number">256</span>;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				i = (r == v) ? k : i + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				i = (r != v) ? k : i + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="number">4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				i = (r &lt; v) ? k : i + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="number">5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				i = (r &gt; v) ? k : i + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(book[i][r] == <span class="literal">true</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sgn = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			book[i][r] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sgn == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Live-Love"><a href="#Live-Love" class="headerlink" title="Live Love"></a>Live Love</h3><p>DreamGrid is playing the music game Live Love. He has just finished a song consisting of nnotes and got a result sequence A​1​​,A​2​​,…,A​n​​ (A​i​​∈ {PERFECT, NON-PERFECT}). The score of the song is equal to the max-combo of the result sequence, which is defined as the maximum number of continuous PERFECTs in the sequence.</p>
<p>Formally speaking, max-combo(A)=max { k | k is an integer and there exists an integer i (1≤i≤n−k+1) such that A​i​​=A​i+1​​=A​i+2​​=…=A​i+k−1​​= PERFECT }. For completeness, we define max(∅)=0.</p>
<p>As DreamGrid is forgetful, he forgets the result sequence immediately after finishing the song. All he knows is the sequence length n and the total number of PERFECTs in the sequence, indicated by m. Any possible score s he may get must satisfy that there exists a sequence A​′​​ of length n containing exactly m PERFECTs and (n−m) NON-PERFECTs and max-combo(A​′​​)=s. Now he needs your help to find the maximum and minimum samong all possible scores.</p>
<p>Input</p>
<p>There are multiple test cases. The first line of the input contains an integer T (1≤T≤100), indicating the number of test cases. For each test case:</p>
<p>The only line contains two integers n and m (1≤n≤10​3​​, 0≤m≤10​3​​, m≤n), indicating the sequence length and the number of PERFECTs DreamGrid gets.</p>
<p>Output</p>
<p>For each test case output one line containing two integers s​max​​ and s​min​​, indicating the maximum and minimum possible score.</p>
<p>Sample Input</p>
<p>5<br>5 4<br>100 50<br>252 52<br>3 0<br>10 10<br>Sample Output</p>
<p>4 2<br>50 1<br>52 1<br>0 0<br>10 10<br>Hint</p>
<p>Let’s indicate a PERFECT as P and a NON-PERFECT as N.</p>
<p>For the first sample test case, the sequence (P,P,P,P,N) leads to the maximum score and the sequence (P,P,N,P,P) leads to the minimum score.</p>
<h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><p>这题是我队友做的，感觉也比较简单，直接上代码了。</p>
<h4 id="AC代码：-4"><a href="#AC代码：-4" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="keyword">int</span> nc = n - m + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,m,n/nc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>真的有时候发现就是孰能生巧，当题目出来，有点思路的时候刷新看下解题情况（也就2-3分吧），哇，就有AC了，天哪！所以说，做得多就是一种好处，像小儿科一样。还有就是啊，明明“Halting Problem”就是无解，还出这个，弄得我晕头转向额，壳卡在输出这的代码BUG，调了快半把个小时，心累！不过，也是一种有趣的体验，图灵啊图灵，图灵机。。。。。。为我以后助我一臂之力吧！！！<br>学无止境，继续前行。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心+二分</title>
    <url>/2018/08/07/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83-%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在刷题时，总会遇到求最大值最小，最小值最大问题，也许它会暗喻是这样的一个问题。对于这样的一个问题，你会发现用dp和枚举都会超时超内存，或者说很麻烦，所以这是一个比较简单的解题方式。</p>
<p>二分逼近思想<br>•对于难以直接确定解的问题,采取二分枚举+检验的思想.<br><a id="more"></a><br>•已知解为x,验证x是否满足要求.</p>
<p>•如果答案具有特定的范围，并且验证答案是否成立的函数具有单调性。则可以在范围内对答案进行二分验证，从而快速确定答案。</p>
<p> 对于答案判断：<br>在二分答案的时候需要判断，从而确定下一个范围。</p>
<p>可以用一个bool Check(x)函数来判断，返回true表示满足,返回false表示不满足.</p>
<p>可以类比数学函数f(x)&gt;=0和f(x)&lt;0来理解.</p>
<p>根据具体问题写出相应的Check函数往往就是解决问题的关键点。</p>
<p>下面举例一些问题：</p>
<p><strong>poj2456</strong><br>Aggressive cows</p>
<p>Time Limit: 1000MS         Memory Limit: 65536K<br>Total Submissions: 13139         Accepted: 6399</p>
<p>Description</p>
<p>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000). </p>
<p>His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?</p>
<p>Input</p>
<ul>
<li><p>Line 1: Two space-separated integers: N and C </p>
</li>
<li><p>Lines 2..N+1: Line i+1 contains an integer stall location, xi</p>
</li>
</ul>
<p>Output</p>
<ul>
<li>Line 1: One integer: the largest minimum distance</li>
</ul>
<p>Sample Input</p>
<p>5 3<br>1<br>2<br>8<br>4<br>9<br>Sample Output</p>
<p>3<br>Hint</p>
<p>OUTPUT DETAILS: </p>
<p>FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3. </p>
<p>Huge input data,scanf is recommended.</p>
<p>Source</p>
<p>USACO 2005 February Gold</p>
<p>2.题意概述：</p>
<p>农夫有c头牛，n个隔间，c头牛很躁动，很容易相互打架，因此农夫想把它们分得越远越好，要你分配隔间使得相邻两头牛的距离越远越好，问你这c头牛分割的最小距离的最大值。</p>
<p>3.解题思路： </p>
<p>先对隔间的坐标排序，对于牛，最小距离是0，最大距离不会超过两端两头牛的距离值，因此二分地查找分割距离的最大值，每次mid都judge一次，judge的时候贪心地放置牛，保证前i头牛是符合这样分割标准的。</p>
<p>AC代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">int</span> n,k,t;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> next,last=<span class="number">0</span>,k=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;t;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-a[last]&gt;=d)&#123;</span><br><span class="line">			k++;</span><br><span class="line">			last=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;=n)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	sort(a,a+t);</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=a[t<span class="number">-1</span>],mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fun(mid))&#123;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			r=mid<span class="number">-1</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<p><strong>poj1505 </strong><br>Copying Books</p>
<p>Time Limit: 3000MS         Memory Limit: 10000K<br>Total Submissions: 9632         Accepted: 3013<br>Description</p>
<p>Before the invention of book-printing, it was very hard to make a copy of a book. All the contents had to be re-written by hand by so called scribers. The scriber had been given a book and after several months he finished its copy. One of the most famous scribers lived in the 15th century and his name was Xaverius Endricus Remius Ontius Xendrianus (Xerox). Anyway, the work was very annoying and boring. And the only way to speed it up was to hire more scribers. </p>
<p>Once upon a time, there was a theater ensemble that wanted to play famous Antique Tragedies. The scripts of these plays were divided into many books and actors needed more copies of them, of course. So they hired many scribers to make copies of these books. Imagine you have m books (numbered 1, 2 … m) that may have different number of pages (p1, p2 … pm) and you want to make one copy of each of them. Your task is to divide these books among k scribes, k &lt;= m. Each book can be assigned to a single scriber only, and every scriber must get a continuous sequence of books. That means, there exists an increasing succession of numbers 0 = b0 &lt; b1 &lt; b2, … &lt; bk-1 &lt;= bk = m such that i-th scriber gets a sequence of books with numbers between bi-1+1 and bi. The time needed to make a copy of all the books is determined by the scriber who was assigned the most work. Therefore, our goal is to minimize the maximum number of pages assigned to a single scriber. Your task is to find the optimal assignment. </p>
<p>Input</p>
<p>The input consists of N cases. The first line of the input contains only positive integer N. Then follow the cases. Each case consists of exactly two lines. At the first line, there are two integers m and k, 1 &lt;= k &lt;= m &lt;= 500. At the second line, there are integers p1, p2, … pm separated by spaces. All these values are positive and less than 10000000.</p>
<p>Output</p>
<p>For each case, print exactly one line. The line must contain the input succession p1, p2, … pm divided into exactly k parts such that the maximum sum of a single part should be as small as possible. Use the slash character (‘/‘) to separate the parts. There must be exactly one space character between any two successive numbers and between the number and the slash. </p>
<p>If there is more than one solution, print the one that minimizes the work assigned to the first scriber, then to the second scriber etc. But each scriber must be assigned at least one book.</p>
<p>Sample Input</p>
<p>2<br>9 3<br>100 200 300 400 500 600 700 800 900<br>5 4<br>100 100 100 100 100<br>Sample Output</p>
<p>100 200 300 400 500 / 600 700 / 800 900<br>100 / 100 / 100 / 100 100</p>
<p>题意：按顺序给你N个数，将这N个数分成连续的M段，使得这M段每段的和中的最大值最小，输出最小值（1&lt;=N&lt;=100000,1&lt;=M&lt;=N,每个数在1到10000之间），如果有多种可能的话，尽量在前面进行划分。（其实第一次读题还不知道是什么意思，仔细琢磨才明白是这样的一个问题）</p>
<p>首先以正常的思路去考虑优化这个最大值的最小化问题，好像会陷入到循环之中找不到解决的思路，但是我们如果采用猜测－判断－重来的方法不断的去尝试二分查找最大值的最小值，然后去判断这个值是否合法，进一步优化这个值，就可以解决。</p>
<p>ac代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">501</span>];</span><br><span class="line"><span class="keyword">int</span> t,m,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yes_no</span><span class="params">(<span class="keyword">int</span> dis,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last=<span class="number">0</span>,next=<span class="number">0</span>,tsum=a[last],cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(next&lt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(tsum&lt;=dis)&#123;</span><br><span class="line">			next++;</span><br><span class="line">			tsum=tsum+a[next];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tsum&gt;dis)&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			last=next;</span><br><span class="line">			tsum=a[last];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">if</span>(cnt&gt;flag)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(cnt==flag)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>,ans;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">			sum+=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">0</span>,r=sum,mid;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;mid&lt;&lt;endl;	</span></span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(yes_no(mid,n)==<span class="number">2</span>)&#123;</span><br><span class="line">				l=mid+<span class="number">1</span>;</span><br><span class="line">				<span class="comment">//cout&lt;&lt;"1";</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(yes_no(mid,n)==<span class="number">1</span>)&#123;</span><br><span class="line">				ans=mid;</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				r=mid<span class="number">-1</span>;</span><br><span class="line">			<span class="comment">//	cout&lt;&lt;"2";</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">int</span> tsum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> tn=n<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">			tsum+=a[i];</span><br><span class="line">			<span class="keyword">if</span>(tsum&gt;=ans&amp;&amp;tn)&#123;</span><br><span class="line">				tn--;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">" /"</span>;</span><br><span class="line">				tsum=a[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;a[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;a[i];				</span><br><span class="line">		&#125;	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是这两题，是基本的贪心+二分的求法。 </p>
<p><strong>注意：二分是在排序好的基础上进行的查找，所以，看清题目，尽量先排好序。。。</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心+二分</tag>
      </tags>
  </entry>
  <entry>
    <title>链式前向星（静态邻接表）存储图及简单的最短路径（dijkstra+spfa）</title>
    <url>/2018/08/29/%E7%AE%97%E6%B3%95/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%EF%BC%88%E9%9D%99%E6%80%81%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89%E5%AD%98%E5%82%A8%E5%9B%BE%E5%8F%8A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88dijkstra-spfa%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>链式前向星，也叫静态邻接表，今天我讲的是关于图的东西，所以都以图的角度去看待这个较优化的存储结构。</p>
<h1 id="存图优缺点"><a href="#存图优缺点" class="headerlink" title="存图优缺点"></a>存图优缺点</h1><p>存图的时候，链式前向星是一种介于邻接矩阵和和邻接表的一种存储结构。</p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>存图一般都用这个呀！不过啊，当遇到稀疏图的时候，顶点特别多，而边就那么几条，空间浪费必然很大，所以我们又想到了邻接表</p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>邻接表（未优化过的链式前向星）是最常用存储结构之一。 但是 vector(动态数组) 的时间效率较低 (较普通数组而言)。</p>
<p>所以，链式前向星也就因运而生。链式前向星是介于 邻接矩阵 和 邻接表 之间比较均衡的一种数据结构。</p>
<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>先来看一下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链式前向星的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;<span class="comment">//边指向的终点</span></span><br><span class="line">    <span class="keyword">int</span> next;<span class="comment">//下一条边的存储下标</span></span><br><span class="line">    <span class="keyword">int</span> w;<span class="comment">//权值</span></span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="comment">//增边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;<span class="comment">//需初始化cnt=0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个列子：</p>
<figure class="image-box">
                <img src="https://img-blog.csdn.net/20131123160056593" alt="" title="" class="">
                <p></p>
            </figure>
<p>这是我拿别人家博客的图片的哦，希望不要介意呀！</p>
<p>对于这样一个图，我们进行增边操作；</p>
<p>1.首先，cnt初始化，可以是0，也可以是一，看你个人喜好。head[]数组初始化，可以是0也可以是1.</p>
<p>2.调用函数增边：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//n代表边数</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;<span class="comment">//u是起始点，v是这条边的终点，w是权值</span></span><br><span class="line">      add_edge(u,v,w);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>例如上图，就是输入（我这里没权值，直接忽略吧）：</p>
<p>1 2 </p>
<p>2 3</p>
<p>3 4</p>
<p>1 3</p>
<p>4 1</p>
<p>1 5</p>
<p>4 5</p>
<p>这样就建成了一张链式前向星的图。</p>
<p>其他相信大家都好理解，就是 edge[].next=head[]  这个比较模糊，其实就是存的是以 i 为起点，连接着 i 的顶点编号的最大编号所在的边数，就如上图（按输入顺序编号），1-&gt;2（第0条边）,1-&gt;3（第3条边）,1-&gt;5（第5条边）,而edge[5].next=3;edge[3].next=0;所以在遍历的时候，就相当于倒着遍历，就有这样的语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">       ...</span><br><span class="line">&#125;<span class="comment">//u是起点（当前节点）</span></span><br></pre></td></tr></table></figure>
<p>有了这样一个邻接表的基础，那么对于图的最大经典问题，最短路，在这样的存储结构下又有什么不一样呢。看下面代码：</p>
<h2 id="dijsktra"><a href="#dijsktra" class="headerlink" title="dijsktra"></a>dijsktra</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆优化的最短路</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; P;<span class="comment">//存编号与距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//s为起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt; P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d,inf,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="comment">//memset(vis,0,sizeof(vis));</span></span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(P(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        P p=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u=p.second;</span><br><span class="line">        <span class="keyword">if</span>(d[u]&lt;p.first)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+edge[i].w)&#123;</span><br><span class="line">                d[v]=d[u]+edge[i].w;</span><br><span class="line">                q.push(P(d[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是用了堆优化（priority_queue）后的dijkstra模板，最主要的思想就是松弛到不能再松弛位置， 然后遍历的过程就是松弛过程。可能对于一些题目， priority_queue&lt; P,vector</p><p>,greater</p><p> &gt; q;中的 greater 会有一些超时，重载运算符也是一种解决办法。复杂度：</p>
<p>O((V+E)lgV)</p>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[maxn];<span class="comment">//记录最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[maxn];<span class="comment">//判断是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//可以计算含负权的图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,inf,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span> &gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开始遍历松弛</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+edge[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                d[v]=d[u]+edge[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    vis[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有觉得这个非常像，就是相差了vis[]这样一个数组判断，而这也就是差别，vis[]在SPFA就是判断当前点是否在队列中，从而进行松弛操作，还有就是vis[]还能判断图中是否有“负权环”（当vis[]&gt;n， 就表示有环）。</p>
<p>复杂度：O(kE)O(kE)。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>如果是稠密图，Dijkstra+heap比SPFA快。稀疏图则SPFA更快。SPFA可以有SLF和LLL两种优化，SLF就是d比队头小就插入队头，否则插入队尾。</p>
<p> 全部代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//链式前向星的存储结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;<span class="comment">//边指向的终点</span></span><br><span class="line">    <span class="keyword">int</span> next;<span class="comment">//下一条边的存储下标</span></span><br><span class="line">    <span class="keyword">int</span> w;<span class="comment">//权值</span></span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="comment">//增边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;<span class="comment">//需初始化cnt=0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d[maxn];<span class="comment">//记录最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[maxn];<span class="comment">//判断是否在队列中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void SPFA(int s)//可以计算含负权的图</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    memset(d,inf,sizeof(d));</span></span><br><span class="line"><span class="comment">    memset(vis,0,sizeof(vis));</span></span><br><span class="line"><span class="comment">    queue&lt;int &gt; q;</span></span><br><span class="line"><span class="comment">    q.push(s);</span></span><br><span class="line"><span class="comment">    vis[s]=1;</span></span><br><span class="line"><span class="comment">    d[s]=0;</span></span><br><span class="line"><span class="comment">    while(!q.empty())</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int u=q.front();</span></span><br><span class="line"><span class="comment">        q.pop();</span></span><br><span class="line"><span class="comment">        vis[u]=0;</span></span><br><span class="line"><span class="comment">        //开始遍历松弛</span></span><br><span class="line"><span class="comment">        for(int i=head[u];i!=-1;i=edge[i].next)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int v=edge[i].to;</span></span><br><span class="line"><span class="comment">            if(d[v]&gt;d[u]+edge[i].w)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                d[v]=d[u]+edge[i].w;</span></span><br><span class="line"><span class="comment">                if(!vis[v])</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    q.push(v);</span></span><br><span class="line"><span class="comment">                    vis[v]=1;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//堆优化的最短路</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; P;<span class="comment">//存编号与距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//s为起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt; P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d,inf,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="comment">//memset(vis,0,sizeof(vis));</span></span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(P(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        P p=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u=p.second;</span><br><span class="line">        <span class="keyword">if</span>(d[u]&lt;p.first)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+edge[i].w)&#123;</span><br><span class="line">                d[v]=d[u]+edge[i].w;</span><br><span class="line">                q.push(P(d[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;<span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//边数</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add_edge(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//SPFA(1);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;d[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>对于inf这个定义，0x7fffffff和0x3f3f3f3f这两个也是一个大坑，</p>
<p>很多人可能设为0x7fffffff,这个数的确是32-bit int的最大值，符号位为0，其他的都是1</p>
<p>但在很多情况下，0x7fffffff会出现错误，比如溢出，这样两个无穷大数相加会变成负数，还有如在做dijkstra求最短路时，当做松弛操作，判断if (d[u]+w[u][v]&lt;d[v]) d[v]=d[u]+w[u][v]时，若u到v没有路劲，w[u][v]=0x7fffffff，这样d[u]+w[u][v]会变成负数，这就产生了错误。</p>
<p>所以，memset(d,0x3f,sizeof(d));</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>30 分钟学会如何使用 Shiro</title>
    <url>/2020/05/17/java/30-%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Shiro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文作者：冷豪；<a href="www.cnblogs.com/learnhow/p/5694876.html">原文地址</a></p>
</blockquote>
<h1 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a><strong>一、架构</strong></h1><p>要学习如何使用Shiro必须先从它的架构谈起，作为一款安全框架Shiro的设计相当精妙。Shiro的应用不依赖任何容器，它也可以在JavaSE下使用。但是最常用的环境还是JavaEE。下面以用户登录为例：</p>
<p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640.webp" alt="img"></p>
<a id="more"></a>
<h2 id="1、使用用户的登录信息创建令牌"><a href="#1、使用用户的登录信息创建令牌" class="headerlink" title="1、使用用户的登录信息创建令牌"></a><strong>1、使用用户的登录信息创建令牌</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br></pre></td></tr></table></figure>
<p>token可以理解为用户令牌，登录的过程被抽象为Shiro验证令牌是否具有合法身份以及相关权限。</p>
<h2 id="2、执行登陆动作"><a href="#2、执行登陆动作" class="headerlink" title="2、执行登陆动作"></a><strong>2、执行登陆动作</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecurityUtils.setSecurityManager(securityManager); <span class="comment">// 注入SecurityManager</span></span><br><span class="line">Subject subject = SecurityUtils.getSubject(); <span class="comment">// 获取Subject单例对象</span></span><br><span class="line">subject.login(token); <span class="comment">// 登陆</span></span><br></pre></td></tr></table></figure>
<p>Shiro的核心部分是SecurityManager，它负责安全认证与授权。Shiro本身已经实现了所有的细节，用户可以完全把它当做一个黑盒来使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。</p>
<p>Subject是初学者比较难于理解的对象，很多人以为它可以等同于User，其实不然。Subject中文翻译：项目，而正确的理解也恰恰如此。它是你目前所设计的需要通过Shiro保护的项目的一个抽象概念。通过令牌（token）与项目（subject）的登陆（login）关系，Shiro保证了项目整体的安全。</p>
<h2 id="3、判断用户"><a href="#3、判断用户" class="headerlink" title="3、判断用户"></a><strong>3、判断用户</strong></h2><p>Shiro本身无法知道所持有令牌的用户是否合法，因为除了项目的设计人员恐怕谁都无法得知。因此Realm是整个框架中为数不多的必须由设计者自行实现的模块，当然Shiro提供了多种实现的途径，本文只介绍最常见也最重要的一种实现方式——数据库查询。</p>
<h2 id="4、两条重要的英文"><a href="#4、两条重要的英文" class="headerlink" title="4、两条重要的英文"></a><strong>4、两条重要的英文</strong></h2><p>我在学习Shiro的过程中遇到的第一个障碍就是这两个对象的英文名称：AuthorizationInfo，AuthenticationInfo。不用怀疑自己的眼睛，它们确实长的很像，不但长的像，就连意思都十分近似。</p>
<p>在解释它们前首先必须要描述一下Shiro对于安全用户的界定：和大多数操作系统一样。用户具有角色和权限两种最基本的属性。例如，我的Windows登陆名称是learnhow，它的角色是administrator，而administrator具有所有系统权限。这样learnhow自然就拥有了所有系统权限。那么其他人需要登录我的电脑怎么办，我可以开放一个guest角色，任何无法提供正确用户名与密码的未知用户都可以通过guest来登录，而系统对于guest角色开放的权限极其有限。</p>
<p>同理，Shiro对用户的约束也采用了这样的方式。AuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合。如此一来，当设计人员对项目中的某一个url路径设置了只允许某个角色或具有某种权限才可以访问的控制约束的时候，Shiro就可以通过以上两个对象来判断。说到这里，大家可能还比较困惑。先不要着急，继续往后看就自然会明白了。</p>
<h1 id="二、实现Realm"><a href="#二、实现Realm" class="headerlink" title="二、实现Realm"></a><strong>二、实现Realm</strong></h1><p>如何实现Realm是本文的重头戏，也是比较费事的部分。这里大家会接触到几个新鲜的概念：缓存机制、散列算法、加密算法。由于本文不会专门介绍这些概念，所以这里仅仅抛砖引玉的谈几点，能帮助大家更好的理解Shiro即可。</p>
<h2 id="1、缓存机制"><a href="#1、缓存机制" class="headerlink" title="1、缓存机制"></a><strong>1、缓存机制</strong></h2><p>Ehcache是很多Java项目中使用的缓存框架，Hibernate就是其中之一。它的本质就是将原本只能存储在内存中的数据通过算法保存到硬盘上，再根据需求依次取出。你可以把Ehcache理解为一个Map&lt;String,Object&gt;对象，通过put保存对象，再通过get取回对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;ehcache name=&quot;shirocache&quot;&gt;</span><br><span class="line">   &lt;diskStore path=&quot;java.io.tmpdir&quot; /&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;cache name=&quot;passwordRetryCache&quot;</span><br><span class="line">          maxEntriesLocalHeap=&quot;2000&quot;</span><br><span class="line">          eternal=&quot;false&quot;</span><br><span class="line">          timeToIdleSeconds=&quot;1800&quot;</span><br><span class="line">          timeToLiveSeconds=&quot;0&quot;</span><br><span class="line">          overflowToDisk=&quot;false&quot;</span><br><span class="line">          statistics=&quot;true&quot;&gt;</span><br><span class="line">   &lt;/cache&gt;</span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure>
<p>以上是ehcache.xml文件的基础配置，timeToLiveSeconds为缓存的最大生存时间，timeToIdleSeconds为缓存的最大空闲时间，当eternal为false时ttl和tti才可以生效。更多配置的含义大家可以去网上查询。</p>
<h2 id="2、散列算法与加密算法"><a href="#2、散列算法与加密算法" class="headerlink" title="2、散列算法与加密算法"></a><strong>2、散列算法与加密算法</strong></h2><p>md5是本文会使用的散列算法，加密算法本文不会涉及。散列和加密本质上都是将一个Object变成一串无意义的字符串，不同点是经过散列的对象无法复原，是一个单向的过程。例如，对密码的加密通常就是使用散列算法，因此用户如果忘记密码只能通过修改而无法获取原始密码。但是对于信息的加密则是正规的加密算法，经过加密的信息是可以通过秘钥解密和还原。</p>
<h2 id="3、用户注册"><a href="#3、用户注册" class="headerlink" title="3、用户注册"></a><strong>3、用户注册</strong></h2><p>请注意，虽然我们一直在谈论用户登录的安全性问题，但是说到用户登录首先就是用户注册。如何保证用户注册的信息不丢失，不泄密也是项目设计的重点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordHelper</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> RandomNumberGenerator randomNumberGenerator = <span class="keyword">new</span> SecureRandomNumberGenerator();</span><br><span class="line">   <span class="keyword">private</span> String algorithmName = <span class="string">"md5"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashIterations = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encryptPassword</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// User对象包含最基本的字段Username和Password</span></span><br><span class="line">       user.setSalt(randomNumberGenerator.nextBytes().toHex());</span><br><span class="line">       <span class="comment">// 将用户的注册密码经过散列算法替换成一个不可逆的新密码保存进数据，散列过程使用了盐</span></span><br><span class="line">       String newPassword = <span class="keyword">new</span> SimpleHash(algorithmName, user.getPassword(),</span><br><span class="line">               ByteSource.Util.bytes(user.getCredentialsSalt()), hashIterations).toHex();</span><br><span class="line">       user.setPassword(newPassword);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不清楚什么叫加盐可以忽略散列的过程，只要明白存储在数据库中的密码是根据户注册时填写的密码所产生的一个新字符串就可以了。经过散列后的密码替换用户注册时的密码，然后将User保存进数据库。剩下的工作就丢给UserService来处理。</p>
<p>那么这样就带来了一个新问题，既然散列算法是无法复原的，当用户登录的时候使用当初注册时的密码，我们又应该如何判断？答案就是需要对用户密码再次以相同的算法散列运算一次，再同数据库中保存的字符串比较。</p>
<h2 id="4、匹配"><a href="#4、匹配" class="headerlink" title="4、匹配"></a><strong>4、匹配</strong></h2><p>CredentialsMatcher是一个接口，功能就是用来匹配用户登录使用的令牌和数据库中保存的用户信息是否匹配。当然它的功能不仅如此。本文要介绍的是这个接口的一个实现类：HashedCredentialsMatcher</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryLimitHashedCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title">HashedCredentialsMatcher</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 声明一个缓存接口，这个接口是Shiro缓存管理的一部分，它的具体实现可以通过外部容器注入</span></span><br><span class="line">   <span class="keyword">private</span> Cache&lt;String, AtomicInteger&gt; passwordRetryCache;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RetryLimitHashedCredentialsMatcher</span><span class="params">(CacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">       passwordRetryCache = cacheManager.getCache(<span class="string">"passwordRetryCache"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> </span>&#123;</span><br><span class="line">       String username = (String) token.getPrincipal();</span><br><span class="line">       AtomicInteger retryCount = passwordRetryCache.get(username);</span><br><span class="line">       <span class="keyword">if</span> (retryCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">           retryCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">           passwordRetryCache.put(username, retryCount);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 自定义一个验证过程：当用户连续输入密码错误5次以上禁止用户登录一段时间</span></span><br><span class="line">       <span class="keyword">if</span> (retryCount.incrementAndGet() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ExcessiveAttemptsException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">boolean</span> match = <span class="keyword">super</span>.doCredentialsMatch(token, info);</span><br><span class="line">       <span class="keyword">if</span> (match) &#123;</span><br><span class="line">           passwordRetryCache.remove(username);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> match;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个实现里设计人员仅仅是增加了一个不允许连续错误登录的判断。真正匹配的过程还是交给它的直接父类去完成。连续登录错误的判断依靠Ehcache缓存来实现。显然match返回true为匹配成功。</p>
<h2 id="5、获取用户的角色和权限信息"><a href="#5、获取用户的角色和权限信息" class="headerlink" title="5、获取用户的角色和权限信息"></a><strong>5、获取用户的角色和权限信息</strong></h2><p>说了这么多才到我们的重点Realm，如果你已经理解了Shiro对于用户匹配和注册加密的全过程，真正理解Realm的实现反而比较简单。我们还得回到上文提及的两个非常类似的对象AuthorizationInfo和AuthenticationInfo。因为Realm就是提供这两个对象的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 用户对应的角色信息与权限信息都保存在数据库中，通过UserService获取数据</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供用户信息返回权限信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">       String username = (String) principals.getPrimaryPrincipal();</span><br><span class="line">       SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">       <span class="comment">// 根据用户名查询当前用户拥有的角色</span></span><br><span class="line">       Set&lt;Role&gt; roles = userService.findRoles(username);</span><br><span class="line">       Set&lt;String&gt; roleNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">           roleNames.add(role.getRole());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将角色名称提供给info</span></span><br><span class="line">       authorizationInfo.setRoles(roleNames);</span><br><span class="line">       <span class="comment">// 根据用户名查询当前用户权限</span></span><br><span class="line">       Set&lt;Permission&gt; permissions = userService.findPermissions(username);</span><br><span class="line">       Set&lt;String&gt; permissionNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Permission permission : permissions) &#123;</span><br><span class="line">           permissionNames.add(permission.getPermission());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将权限名称提供给info</span></span><br><span class="line">       authorizationInfo.setStringPermissions(permissionNames);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供账户信息返回认证信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">       String username = (String) token.getPrincipal();</span><br><span class="line">       User user = userService.findByUsername(username);</span><br><span class="line">       <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 用户名不存在抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (user.getLocked() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 用户被管理员锁定抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> LockedAccountException();</span><br><span class="line">       &#125;</span><br><span class="line">       SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(user.getUsername(),</span><br><span class="line">               user.getPassword(), ByteSource.Util.bytes(user.getCredentialsSalt()), getName());</span><br><span class="line">       <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据Shiro的设计思路，用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多。在数据库中需要因此建立5张表，分别是：</p>
<p>用户表（存储用户名，密码，盐等）</p>
<p>角色表（角色名称，相关描述等）</p>
<p>权限表（权限名称，相关描述等）</p>
<p>用户-角色对应中间表（以用户ID和角色ID作为联合主键）</p>
<p>角色-权限对应中间表（以角色ID和权限ID作为联合主键）</p>
<p>具体dao与service的实现本文不提供。总之结论就是，Shiro需要根据用户名和密码首先判断登录的用户是否合法，然后再对合法用户授权。而这个过程就是Realm的实现过程。</p>
<h2 id="6、会话"><a href="#6、会话" class="headerlink" title="6、会话"></a><strong>6、会话</strong></h2><p>用户的一次登录即为一次会话，Shiro也可以代替Tomcat等容器管理会话。目的是当用户停留在某个页面长时间无动作的时候，再次对任何链接的访问都会被重定向到登录页面要求重新输入用户名和密码而不需要程序员在Servlet中不停的判断Session中是否包含User对象。</p>
<p>启用Shiro会话管理的另一个用途是可以针对不同的模块采取不同的会话处理。以淘宝为例，用户注册淘宝以后可以选择记住用户名和密码。之后再次访问就无需登陆。但是如果你要访问支付宝或购物车等链接依然需要用户确认身份。当然，Shiro也可以创建使用容器提供的Session最为实现。</p>
<h1 id="三、与SpringMVC集成"><a href="#三、与SpringMVC集成" class="headerlink" title="三、与SpringMVC集成"></a><strong>三、与SpringMVC集成</strong></h1><p>有了注册模块和Realm模块的支持，下面就是如何与SpringMVC集成开发。有过框架集成经验的同学一定知道，所谓的集成基本都是一堆xml文件的配置，Shiro也不例外。</p>
<h2 id="1、配置前端过滤器"><a href="#1、配置前端过滤器" class="headerlink" title="1、配置前端过滤器"></a><strong>1、配置前端过滤器</strong></h2><p>先说一个题外话，Filter是过滤器，interceptor是拦截器。前者基于回调函数实现，必须依靠容器支持。因为需要容器装配好整条FilterChain并逐个调用。后者基于代理实现，属于AOP的范畴。</p>
<p>如果希望在WEB环境中使用Shiro必须首先在web.xml文件中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Shiro_Project<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.Log4jConfigListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 将Shiro的配置文件交给Spring监听器初始化 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring.xml,classpath:spring-shiro-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfigLoaction<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:log4j.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- shiro配置 开始 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- shiro配置 结束 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>熟悉Spring配置的同学可以重点看有绿字注释的部分，这里是使Shiro生效的关键。由于项目通过Spring管理，因此所有的配置原则上都是交给Spring。DelegatingFilterProxy的功能是通知Spring将所有的Filter交给ShiroFilter管理。</p>
<p>接着在classpath路径下配置spring-shiro-web.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">                       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">                       http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">                       http://www.springframework.org/schema/context/spring-context-3.1.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">                       http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">                       http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 缓存管理器 使用Ehcache实现 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.cache.ehcache.EhCacheManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerConfigFile"</span> <span class="attr">value</span>=<span class="string">"classpath:ehcache.xml"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 凭证匹配器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">class</span>=<span class="string">"utils.RetryLimitHashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashAlgorithmName"</span> <span class="attr">value</span>=<span class="string">"md5"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashIterations"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"storedCredentialsHexEncoded"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- Realm实现 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userRealm"</span> <span class="attr">class</span>=<span class="string">"utils.UserRealm"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">ref</span>=<span class="string">"credentialsMatcher"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"userRealm"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- Shiro的Web过滤器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">               /authc/admin = roles[admin]</span><br><span class="line">               /authc/** = authc</span><br><span class="line">               /** = anon</span><br><span class="line">           <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意filterChainDefinitions过滤器中对于路径的配置是有顺序的，当找到匹配的条目之后容器不会再继续寻找。因此带有通配符的路径要放在后面。三条配置的含义是：</p>
<p> /authc/admin需要用户有用admin权限</p>
<p>/authc/**用户必须登录才能访问</p>
<p>/**其他所有路径任何人都可以访问</p>
<p>说了这么多，大家一定关心在Spring中引入Shiro之后到底如何编写登录代码呢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>&#123;</span><br><span class="line">       UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           subject.login(token);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">           <span class="comment">// 捕获密码错误异常</span></span><br><span class="line">           ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">           mv.addObject(<span class="string">"message"</span>, <span class="string">"password error!"</span>);</span><br><span class="line">           <span class="keyword">return</span> mv;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">           <span class="comment">// 捕获未知用户名异常</span></span><br><span class="line">           ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">           mv.addObject(<span class="string">"message"</span>, <span class="string">"username error!"</span>);</span><br><span class="line">           <span class="keyword">return</span> mv;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ExcessiveAttemptsException eae) &#123;</span><br><span class="line">           <span class="comment">// 捕获错误登录过多的异常</span></span><br><span class="line">           ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">           mv.addObject(<span class="string">"message"</span>, <span class="string">"times error"</span>);</span><br><span class="line">           <span class="keyword">return</span> mv;</span><br><span class="line">       &#125;</span><br><span class="line">       User user = userService.findByUsername(username);</span><br><span class="line">       subject.getSession().setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"success"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>登录完成以后，当前用户信息被保存进Session。这个Session是通过Shiro管理的会话对象，要获取依然必须通过Shiro。传统的Session中不存在User对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"authc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthcController</span> </span>&#123;</span><br><span class="line">   <span class="comment">// /authc/** = authc 任何通过表单登录的用户都可以访问</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"anyuser"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">anyuser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       User user = (User) subject.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">       System.out.println(user);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"inner"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// /authc/admin = user[admin] 只有具备admin角色的用户才可以访问，否则请求将被重定向至登录界面</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"admin"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       User user = (User) subject.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">       System.out.println(user);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"inner"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本篇内容大多总结自张开涛的《跟我学Shiro》原文地址：</p>
<p><a href="http://jinnianshilongnian.iteye.com/blog/2018936" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/2018936</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>shiro</tag>
        <tag>安全</tag>
      </tags>
  </entry>
</search>
