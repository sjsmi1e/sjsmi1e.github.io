<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MY STUDY BLOG</title>
  
  <subtitle>喜欢争取，得到珍惜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sjsmile.cn/"/>
  <updated>2021-01-24T08:33:30.101Z</updated>
  <id>http://www.sjsmile.cn/</id>
  
  <author>
    <name>Smile</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>盘点：35 个 Java 代码优化魔鬼细节</title>
    <link href="http://www.sjsmile.cn/2021/01/24/java/%E7%9B%98%E7%82%B9%EF%BC%9A35-%E4%B8%AA-Java-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E9%AD%94%E9%AC%BC%E7%BB%86%E8%8A%82/"/>
    <id>http://www.sjsmile.cn/2021/01/24/java/%E7%9B%98%E7%82%B9%EF%BC%9A35-%E4%B8%AA-Java-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E9%AD%94%E9%AC%BC%E7%BB%86%E8%8A%82/</id>
    <published>2021-01-24T07:25:01.000Z</published>
    <updated>2021-01-24T08:33:30.101Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>前言</strong></p><p>代码 优化 ，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。</p><p>代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。</p><p><strong>代码优化的目标是：</strong></p><p>减小代码的体积</p><p>提高代码运行的效率</p><p>代码优化细节</p><a id="more"></a><p><strong>1、尽量指定类、方法的final修饰符</strong></p><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50% 。</p><p><strong>2、尽量重用对象</strong></p><p>特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><p><strong>3、尽可能使用局部变量</strong></p><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p><p><strong>4、及时关闭流</strong></p><p>Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。如果条件允许，即JDK7以上，强烈建议使用try-with-resources。</p><p><strong>5、尽量减少对变量的重复计算</strong></p><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152604.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>建议替换为：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152633.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>这样，在list.size很大的时候，就减少了很多的消耗</p><p>6、尽量采用懒加载的策略，即在需要的时候才创建*</p><p>例如：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152643.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>建议替换为：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152651.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p><strong>7、慎用异常</strong></p><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace的本地同步方法，fillInStackTrace方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><p><strong>8、不要在循环中使用try…catch…，应该把其放在最外层</strong></p><p>除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了。</p><p><strong>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</strong></p><p>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：</p><p>（1）StringBuilder // 默认分配16个字符的空间</p><p>（2）StringBuilder(int size) // 默认分配size个字符的空间</p><p>（3）StringBuilder(String str) // 默认分配16个字符+str.length个字符空间</p><p>可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p><p>（1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间；</p><p>（2）把原来的4096个字符拷贝到新的的字符数组中去。</p><p>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</p><p><strong>10、当复制大量数据时，使用System.arraycopy命令</strong></p><p><strong>11、乘法和除法使用移位操作</strong></p><p>例如：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152707.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152724.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p><p><strong>12、循环内不要不断创建对象引用</strong></p><p>例如：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152820.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152832.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>这样的话，内存中只有一份Object对象引用，每次new Object的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p><p><strong>13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</strong></p><p><strong>14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</strong></p><p><strong>15、不要将数组声明为public static final</strong></p><p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变。</p><p><strong>16、尽量在合适的场合使用单例</strong></p><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><p>（1）控制资源的使用，通过线程同步来控制资源的并发访问</p><p>（2）控制实例的产生，以达到节约资源的目的</p><p>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p><p><strong>17、尽量避免随意使用静态变量</strong></p><p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152842.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止。</p><p><strong>18、及时清除不再需要的Session</strong></p><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate方法清除会话。</p><p><strong>19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</strong></p><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152858.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p><p><strong>20、使用同步代码块替代同步方法</strong></p><p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p><p><strong>21、将常量声明为static final，并以大写命名</strong></p><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量。</p><p><strong>22、不要创建一些不使用的对象，不要导入一些不使用的类</strong></p><p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p><p><strong>23、程序运行过程中避免使用反射</strong></p><p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p><p><strong>24、使用数据库连接池和线程池</strong></p><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程。</p><p><strong>25、使用带缓冲的输入输出流进行IO操作</strong></p><p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率。</p><p><strong>26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了。</strong></p><p><strong>27、不要让public方法中有太多的形参</strong></p><p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p><p>1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</p><p>2、参数太多势必导致方法调用的出错概率增加</p><p>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参。</p><p><strong>28、字符串变量和字符串常量equals的时候将字符串常量写在前面</strong></p><p>这是一个比较常见的小技巧了，如果有以下代码：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152911.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>建议修改为：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152920.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>这么做主要是可以避免空指针异常。</p><p><strong>29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者</strong></p><p>平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。</p><p>在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152947.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>C/C++判断”i==1″不成立，所以以0表示，即false。但是如果：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153000.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153009.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p><p>但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p><p><strong>30、不要对数组使用toString方法</strong></p><p>看一下对数组使用toString打印出来的是什么：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153019.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>结果是：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153031.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString没有意义，但是对集合toString是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString方法。</p><p><strong>31、不要对超出范围的基本数据类型做向下强制转型</strong></p><p>这绝不会得到想要的结果：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153040.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>我们可能期望得到其中的某几位，但是结果却是：</p><p>1942892530</p><p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p><p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p><p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p><p>0111 0011 1100 1110 0010 1111 1111 0010</p><p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p><p>1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f = 3.5f”</p><p>2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int</p><p><strong>32、公用的集合类中不使用的数据一定要及时remove掉</strong></p><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p><p><strong>33、把一个基本数据类型转为字符串，基本数据类型.toString是最快的方式、String.valueOf次之、数据+””最慢</strong></p><p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153049.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>运行结果为：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153059.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString方法。至于为什么，很简单：</p><p>1、String.valueOf方法底层调用了Integer.toString方法，但是会在调用前做空判断</p><p>2、Integer.toString方法就不说了，直接调用了</p><p>3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString方法获取字符串</p><p>三者对比下来，明显是2最快、1次之、3最慢。</p><p><strong>34、使用最有效率的方式去遍历Map</strong></p><p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153110.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>如果你只是想遍历一下这个Map的key值，那用”Set keySet = hm.keySet;”会比较合适一些</p><p>35、对资源的close建议分开操作</p><p>意思是，比如我有这么一段代码：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153120.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>建议修改为：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124153128.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>虽然有些麻烦，却能避免资源泄露。我想，如果没有修改过的代码，万一XXX.close抛异常了，那么就进入了cath块中了，YYY.close不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为上面的写法之后，就保证了无论如何XXX和YYY都会被close掉。如果JDK7以上，强烈建议使用try-with-resources。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码 优化 ，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。&lt;/p&gt;
&lt;p&gt;代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码优化的目标是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;减小代码的体积&lt;/p&gt;
&lt;p&gt;提高代码运行的效率&lt;/p&gt;
&lt;p&gt;代码优化细节&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Guava - 拯救垃圾代码，写出优雅高效，效率提升N倍</title>
    <link href="http://www.sjsmile.cn/2021/01/24/java/Guava-%E6%8B%AF%E6%95%91%E5%9E%83%E5%9C%BE%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E9%AB%98%E6%95%88%EF%BC%8C%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87N%E5%80%8D/"/>
    <id>http://www.sjsmile.cn/2021/01/24/java/Guava-%E6%8B%AF%E6%95%91%E5%9E%83%E5%9C%BE%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E9%AB%98%E6%95%88%EF%BC%8C%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87N%E5%80%8D/</id>
    <published>2021-01-24T07:22:01.000Z</published>
    <updated>2021-01-24T08:33:38.988Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Guava</strong> 项目是 Google 公司开源的 Java 核心库，它主要是包含一些在 Java 开发中经常使用到的功能，如<strong>数据校验</strong>、<strong>不可变集合</strong>、计数集合，集合增强操作、I/O、缓存、字符串操作等。并且 <strong>Guava</strong> 广泛用于 Google 内部的 Java 项目中，也被其他公司广泛使用，甚至在新版 JDK 中直接引入了 <strong>Guava</strong> 中的优秀类库，所以质量毋庸置疑。</p><p>使用方式直接 mavan 依赖引入。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>30.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><p>数据校验说来十分简单，一是<strong>非空判断</strong>，二是<strong>预期值判断</strong>。非空判断我想每一个 Java 开发者都很熟悉，一开始都经常和 <code>NullPointException</code> 打交道。处理的方式我们自然是一个 <code>if( xx == null)</code> 就能轻松解决。预期值判断也是类似，检查数据值是不是自己想要的结果即可。</p><p>即使这么简单的操作，我们是不是还经常出错呢？而且写起来的代码总是一行判断一行异常抛出，怎么看都觉得那么优雅。还好，现在就来尝试第一次使用 Guava 吧。</p><a id="more"></a><h3 id="非空判断"><a href="#非空判断" class="headerlink" title="非空判断"></a>非空判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String param = <span class="string">"未读代码"</span>;</span><br><span class="line">String name = Preconditions.checkNotNull(param);</span><br><span class="line">System.out.println(name); <span class="comment">// 未读代码</span></span><br><span class="line">String param2 = <span class="keyword">null</span>;</span><br><span class="line">String name2 = Preconditions.checkNotNull(param2); <span class="comment">// NullPointerException</span></span><br><span class="line">System.out.println(name2);</span><br></pre></td></tr></table></figure><p>引入了 Guava 后可以直接使用 <code>Preconditions.checkNotNull</code> 进行非空判断，好处为觉得有两个，一是语义清晰代码优雅；二是你也可以自定义报错信息，这样如果参数为空，报错的信息清晰，可以直接定位到具体参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String param2 = <span class="keyword">null</span>;</span><br><span class="line">String name2 = Preconditions.checkNotNull(param2,<span class="string">"param2 is null"</span>);</span><br><span class="line"><span class="comment">// java.lang.NullPointerException: param2 is null</span></span><br></pre></td></tr></table></figure><h3 id="预期值判断"><a href="#预期值判断" class="headerlink" title="预期值判断"></a>预期值判断</h3><p>和非空判断类似，可以比较当前值和预期值，如果不相等可以自定义报错信息抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String param = <span class="string">"www.wdbyte.com2"</span>;</span><br><span class="line">String wdbyte = <span class="string">"www.wdbyte.com"</span>;</span><br><span class="line">Preconditions.checkArgument(wdbyte.equals(param), <span class="string">"[%s] 404 NOT FOUND"</span>, param);</span><br><span class="line"><span class="comment">// java.lang.IllegalArgumentException: [www.wdbyte.com2] 404 NOT FOUND</span></span><br></pre></td></tr></table></figure><h3 id="是否越界"><a href="#是否越界" class="headerlink" title="是否越界"></a>是否越界</h3><p><code>Preconditions</code> 类还可以用来检查数组和集合的元素获取是否越界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Guava 中快速创建ArrayList</span></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line"><span class="comment">// 开始校验</span></span><br><span class="line"><span class="keyword">int</span> index = Preconditions.checkElementIndex(<span class="number">5</span>, list.size());</span><br><span class="line"><span class="comment">// java.lang.IndexOutOfBoundsException: index (5) must be less than size (4)</span></span><br></pre></td></tr></table></figure><p>代码中快速创建 List 的方式也是 Guava 提供的，后面会详细介绍 Guava 中集合创建的超多姿势。</p><h2 id="不可变的集合"><a href="#不可变的集合" class="headerlink" title="不可变的集合"></a>不可变的集合</h2><p>创建不可变集合是我个人最喜欢 Guava 的一个原因，因为创建一个<strong>不能删除、不能修改、不能增加元素</strong>的集合实在是太实用了。这样的集合你完全不用担心发生什么问题，总的来说有下面几个优点：</p><ol><li>线程安全，因为不能修改任何元素，可以随意多线程使用且没有并发问题。</li><li>可以无忧的提供给第三方使用，反正修改不了。</li><li>减少内存占用，因为不能改变，所以内部实现可以最大程度节约内存占用。</li><li>可以用作常量集合。</li></ol><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p>说了那么多，那么到底怎么使用呢？赶紧撸起代码来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建方式1：of</span></span><br><span class="line">ImmutableSet&lt;String&gt; immutableSet = ImmutableSet.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">immutableSet.forEach(System.out::println);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建方式2：builder</span></span><br><span class="line">ImmutableSet&lt;String&gt; immutableSet2 = ImmutableSet.&lt;String&gt;builder()</span><br><span class="line">    .add(<span class="string">"hello"</span>)</span><br><span class="line">    .add(<span class="keyword">new</span> String(<span class="string">"未读代码"</span>))</span><br><span class="line">    .build();</span><br><span class="line">immutableSet2.forEach(System.out::println);</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// 未读代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建方式3：从其他集合中拷贝创建</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"www.wdbyte.com"</span>);</span><br><span class="line">arrayList.add(<span class="string">"https"</span>);</span><br><span class="line">ImmutableSet&lt;String&gt; immutableSet3 = ImmutableSet.copyOf(arrayList);</span><br><span class="line">immutableSet3.forEach(System.out::println);</span><br><span class="line"><span class="comment">// www.wdbyte.com</span></span><br><span class="line"><span class="comment">// https</span></span><br></pre></td></tr></table></figure><p>都可以正常打印遍历结果，但是如果进行增删改，会直接报 <code>UnsupportedOperationException</code>.</p><p>其实 JDK 中也提供了一个不可变集合，可以像下面这样创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"www.wdbyte.com"</span>);</span><br><span class="line">arrayList.add(<span class="string">"https"</span>);</span><br><span class="line"><span class="comment">// JDK Collections 创建不可变 List</span></span><br><span class="line">List&lt;String&gt; list = Collections.unmodifiableList(arrayList);</span><br><span class="line">list.forEach(System.out::println);<span class="comment">// www.wdbyte.com https</span></span><br><span class="line">list.add(<span class="string">"未读代码"</span>); <span class="comment">// java.lang.UnsupportedOperationException</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>使用 Guava 创建的不可变集合是拒绝 <code>null</code> 值的，因为在 Google 内部调查中，95% 的情况下都不需要放入 <code>null</code> 值。</li><li>使用 JDK 提供的不可变集合创建成功后，原集合添加元素会体现在不可变集合中，而 Guava 的不可变集合不会有这个问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">"a"</span>);</span><br><span class="line">arrayList.add(<span class="string">"b"</span>);</span><br><span class="line">List&lt;String&gt; jdkList = Collections.unmodifiableList(arrayList);</span><br><span class="line">ImmutableList&lt;String&gt; immutableList = ImmutableList.copyOf(arrayList);</span><br><span class="line">arrayList.add(<span class="string">"ccc"</span>);</span><br><span class="line">jdkList.forEach(System.out::println);<span class="comment">// result: a b ccc</span></span><br><span class="line">System.out.println(<span class="string">"-------"</span>);</span><br><span class="line">immutableList.forEach(System.out::println);<span class="comment">// result: a b</span></span><br></pre></td></tr></table></figure><ol><li>如果不可变集合的元素是引用对象，那么引用对象的属性是可以更改的。</li></ol><p><strong>其他不可变集合</strong></p><p>不可变集合除了上面演示的 <code>set</code> 之外，还有很多不可变集合，下面是 Guava 中不可变集合和其他集合的对应关系。</p><table><thead><tr><th style="text-align:left"><strong>可变集合接口</strong></th><th style="text-align:left">属于JDK还是Guava</th><th style="text-align:left"><strong>不可变版本</strong></th></tr></thead><tbody><tr><td style="text-align:left">Collection</td><td style="text-align:left">JDK</td><td style="text-align:left"><code>ImmutableCollection</code></td></tr><tr><td style="text-align:left">List</td><td style="text-align:left">JDK</td><td style="text-align:left"><code>ImmutableList</code></td></tr><tr><td style="text-align:left">Set</td><td style="text-align:left">JDK</td><td style="text-align:left"><code>ImmutableSet</code></td></tr><tr><td style="text-align:left">SortedSet/NavigableSet</td><td style="text-align:left">JDK</td><td style="text-align:left"><code>ImmutableSortedSet</code></td></tr><tr><td style="text-align:left">Map</td><td style="text-align:left">JDK</td><td style="text-align:left"><code>ImmutableMap</code></td></tr><tr><td style="text-align:left">SortedMap</td><td style="text-align:left">JDK</td><td style="text-align:left"><code>ImmutableSortedMap</code></td></tr><tr><td style="text-align:left">Multiset</td><td style="text-align:left">Guava</td><td style="text-align:left"><code>ImmutableMultiset</code></td></tr><tr><td style="text-align:left">SortedMultiset</td><td style="text-align:left">Guava</td><td style="text-align:left"><code>ImmutableSortedMultiset</code></td></tr><tr><td style="text-align:left">Multimap</td><td style="text-align:left">Guava</td><td style="text-align:left"><code>ImmutableMultimap</code></td></tr><tr><td style="text-align:left">ListMultimap</td><td style="text-align:left">Guava</td><td style="text-align:left"><code>ImmutableListMultimap</code></td></tr><tr><td style="text-align:left">SetMultimap</td><td style="text-align:left">Guava</td><td style="text-align:left"><code>ImmutableSetMultimap</code></td></tr><tr><td style="text-align:left">BiMap</td><td style="text-align:left">Guava</td><td style="text-align:left"><code>ImmutableBiMap</code></td></tr><tr><td style="text-align:left">ClassToInstanceMap</td><td style="text-align:left">Guava</td><td style="text-align:left"><code>ImmutableClassToInstanceMap</code></td></tr><tr><td style="text-align:left">Table</td><td style="text-align:left">Guava</td><td style="text-align:left"><code>ImmutableTable</code></td></tr></tbody></table><h2 id="集合操作工厂"><a href="#集合操作工厂" class="headerlink" title="集合操作工厂"></a>集合操作工厂</h2><p>其实这里只会介绍一个创建方法，但是为什么还是单独拿出来介绍了呢？看下去你就会<strong>大呼好用</strong>。虽然 JDK 中已经提供了大量的集合相关的操作方法，用起来也是非常的方便，但是 Guava 还是增加了一些十分好用的方法，保证让你用上一次就爱不释手，</p><h3 id="创建集合。"><a href="#创建集合。" class="headerlink" title="创建集合。"></a>创建集合。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 ArrayList 集合</span></span><br><span class="line">List&lt;String&gt; list1 = Lists.newArrayList();</span><br><span class="line"><span class="comment">// 创建一个 ArrayList 集合，同时塞入3个数据</span></span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"><span class="comment">// 创建一个 ArrayList 集合，容量初始化为10</span></span><br><span class="line">List&lt;String&gt; list3 = Lists.newArrayListWithCapacity(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">LinkedList&lt;String&gt; linkedList1 = Lists.newLinkedList();</span><br><span class="line">CopyOnWriteArrayList&lt;String&gt; cowArrayList = Lists.newCopyOnWriteArrayList();</span><br><span class="line"></span><br><span class="line">HashMap&lt;Object, Object&gt; hashMap = Maps.newHashMap();</span><br><span class="line">ConcurrentMap&lt;Object, Object&gt; concurrentMap = Maps.newConcurrentMap();</span><br><span class="line">TreeMap&lt;Comparable, Object&gt; treeMap = Maps.newTreeMap();</span><br><span class="line"></span><br><span class="line">HashSet&lt;Object&gt; hashSet = Sets.newHashSet();</span><br><span class="line">HashSet&lt;String&gt; newHashSet = Sets.newHashSet(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br></pre></td></tr></table></figure><p>Guava 为每一个集合都添加了工厂方法创建方式，上面已经展示了部分集合的工厂方法创建方式。是不是十分的好用呢。而且可以在创建时直接扔进去几个元素，这个简直太赞了，再也不用一个个 <code>add</code> 了。</p><h3 id="集合交集并集差集"><a href="#集合交集并集差集" class="headerlink" title="集合交集并集差集"></a>集合交集并集差集</h3><p>过于简单，直接看代码和输出结果吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; newHashSet1 = Sets.newHashSet(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">Set&lt;String&gt; newHashSet2 = Sets.newHashSet(<span class="string">"b"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line">SetView&lt;String&gt; intersectionSet = Sets.intersection(newHashSet1, newHashSet2);</span><br><span class="line">System.out.println(intersectionSet); <span class="comment">// [b, c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line">SetView&lt;String&gt; unionSet = Sets.union(newHashSet1, newHashSet2);</span><br><span class="line">System.out.println(unionSet); <span class="comment">// [a, b, c, d]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// newHashSet1 中存在，newHashSet2 中不存在</span></span><br><span class="line">SetView&lt;String&gt; setView = Sets.difference(newHashSet1, newHashSet2);</span><br><span class="line">System.out.println(setView); <span class="comment">// [a]</span></span><br></pre></td></tr></table></figure><h2 id="有数量的集合"><a href="#有数量的集合" class="headerlink" title="有数量的集合"></a>有数量的集合</h2><p>这个真的太有用了，因为我们经常会需要设计可以计数的集合，或者 value 是 <code>List</code> 的 <code>Map</code>集合，如果说你不太明白，看下面这段代码，是否某天夜里你也这样写过。</p><ol><li><p>统计相同元素出现的次数（下面的代码我已经尽可能精简写法了）。</p><p>JDK 原生写法：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 统计相同元素出现的次数。</span></span><br><span class="line">List&lt;String&gt; words = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>);</span><br><span class="line">Map&lt;String, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    Integer count = countMap.get(word);</span><br><span class="line">    count = (count == <span class="keyword">null</span>) ? <span class="number">1</span> : ++count;</span><br><span class="line">    countMap.put(word, count);</span><br><span class="line">&#125;</span><br><span class="line">countMap.forEach((k, v) -&gt; System.out.println(k + <span class="string">":"</span> + v));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result:</span></span><br><span class="line"><span class="comment"> * a:2</span></span><br><span class="line"><span class="comment"> * b:1</span></span><br><span class="line"><span class="comment"> * c:2</span></span><br><span class="line"><span class="comment"> * d:1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>尽管已经尽量优化代码，代码量还是不少的，那么在 Guava 中有什么不一样呢？在 Guava. 中主要是使用 <code>HashMultiset</code> 类，看下面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>);</span><br><span class="line">HashMultiset&lt;String&gt; multiset = HashMultiset.create(arrayList);</span><br><span class="line">multiset.elementSet().forEach(s -&gt; System.out.println(s + <span class="string">":"</span> + multiset.count(s)));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * result:</span></span><br><span class="line"><span class="comment"> * a:2</span></span><br><span class="line"><span class="comment"> * b:1</span></span><br><span class="line"><span class="comment"> * c:2</span></span><br><span class="line"><span class="comment"> * d:1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>是的，只要把元素添加进去就行了，不用在乎是否重复，最后都可以使用 <code>count</code> 方法统计重复元素数量。看着舒服，写着优雅，<code>HashMultiset</code> 是 Guava 中实现的 <code>Collection</code> 类，可以轻松统计元素数量。</p><ol><li><p>一对多，value 是 <code>List</code> 的 <code>Map</code> 集合。</p><p>假设一个场景，需要把很多动物按照种类进行分类，我相信最后你会写出类似的代码。</p><p>JDK 原生写法：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Set&lt;String&gt;&gt; animalMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">HashSet&lt;String&gt; dogSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">dogSet.add(<span class="string">"旺财"</span>);</span><br><span class="line">dogSet.add(<span class="string">"大黄"</span>);</span><br><span class="line">animalMap.put(<span class="string">"狗"</span>, dogSet);</span><br><span class="line">HashSet&lt;String&gt; catSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">catSet.add(<span class="string">"加菲"</span>);</span><br><span class="line">catSet.add(<span class="string">"汤姆"</span>);</span><br><span class="line">animalMap.put(<span class="string">"猫"</span>, catSet);</span><br><span class="line">System.out.println(animalMap.get(<span class="string">"猫"</span>)); <span class="comment">// [加菲, 汤姆]</span></span><br></pre></td></tr></table></figure><p>最后一行查询猫得到了猫类的 “加菲” 和 ”汤姆“。这个代码简直太烦做了，如果使用 Guava 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use guava</span></span><br><span class="line">HashMultimap&lt;String, String&gt; multimap = HashMultimap.create();</span><br><span class="line">multimap.put(<span class="string">"狗"</span>, <span class="string">"大黄"</span>);</span><br><span class="line">multimap.put(<span class="string">"狗"</span>, <span class="string">"旺财"</span>);</span><br><span class="line">multimap.put(<span class="string">"猫"</span>, <span class="string">"加菲"</span>);</span><br><span class="line">multimap.put(<span class="string">"猫"</span>, <span class="string">"汤姆"</span>);</span><br><span class="line">System.out.println(multimap.get(<span class="string">"猫"</span>)); <span class="comment">// [加菲, 汤姆]</span></span><br></pre></td></tr></table></figure><p>HashMultimap 可以扔进去重复的 key 值，最后获取时可以得到所有的 value 值，可以看到输出结果和 JDK 写法上是一样的，但是代码已经无比清爽。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>作为开发中最长使用的数据类型，字符串操作的增强可以让开发更加高效。</p><h3 id="字符拼接"><a href="#字符拼接" class="headerlink" title="字符拼接"></a>字符拼接</h3><p>JDK 8 中其实已经内置了字符串拼接方法，但是它只是简单的拼接，没有额外操作，比如过滤掉 null 元素，去除前后空格等。先看一下 JDK 8 中字符串拼接的几种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 方式一</span></span><br><span class="line">ArrayList&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="keyword">null</span>);</span><br><span class="line">String join = String.join(<span class="string">","</span>, list);</span><br><span class="line">System.out.println(join); <span class="comment">// a,b,c,null</span></span><br><span class="line"><span class="comment">// JDK 方式二</span></span><br><span class="line">String result = list.stream().collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">System.out.println(result); <span class="comment">// a,b,c,null</span></span><br><span class="line"><span class="comment">// JDK 方式三</span></span><br><span class="line">StringJoiner stringJoiner = <span class="keyword">new</span> StringJoiner(<span class="string">","</span>);</span><br><span class="line">list.forEach(stringJoiner::add);</span><br><span class="line">System.out.println(stringJoiner.toString()); <span class="comment">// a,b,c,null</span></span><br></pre></td></tr></table></figure><p>可以看到 null 值也被拼接到了字符串里，这有时候不是我们想要的，那么使用 Guava 有什么不一样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="keyword">null</span>);</span><br><span class="line">String join = Joiner.on(<span class="string">","</span>).skipNulls().join(list);</span><br><span class="line">System.out.println(join); <span class="comment">// a,b,c</span></span><br><span class="line"></span><br><span class="line">String join1 = Joiner.on(<span class="string">","</span>).useForNull(<span class="string">"空值"</span>).join(<span class="string">"旺财"</span>, <span class="string">"汤姆"</span>, <span class="string">"杰瑞"</span>, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(join1); <span class="comment">// 旺财,汤姆,杰瑞,空值</span></span><br></pre></td></tr></table></figure><p>可以看到使用 <code>skipNulls()</code> 可以跳过空值，使用 <code>useFornull(String)</code> 可以为空值自定义显示文本。</p><h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><p>JDK 中是自带字符串分割的，我想你也一定用过，那就是 String 的 split 方法，但是这个方法有一个问题，就是如果最后一个元素为空，那么就会丢弃，奇怪的是第一个元素为空却不会丢弃，这就十分迷惑，下面通过一个例子演示这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">",a,,b,"</span>;</span><br><span class="line">String[] splitArr = str.split(<span class="string">","</span>);</span><br><span class="line">Arrays.stream(splitArr).forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">"------"</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * a</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * b</span></span><br><span class="line"><span class="comment"> * ------</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>你也可以自己测试下，最后一个元素不是空，直接消失了。</p><p>如果使用 Guava 是怎样的操作方式呢？Guava 提供了 Splitter 类，并且有一系列的操作方式可以直观的控制分割逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">",a ,,b ,"</span>;</span><br><span class="line">Iterable&lt;String&gt; split = Splitter.on(<span class="string">","</span>)</span><br><span class="line">    .omitEmptyStrings() <span class="comment">// 忽略空值</span></span><br><span class="line">    .trimResults() <span class="comment">// 过滤结果中的空白</span></span><br><span class="line">    .split(str);</span><br><span class="line">split.forEach(System.out::println);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * a</span></span><br><span class="line"><span class="comment"> * b</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在开发中我们可能需要使用小规模的缓存，来提高访问速度。这时引入专业的缓存中间件可能又觉得浪费。现在可以了， Guava 中提供了简单的缓存类，且可以根据预计容量、过期时间等自动过期已经添加的元素。即使这样我们也要预估好可能占用的内存空间，以防内存占用过多。</p><p>现在看一下在 Guava 中缓存该怎么用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    CacheLoader cacheLoader = <span class="keyword">new</span> CacheLoader&lt;String, Animal&gt;() &#123;</span><br><span class="line">        <span class="comment">// 如果找不到元素，会调用这里</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Animal <span class="title">load</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    LoadingCache&lt;String, Animal&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">1000</span>) <span class="comment">// 容量</span></span><br><span class="line">        .expireAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS) <span class="comment">// 过期时间</span></span><br><span class="line">        .removalListener(<span class="keyword">new</span> MyRemovalListener()) <span class="comment">// 失效监听器</span></span><br><span class="line">        .build(cacheLoader); <span class="comment">//</span></span><br><span class="line">    loadingCache.put(<span class="string">"狗"</span>, <span class="keyword">new</span> Animal(<span class="string">"旺财"</span>, <span class="number">1</span>));</span><br><span class="line">    loadingCache.put(<span class="string">"猫"</span>, <span class="keyword">new</span> Animal(<span class="string">"汤姆"</span>, <span class="number">3</span>));</span><br><span class="line">    loadingCache.put(<span class="string">"狼"</span>, <span class="keyword">new</span> Animal(<span class="string">"灰太狼"</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    loadingCache.invalidate(<span class="string">"猫"</span>); <span class="comment">// 手动失效</span></span><br><span class="line"></span><br><span class="line">    Animal animal = loadingCache.get(<span class="string">"狼"</span>);</span><br><span class="line">    System.out.println(animal);</span><br><span class="line">    Thread.sleep(<span class="number">4</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 狼已经自动过去，获取为 null 值报错</span></span><br><span class="line">    System.out.println(loadingCache.get(<span class="string">"狼"</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key=猫,value=Animal&#123;name='汤姆', age=3&#125;,reason=EXPLICIT</span></span><br><span class="line"><span class="comment">     * Animal&#123;name='灰太狼', age=4&#125;</span></span><br><span class="line"><span class="comment">     * key=狗,value=Animal&#123;name='旺财', age=1&#125;,reason=EXPIRED</span></span><br><span class="line"><span class="comment">     * key=狼,value=Animal&#123;name='灰太狼', age=4&#125;,reason=EXPIRED</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * com.google.common.cache.CacheLoader$InvalidCacheLoadException: CacheLoader returned null for key 狼.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存移除监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRemovalListener</span> <span class="keyword">implements</span> <span class="title">RemovalListener</span>&lt;<span class="title">String</span>, <span class="title">Animal</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;String, Animal&gt; notification)</span> </span>&#123;</span><br><span class="line">        String reason = String.format(<span class="string">"key=%s,value=%s,reason=%s"</span>, notification.getKey(), notification.getValue(), notification.getCause());</span><br><span class="line">        System.out.println(reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Animal&#123;"</span> +</span><br><span class="line">            <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">            <span class="string">", age="</span> + age +</span><br><span class="line">            <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中主要分为 CacheLoader、MyRemovalListener、LoadingCache。</p><p>CacheLoader 中重写了 <code>load</code> 方法，这个方法会在查询缓存没有命中时被调用，我这里直接返回了 <code>null</code>，其实这样会在没有命中时抛出 <code>CacheLoader returned null for key</code> 异常信息。</p><p>MyRemovalListener 作为缓存元素失效时的监听类，在有元素缓存失效时会自动调用 <code>onRemoval</code> 方法，这里需要注意的是这个方法是同步方法，如果这里耗时较长，会阻塞直到处理完成。</p><p>LoadingCache 就是缓存的主要操作对象了，常用的就是其中的 <code>put</code> 和 <code>get</code> 方法了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面介绍了我认为最常用的 Guava 功能，Guava 作为 Google 公司开源的 Java 开发核心库，个人觉得实用性还是很高的。引入后不仅能快速的实现一些开发中常用的功能，而且还可以让代码更加的优雅简洁。我觉得适用于每一个 Java 项目。Guava 的其他的功能你也可以自己去发现。它的 Github 地址是：<a href="https://github.com/google/guava" target="_blank" rel="noopener">https://github.com/google/guava</a>.</p><p><strong>参考</strong></p><ol><li><a href="https://github.com/google/guava/wiki" target="_blank" rel="noopener">https://github.com/google/guava/wiki</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Guava&lt;/strong&gt; 项目是 Google 公司开源的 Java 核心库，它主要是包含一些在 Java 开发中经常使用到的功能，如&lt;strong&gt;数据校验&lt;/strong&gt;、&lt;strong&gt;不可变集合&lt;/strong&gt;、计数集合，集合增强操作、I/O、缓存、字符串操作等。并且 &lt;strong&gt;Guava&lt;/strong&gt; 广泛用于 Google 内部的 Java 项目中，也被其他公司广泛使用，甚至在新版 JDK 中直接引入了 &lt;strong&gt;Guava&lt;/strong&gt; 中的优秀类库，所以质量毋庸置疑。&lt;/p&gt;
&lt;p&gt;使用方式直接 mavan 依赖引入。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.google.guava&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;guava&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;30.0-jre&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;数据校验&quot;&gt;&lt;a href=&quot;#数据校验&quot; class=&quot;headerlink&quot; title=&quot;数据校验&quot;&gt;&lt;/a&gt;数据校验&lt;/h2&gt;&lt;p&gt;数据校验说来十分简单，一是&lt;strong&gt;非空判断&lt;/strong&gt;，二是&lt;strong&gt;预期值判断&lt;/strong&gt;。非空判断我想每一个 Java 开发者都很熟悉，一开始都经常和 &lt;code&gt;NullPointException&lt;/code&gt; 打交道。处理的方式我们自然是一个 &lt;code&gt;if( xx == null)&lt;/code&gt; 就能轻松解决。预期值判断也是类似，检查数据值是不是自己想要的结果即可。&lt;/p&gt;
&lt;p&gt;即使这么简单的操作，我们是不是还经常出错呢？而且写起来的代码总是一行判断一行异常抛出，怎么看都觉得那么优雅。还好，现在就来尝试第一次使用 Guava 吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>String长度有限制吗？是多少？</title>
    <link href="http://www.sjsmile.cn/2021/01/24/java/String%E9%95%BF%E5%BA%A6%E6%9C%89%E9%99%90%E5%88%B6%E5%90%97%EF%BC%9F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F/"/>
    <id>http://www.sjsmile.cn/2021/01/24/java/String%E9%95%BF%E5%BA%A6%E6%9C%89%E9%99%90%E5%88%B6%E5%90%97%EF%BC%9F%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F/</id>
    <published>2021-01-24T07:10:30.000Z</published>
    <updated>2021-01-24T08:33:56.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>话说Java中String是有长度限制的，听到这里很多人不禁要问，String还有长度限制？是的有，而且在JVM编译中还有规范，而且有的家人们在面试的时候也遇到了。</p><p>本人就遇到过面试的时候问这个的，而且在之前开发的中也真实地遇到过这个String长度限制的场景（将某固定文件转码成Base64的形式用字符串存储，在运行时需要的时候在转回来，当时文件比较大），那这个规范限制到底是怎么样的，咱们话不多说先䁖䁖去。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>首先要知道String的长度限制我们就需要知道String是怎么存储字符串的，String其实是使用的一个char类型的数组来存储字符串中的字符的。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151612.jpg" alt="存储String的容器原来是它" title="" class="">                <p>存储String的容器原来是它</p>            </figure><a id="more"></a><p>那么String既然是数组存储那数组会有长度的限制吗？是的有限制，但是是在有先提条件下的，我们看看String中返回length的方法。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151630.jpg" alt="String类中的length方法" title="" class="">                <p>String类中的length方法</p>            </figure><p>由此我们看到返回值类型是int类型，Java中定义数组是可以给数组指定长度的，当然不指定的话默认会根据数组元素来指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] arr1 = new int[10]; // 定义一个长度为10的数组</span><br><span class="line">int[] arr2 = &#123;1,2,3,4,5&#125;; // 那么此时数组的长度为5</span><br></pre></td></tr></table></figure><p>整数在java中是有限制的，我们通过源码来看看int类型对应的包装类Integer可以看到，其长度最大限制为2^31 -1，那么说明了数组的长度是0~2^31-1，那么计算一下就是（2^31-1 = 2147483647 = 4GB）</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151731.jpg" alt="Integer的取值范围" title="" class="">                <p>Integer的取值范围</p>            </figure><p>看到这我们尝试通过编码来验证一下上述观点。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151745.jpg" alt="以字面量形式定义字符串" title="" class="">                <p>以字面量形式定义字符串</p>            </figure><p>以上是我通过定义字面量的形式构造的10万个字符的字符串，编译之后虚拟机提示报错，说我们的字符串长度过长，不是说好了可以存21亿个吗？为什么才10万个就报错了呢？</p><p>其实这里涉及到了JVM编译规范的限制了，其实JVM在编译时，如果我们将字符串定义成了字面量的形式，编译时JVM是会将其存放在常量池中，这时候JVM对这个常量池存储String类型做出了限制，接下来我们先看下手册是如何说的。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151858.jpg" alt="java虚拟机规范截图" title="" class="">                <p>java虚拟机规范截图</p>            </figure><p>常量池中，每个 cp_info 项的格式必须相同，它们都以一个表示 cp_info 类型的单字节 “tag”项开头。后面 info[]项的内容 由tag 的类型所决定。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151917.jpg" alt="java虚拟机规范手册常量类型表" title="" class="">                <p>java虚拟机规范手册常量类型表</p>            </figure><p>我们可以看到 String类型的表示是 CONSTANT_String ，我们来看下CONSTANT_String具体是如何定义的。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151932.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>这里定义的 u2 string_index 表示的是常量池的有效索引，其类型是CONSTANT_Utf8_info 结构体表示的，这里我们需要注意的是其中定义的length我们看下面这张图。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151941.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>在class文件中u2表示的是无符号数占2个字节单位，我们知道1个字节占8位，2个字节就是16位 ，那么2个字节能表示的范围就是2^16- 1 = 65535 。范中class文件格式对u1、u2的定义的解释做了一下摘要：</p><p>这里对java虚拟机规摘要部分</p><h4 id="1、class文件中文件内容类型解释"><a href="#1、class文件中文件内容类型解释" class="headerlink" title="1、class文件中文件内容类型解释"></a>1、class文件中文件内容类型解释</h4><p>定义一组私有数据类型来表示 Class 文件的内容，它们包括 u1，u2 和 u4，分别代 表了 1、2 和 4 个字节的无符号数。</p><p>每个 Class 文件都是由 8 字节为单位的字节流组成，所有的 16 位、32 位和 64 位长度的数 据将被构造成 2 个、4 个和 8 个 8 字节单位来表示。</p><h4 id="2、程序异常处理的有效范围解释"><a href="#2、程序异常处理的有效范围解释" class="headerlink" title="2、程序异常处理的有效范围解释"></a>2、程序异常处理的有效范围解释</h4><p>start_pc 和 end_pc 两项的值表明了异常处理器在 code[]数组中的有效范围。</p><p>start_pc 必须是对当前 code[]数组中某一指令的操作码的有效索引，end_pc 要 么是对当前 code[]数组中某一指令的操作码的有效索引，要么等于 code_length 的值，即当前 code[]数组的长度。start_pc 的值必须比 end_pc 小。</p><p>当程序计数器在范围<code>[start_pc, end_pc)</code>内时，异常处理器就将生效。即设 x 为 异常句柄的有效范围内的值，x 满足：<code>start_pc ≤ x &lt; end_pc</code>。</p><p>实际上，end_pc 值本身不属于异常处理器的有效范围这点属于 Java 虚拟机历史上 的一个设计缺陷：如果 Java 虚拟机中的一个方法的 code 属性的长度刚好是 65535 个字节，并且以一个 1 个字节长度的指令结束，那么这条指令将不能被异常处理器 所处理。</p><p>不过编译器可以通过限制任何方法、实例初始化方法或类初始化方法的<code>code[]</code>数组最大长度为 65534，这样可以间接弥补这个 BUG。</p><blockquote><p>注意：这里对个人认为比较重要的点做了标记，首先第一个加粗说白了就是说数组有效范围就是【0-65565】但是第二个加粗的地方又解释了，因为虚拟机还需要1个字节的指令作为结束，所以其实真正的有效范围是【0-65564】，这里要注意这里的范围仅限编译时期，如果你是运行时拼接的字符串是可以超出这个范围的。</p></blockquote><p>接下来我们通过一个小实验来测试一下我们构建一个长度为65534的字符串，看看是否就能编译通过。0期阶段汇总</p><p>首先通过一个for循环构建65534长度的字符串，在控制台打印后，我们通过自己度娘的一个在线字符统计工具计算了一下确实是65534个字符，如下：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152003.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152013.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>然后我们将字符复制后以定义字面量的形式赋值给字符串，可以看到我们选择这些字符右下角显示的确实是65534，于是乎运行了一波，果然成功了。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152035.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124152046.jpg" alt="图片" title="" class="">                <p>图片</p>            </figure><p>看到这里我们来总结一下：</p><p><strong>问：字符串有长度限制吗？是多少？</strong></p><p>答：首先字符串的内容是由一个字符数组 char[] 来存储的，由于数组的长度及索引是整数，且String类中返回字符串长度的方法length() 的返回值也是int ，所以通过查看java源码中的类Integer我们可以看到Integer的最大范围是2^31 -1,由于数组是从0开始的，所以数组的最大长度可以使【0~2^31】通过计算是大概4GB。</p><p>但是通过翻阅java虚拟机手册对class文件格式的定义以及常量池中对String类型的结构体定义我们可以知道对于索引定义了u2，就是无符号占2个字节，2个字节可以表示的最大范围是2^16 -1 = 65535。</p><p>其实是65535，但是由于JVM需要1个字节表示结束指令，所以这个范围就为65534了。超出这个范围在编译时期是会报错的，但是运行时拼接或者赋值的话范围是在整形的最大范围。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;话说Java中String是有长度限制的，听到这里很多人不禁要问，String还有长度限制？是的有，而且在JVM编译中还有规范，而且有的家人们在面试的时候也遇到了。&lt;/p&gt;
&lt;p&gt;本人就遇到过面试的时候问这个的，而且在之前开发的中也真实地遇到过这个String长度限制的场景（将某固定文件转码成Base64的形式用字符串存储，在运行时需要的时候在转回来，当时文件比较大），那这个规范限制到底是怎么样的，咱们话不多说先䁖䁖去。&lt;/p&gt;
&lt;h2 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h2&gt;&lt;p&gt;首先要知道String的长度限制我们就需要知道String是怎么存储字符串的，String其实是使用的一个char类型的数组来存储字符串中的字符的。&lt;/p&gt;
&lt;figure class=&quot;image-box&quot;&gt;
                &lt;img src=&quot;https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20210124151612.jpg&quot; alt=&quot;存储String的容器原来是它&quot; title=&quot;&quot; class=&quot;&quot;&gt;
                &lt;p&gt;存储String的容器原来是它&lt;/p&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>websocket 用途，例子，场景，什么时候用websocket</title>
    <link href="http://www.sjsmile.cn/2021/01/24/websocket-%E7%94%A8%E9%80%94%EF%BC%8C%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%9C%BA%E6%99%AF%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8websocket/"/>
    <id>http://www.sjsmile.cn/2021/01/24/websocket-%E7%94%A8%E9%80%94%EF%BC%8C%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%9C%BA%E6%99%AF%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8websocket/</id>
    <published>2021-01-24T07:06:13.000Z</published>
    <updated>2021-01-24T08:33:05.219Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://www.360doc.cn/outlink.html?url=https://java-er.com/blog/tag/websocket/" target="_blank" rel="noopener">websocket</a> 应用例子如下<br>先总结：高即时性服务，比如聊天室的群聊，server顺序收到了张三，李四的消息，立即就推送给王五，不能让王五等半天。<br>Ajax也可以一秒一刷，让王五去问张三说话没，如果张三10分钟没说话，王五要去问600次。 用<a href="http://www.360doc.cn/outlink.html?url=https://java-er.com/blog/tag/websocket/" target="_blank" rel="noopener">websocket</a> 王五不用刷，等着就好了，服务器有了消息会自动给王五的。</p><h1 id="1-websocket社交订阅"><a href="#1-websocket社交订阅" class="headerlink" title="1.websocket社交订阅"></a><strong>1.websocket社交订阅</strong></h1><p>对社交类的应用的一个裨益之处就是能够即时的知道你的朋友正在做什么。虽然听起来有点可怕，但是我们都喜欢这样做。你不会想要在数分钟之后才能知道一个家庭成员在馅饼制作大赛获胜或者一个朋友订婚的消息。你是在线的，所以你的订阅的更新应该是实时的。</p><a id="more"></a><h1 id="2-websocket多玩家游戏"><a href="#2-websocket多玩家游戏" class="headerlink" title="2.websocket多玩家游戏"></a><strong>2.websocket多玩家游戏</strong></h1><p>网络正在迅速转变为游戏平台。在不使用插件（我指的是Flash）的情况下，网络开发者现在可以在浏览器中实现和体验高性能的游戏。无论你是在处理DOM元素、CSS动画，HTML5的canvas或者尝试使用WebGL，玩家之间的互动效率是至关重要的。我不想在我扣动扳机之后，我的对手却已经移动位置。</p><h1 id="3-websocket协同编辑-编程"><a href="#3-websocket协同编辑-编程" class="headerlink" title="3.websocket协同编辑/编程"></a><strong>3.websocket协同编辑/编程</strong></h1><p>我们生活在分布式开发团队的时代。平时使用一个文档的副本就满足工作需求了，但是你最终需要有一个方式来合并所有的编辑副本。版本控制系统，比如Git能够帮助处理某些文件，但是当Git发现一个它不能解决的冲突时,你仍然需要去跟踪人们的修改历史。通过一个协同解决方案，比如WebSocket，我们能够工作在同一个文档，从而省去所有的合并版本。这样会很容易看出谁在编辑什么或者你在和谁同时在修改文档的同一部分。</p><h1 id="4-websocket收集点击流数据"><a href="#4-websocket收集点击流数据" class="headerlink" title="4.websocket收集点击流数据"></a><strong>4.websocket收集点击流数据</strong></h1><p>分析用户与你网站的互动是提升你的网站的关键。HTTP的开销让我们只能优先考虑和收集最重要的数据部分。然后，经过六个月的线下分析，我们意识到我们应该收集一个不同的判断标准——一个看起来不是那么重要但是现在却影响了一个关键的决定。与HTTP请求的开销方式相比，使用Websocket，你可以由客户端发送不受限制的数据。想要在除页面加载之外跟踪鼠标的移动？只需要通过WebSocket连接发送这些数据到服务器，并存储在你喜欢的NoSQL数据库中就可以了（MongoDB是适合记录这样的事件的）。现在你可以通过回放用户在页面的动作来清楚的知道发生了什么。</p><h1 id="5-股票基金报价"><a href="#5-股票基金报价" class="headerlink" title="5.股票基金报价"></a><strong>5.股票基金报价</strong></h1><p>金融界瞬息万变——几乎是每毫秒都在变化。我们人类的大脑不能持续以那样的速度处理那么多的数据，所以我们写了一些算法来帮我们处理这些事情。虽然你不一定是在处理高频的交易，但是，过时的信息也只能导致损失。当你有一个显示盘来跟踪你感兴趣的公司时，你肯定想要随时知道他们的价值，而不是10秒前的数据。使用WebSocket可以流式更新这些数据变化而不需要等待。</p><h1 id="6-体育实况更新"><a href="#6-体育实况更新" class="headerlink" title="6.体育实况更新"></a><strong>6.体育实况更新</strong></h1><p>现在我们开始讨论一个让人们激情澎湃的愚蠢的东西——体育。我不是运动爱好者，但是我知道运动迷们想要什么。当爱国者在打比赛的时候，我的妹夫将会沉浸于这场比赛中而不能自拔。那是一种疯狂痴迷的状态，完全发自内心的。我虽然不理解这个，但是我敬佩他们与运动之间的这种强烈的联系，所以，最后我能做的就是给他的体验中降低延迟。如果你在你的网站应用中包含了体育新闻，WebSocket能够助力你的用户获得实时的更新。</p><h1 id="7-多媒体聊天"><a href="#7-多媒体聊天" class="headerlink" title="7.多媒体聊天"></a><strong>7.多媒体聊天</strong></h1><p>视频会议并不能代替和真人相见，但当你不能在同一个屋子里见到你谈话的对象时，视频会议是个不错的选择。尽管视频会议私有化做的“不错”，但其使用还是很繁琐。我可是开放式网络的粉丝，所以用WebSockets getUserMedia API和HTML5音视频元素明显是个不错的选择。WebRTC的出现顺理成章的成为我刚才概括的组合体，它看起来很有希望，但其缺乏目前浏览器的支持，所以就取消了它成为候选人的资格。</p><h1 id="8-基于位置的应用"><a href="#8-基于位置的应用" class="headerlink" title="8.基于位置的应用"></a><strong>8.基于位置的应用</strong></h1><p>越来越多的开发者借用移动设备的GPS功能来实现他们基于位置的网络应用。如果你一直记录用户的位置(比如运行应用来记录运动轨迹)，你可以收集到更加细致化的数据。如果你想实时的更新网络数据仪表盘(可以说是一个监视运动员的教练)，HTTP协议显得有些笨拙。借用WebSocket TCP链接可以让数据飞起来。</p><h1 id="9-在线教育"><a href="#9-在线教育" class="headerlink" title="9.在线教育"></a><strong>9.在线教育</strong></h1><p>上学花费越来越贵了，但互联网变得更快和更便宜。在线教育是学习的不错方式，尤其是你可以和老师以及其他同学一起交流。很自然，WebSockets是个不错的选择，可以多媒体聊天、文字聊天以及其它优势如与别人合作一起在公共数字黑板上画画…</p><h1 id="10-论坛的消息广播"><a href="#10-论坛的消息广播" class="headerlink" title="10.论坛的消息广播"></a><strong>10.论坛的消息广播</strong></h1><p>早期的论坛消息通知，靠的都是JS轮询，现在有了websocket 可以改改了。</p><p><a href="http://www.360doc.cn/outlink.html?url=https://java-er.com/blog/websocket-where-when/" target="_blank" rel="noopener">https://java-er.com/blog/websocket-where-when/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.360doc.cn/outlink.html?url=https://java-er.com/blog/tag/websocket/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;websocket&lt;/a&gt; 应用例子如下&lt;br&gt;先总结：高即时性服务，比如聊天室的群聊，server顺序收到了张三，李四的消息，立即就推送给王五，不能让王五等半天。&lt;br&gt;Ajax也可以一秒一刷，让王五去问张三说话没，如果张三10分钟没说话，王五要去问600次。 用&lt;a href=&quot;http://www.360doc.cn/outlink.html?url=https://java-er.com/blog/tag/websocket/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;websocket&lt;/a&gt; 王五不用刷，等着就好了，服务器有了消息会自动给王五的。&lt;/p&gt;
&lt;h1 id=&quot;1-websocket社交订阅&quot;&gt;&lt;a href=&quot;#1-websocket社交订阅&quot; class=&quot;headerlink&quot; title=&quot;1.websocket社交订阅&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.websocket社交订阅&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;对社交类的应用的一个裨益之处就是能够即时的知道你的朋友正在做什么。虽然听起来有点可怕，但是我们都喜欢这样做。你不会想要在数分钟之后才能知道一个家庭成员在馅饼制作大赛获胜或者一个朋友订婚的消息。你是在线的，所以你的订阅的更新应该是实时的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="websocket" scheme="http://www.sjsmile.cn/categories/websocket/"/>
    
      <category term="网络" scheme="http://www.sjsmile.cn/categories/websocket/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="websocket" scheme="http://www.sjsmile.cn/tags/websocket/"/>
    
      <category term="网络" scheme="http://www.sjsmile.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>java常用集合源码分析</title>
    <link href="http://www.sjsmile.cn/2020/09/26/java/java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.sjsmile.cn/2020/09/26/java/java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-09-26T13:20:10.000Z</published>
    <updated>2020-10-04T03:45:43.439Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java集合源码分析"><a href="#java集合源码分析" class="headerlink" title="java集合源码分析"></a>java集合源码分析</h1><p>大家平时在用java写代码的时候，使用的数据结构最多的就是java自己封装好的集合类。但是当我们使用这些封装好的集合类的时候，不了解底层原理，或多或少就会碰到由于不知道底层原理，导致开发时忽略的细节，造成开发甚至是生产方面的BUG。防微杜渐，产品的质量是计划出来的，未雨绸缪的。所以，下面就java常用集合专题，揭开java集合的神秘面纱。包括ArrayList；LinkedList；HashSet；HashMap；线程安全的ConcurrentHashMap。我会将个人理解与源代码结合，将个人解读写在源代码注释中，边看源码边学习。</p><h1 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1 ArrayList"></a>1 ArrayList</h1><h2 id="1-1-整体架构"><a href="#1-1-整体架构" class="headerlink" title="1.1 整体架构"></a>1.1 整体架构</h2><p>ArrayList 整体架构比较简单，就是一个数组结构，比较简单，如下图：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114356.png" alt="图片描述" title="" class="">                <p>图片描述</p>            </figure><p>图中展示是长度为 10 的数组，从 1 开始计数，index 表示数组的下标，从 0 开始计数，elementData 表示数组本身，源码中除了这两个概念，还有以下三个基本概念：</p><ul><li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li><li>size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；</li><li>modCount 统计当前数组被修改的版本次数，数组结构有变动，就会 +1。</li></ul><p>下面是源码：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始容量大小10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//大小为0实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认初始化的空实例，元素增加时自动grow</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    存储arraylist元素的数组缓冲区。</span></span><br><span class="line"><span class="comment">    arraylist的容量是这个数组缓冲区的长度。任何带有elementdata==defaultcapacity_empty_elementdata的空arraylist将在添加第一个元素时扩展为默认容量*/</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">    <span class="comment">//当前大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-类注释"><a href="#1-2-类注释" class="headerlink" title="1.2 类注释"></a>1.2 类注释</h2><p>了解一个类，就需要先看类注释，一个完整的类注释，可以让使用者快速了解一个类，往往事半功倍，下面我们来看一下ArrayList的类注释写了什么（因为源码的类注释很长，下面就简短的挑一些重点的说明并总结经行阐述）</p><ul><li>允许 put null 值，会自动扩容；</li><li>size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；</li><li>是非线程安全的，多线程情况下，推荐使用线程安全类：Vector(早期的集合，现在不推荐使用了)，Collections.synchronizedList，CopyOnWriteArrayList；</li><li>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。</li></ul><h2 id="1-3-构造函数（初始化）"><a href="#1-3-构造函数（初始化）" class="headerlink" title="1.3 构造函数（初始化）"></a>1.3 构造函数（初始化）</h2><p>我们有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有大小initialCapacity的构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无参数直接初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始数据初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// c.toArray 可能不会正确返回 Object[]（具体问题请自行看toArray源码）</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)&#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用EMPTY_ELEMENTDATA替代数据.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：使用无参数直接初始化，默认是空的数组，只有当在第一次使用add方法的时候，扩容到DEFAULT_CAPACITY（也就是10）。下面我们可以通过常用的方法，来看看这么一个过程。</p><h2 id="1-4-方法"><a href="#1-4-方法" class="headerlink" title="1.4 方法"></a>1.4 方法</h2><h3 id="1-4-1-新增和扩容实现"><a href="#1-4-1-新增和扩容实现" class="headerlink" title="1.4.1 新增和扩容实现"></a>1.4.1 新增和扩容实现</h3><p>新增与扩容就是往数组中添加元素，主要分成两步：</p><ul><li>判断是否需要扩容，如果需要执行扩容操作（默认扩容为原容量大小的1.5倍，直到Integer的最大值）；</li><li>直接赋值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">//直接赋值，线程不安全的</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确保容积足够</span></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//记录数组被修改</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容，并把现有数据拷贝到新的数组里面去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity 除以 2 的意思</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 通过复制进行扩容</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-删除"><a href="#1-4-2-删除" class="headerlink" title="1.4.2 删除"></a>1.4.2 删除</h3><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多，就选取根据值删除方式来进行源码说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果要删除的值是 null，找到第一个值是 null 的删除</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果要删除的值不为 null，找到第一个和要删除的值相等的删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="comment">// 这里是根据  equals 来判断值相等的，相等后再根据索引位置进行删除</span></span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要注意的两点是：</p><ul><li>新增的时候是没有对 null 进行校验的，所以删除的时候也是允许删除 null 值的；</li><li>找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，需要我们关注 equals 的具体实现。</li></ul><p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 记录数组的结构要发生变动了</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去</span></span><br><span class="line">  <span class="comment">// 减 1 的原因，是因为 size 从 1 开始算起，index 从 0开始算起</span></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 numMoved</span></span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">  <span class="comment">//数组最后一个位置赋值 null，帮助 GC</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中，我们可以看出，某一个元素被删除后，为了维护数组结构，我们都会把数组后面的元素往前移动。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><p>可以发现，ArrayList是一个Object的数组；平时我们用需要用泛型去制约好它，不然会造成元数据操作的问题（比如一个ArrayList里面有Integer，String，到时候对数据的操作就会产生问题）。通过上面源码分析，我们发现，扩容是通过这行代码来实现的：<code>Arrays.copyOf(elementData, newCapacity);</code>，这行代码描述的本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据拷贝过去。通过构造函数，我们可以知道，使用没有参数的构造函数构造ArrayList，默认是空数组，当第一次add的时候才会扩容，所以最好在初始话的时候指定好大小，频繁的calculateCapacity扩容会造成一定的性能损耗。</p><p>其他的函数也就大同小异，业余时间也可以探索一下其他函数的源码实现。</p><h1 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2 LinkedList"></a>2 LinkedList</h1><h2 id="2-1-整体架构"><a href="#2-1-整体架构" class="headerlink" title="2.1 整体架构"></a>2.1 整体架构</h2><p>LinkedList 底层数据结构是一个双向链表，整体结构如下图所示（来源于百度）：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114410.png" alt="图片描述" title="" class="">                <p>图片描述</p>            </figure><p>上图代表了一个双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如下：</p><ul><li>链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置；</li><li>first 是双向链表的头节点，它的前一个节点是 null。</li><li>last 是双向链表的尾节点，它的后一个节点是 null；</li><li>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；</li><li>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。</li></ul><h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><p>我们先首先来看一下对于每一个节点，LinkedList保存的是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">//数据</span></span><br><span class="line">      E item;</span><br><span class="line">      <span class="comment">//类似于c的指针，指向下一个节点</span></span><br><span class="line">      Node&lt;E&gt; next;</span><br><span class="line">      <span class="comment">//指向上一个节点</span></span><br><span class="line">      Node&lt;E&gt; prev;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">          <span class="keyword">this</span>.item = element;</span><br><span class="line">          <span class="keyword">this</span>.next = next;</span><br><span class="line">          <span class="keyword">this</span>.prev = prev;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-构造函数（初始化）"><a href="#2-3-构造函数（初始化）" class="headerlink" title="2.3 构造函数（初始化）"></a>2.3 构造函数（初始化）</h2><p>LinkedList基本属性中保存了首节点与尾节点与大小，构造函数只有空参构造函数以及指定元素的构造函数两种构造方式，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">双向链表，操作类似于其他链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;    <span class="comment">//初始size</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一个节点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">//上一个节点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//addAll构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-方法"><a href="#2-4-方法" class="headerlink" title="2.4 方法"></a>2.4 方法</h2><h3 id="2-4-1-增加"><a href="#2-4-1-增加" class="headerlink" title="2.4.1 增加"></a>2.4.1 增加</h3><p>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加，addLast从尾部增加。增加原理同链表的原理类似，请看下面动图吧：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114419.gif" alt="在这里插入图片描述" title="" class="">                <p>在这里插入图片描述</p>            </figure><h3 id="2-4-2-删除"><a href="#2-4-2-删除" class="headerlink" title="2.4.2 删除"></a>2.4.2 删除</h3><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。下面看图：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114426.gif" alt="在这里插入图片描述" title="" class="">                <p>在这里插入图片描述</p>            </figure><p>补充：上面图片都是以单项列表为例的，其实和双向链表类似，只不过双向链表维护了向前和向后两个指针，也就是执行了单向链表的两次相同的操作。</p><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h2><p>从数据属性来看，LinkedList是一个双向链表，符合链表的各种特性，比如查找的时间复杂度是O（n），头增加和尾增加都是O（1）等。当然如果链表实现了跳表，查找将会变成log级别的查找。跳表的详细知识，有机会我再出一篇文档吧。</p><h1 id="3-HashSet"><a href="#3-HashSet" class="headerlink" title="3 HashSet"></a>3 HashSet</h1><h2 id="3-1-整体架构"><a href="#3-1-整体架构" class="headerlink" title="3.1 整体架构"></a>3.1 整体架构</h2><p>HashSet主要是在 Map 的基础上组装起来的类，了解HashSet主要了解HashMap就行，我们学习它主要是学习Set 是如何利用 Map 现有的功能，来达成自己的目标的，也就是说如何基于现有的功能进行创新，然后再看看一些改变的小细节是否值得我们学习。</p><h2 id="3-2-类注释"><a href="#3-2-类注释" class="headerlink" title="3.2 类注释"></a>3.2 类注释</h2><p>看源码先看类注释上，我们可以得到的信息有：</p><ol><li>底层实现基于 HashMap，所以迭代时不能保证按照插入顺序，或者其它顺序进行迭代；</li><li>add、remove、contanins、size 等方法的耗时性能，是不会随着数据量的增加而增加的，这个主要跟 HashMap 底层的数组数据结构有关，不管数据量多大，不考虑 hash 冲突的情况下，时间复杂度都是 O (1)；</li><li>线程不安全的，如果需要安全请自行加锁，或者使用 Collections.synchronizedSet；</li><li>迭代过程中，如果数据结构被改变，会快速失败的，会抛出 ConcurrentModificationException 异常。</li></ol><h2 id="3-3-HashSet-是如何组合-HashMap-的"><a href="#3-3-HashSet-是如何组合-HashMap-的" class="headerlink" title="3.3 HashSet 是如何组合 HashMap 的"></a>3.3 HashSet 是如何组合 HashMap 的</h2><p>刚才是从类注释 1 中看到，HashSet 的实现是基于 HashMap 的，在 Java 中，要基于基础类进行创新实现，有两种办法：</p><ul><li>继承基础类，覆写基础类的方法，比如说继承 HashMap , 覆写其 add 的方法；</li><li>组合基础类，通过调用基础类的方法，来复用基础类的能力。</li></ul><p>HashSet 使用的就是组合 HashMap，其优点如下：</p><ol><li>继承表示父子类是同一个事物，而 Set 和 Map 本来就是想表达两种事物，所以继承不妥，而且 Java 语法限制，子类只能继承一个父类，后续难以扩展。</li><li>组合更加灵活，可以任意的组合现有的基础类，并且可以在基础类方法的基础上进行扩展、编排等，而且方法命名可以任意命名，无需和基础类的方法名称保持一致。</li></ol><p>我们在工作中，如果碰到类似问题，我们的原则也是尽量多用组合，少用继承。</p><p>组合就是把 HashMap 当作自己的一个局部变量，以下是 HashSet 的组合实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 HashMap 组合进来，key 是 Hashset 的 key，value 是下面的 PRESENT</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">// HashMap 中的 value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>从这两行代码中，我们可以看出两点：</p><ol><li>我们在使用 HashSet 时，比如 add 方法，只有一个入参，但组合的 Map 的 add 方法却有 key，value 两个入参，相对应上 Map 的 key 就是我们 add 的入参，value 就是第二行代码中的 PRESENT，此处设计非常巧妙，用一个默认值 PRESENT 来代替 Map 的 Value；</li><li>如果 HashSet 是被共享的，当多个线程访问的时候，就会有线程安全问题，因为在后续的所有操作中，并没有加锁。</li></ol><p><strong>总结</strong></p><p>HashSet 在以 HashMap 为基础进行实现的时候，首先选择组合的方式，接着使用默认值来代替了 Map 中的 Value 值，设计得非常巧妙，给使用者的体验很好，使用起来简单方便，我们在工作中也可以借鉴这种思想，可以把底层复杂实现包装一下，一些默认实现可以自己吃掉，使吐出去的接口尽量简单好用。</p><h2 id="3-4-属性及构造函数"><a href="#3-4-属性及构造函数" class="headerlink" title="3.4 属性及构造函数"></a>3.4 属性及构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">     * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">     从源码解释可以看出，Set的数据结构使用的是HashMap，初始大小为16，加载因子为3/4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">有原始集合数据进行初始化的情况下，会对 HashMap 的初始容量进行计算</span></span><br><span class="line"><span class="comment"> 取括号中两个数的最大值（期望的值 / 0.75+1，默认值 16）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-方法"><a href="#3-5-方法" class="headerlink" title="3.5 方法"></a>3.5 方法</h2><p>至于 HashSet 的其他方法就比较简单了，就是对 Map 的 api 进行了一些包装，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全部都是map的key值的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><p>从源码看出，HashSet复用HashMap的代码，使用聚合的方式进行复用，所以下文主要以分析HashMap为主。</p><h1 id="4-HashMap"><a href="#4-HashMap" class="headerlink" title="4 HashMap"></a>4 HashMap</h1><h2 id="4-1-整体框架"><a href="#4-1-整体框架" class="headerlink" title="4.1 整体框架"></a>4.1 整体框架</h2><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时，链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构如下图：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114435.png" alt="图片描述" title="" class="">                <p>图片描述</p>            </figure><p>图中左边竖着的是 HashMap 的数组结构，数组的元素可能是单个 Node，也可能是个链表，也可能是个红黑树，比如数组下标索引为 2 的位置就是一个链表，下标索引为 9 的位置对应的就是红黑树。</p><h2 id="4-2-类注释"><a href="#4-2-类注释" class="headerlink" title="4.2 类注释"></a>4.2 类注释</h2><p>从 HashMap 的类注释中，我们可以得到如下信息：</p><ul><li>允许 null 值，不同于 HashTable ，是线程不安全的；</li><li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor；</li><li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能；</li><li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过 Collections.synchronizedMap 来实现线程安全，Collections.synchronizedMap 的实现是在每个方法上加上了 synchronized 锁；或者使用ConcurrentHashMap，下文也会对ConcurrentHashMap进行简单阐述。</li><li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li></ul><h2 id="4-3-属性"><a href="#4-3-属性" class="headerlink" title="4.3 属性"></a>4.3 属性</h2><p>属性源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认数组初始化大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组最大大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载系数，用于数组数量达到 CAPACITY*LOAD_FACTOR（默认为12）时，对数组进行扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表树化的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树链化的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> * 当数组容量大于 64 时，链表才会转化成红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的节点</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"> //红黑树的节点</span></span><br><span class="line"><span class="class"> <span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h2><h3 id="4-1-1-指定加载因子以及初始大小"><a href="#4-1-1-指定加载因子以及初始大小" class="headerlink" title="4.1.1 指定加载因子以及初始大小"></a>4.1.1 指定加载因子以及初始大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-2-指定初始化大小"><a href="#4-1-2-指定初始化大小" class="headerlink" title="4.1.2 指定初始化大小"></a>4.1.2 指定初始化大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-空参构造"><a href="#4-1-3-空参构造" class="headerlink" title="4.1.3 空参构造"></a>4.1.3 空参构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-4-数据集合构造"><a href="#4-1-4-数据集合构造" class="headerlink" title="4.1.4 数据集合构造"></a>4.1.4 数据集合构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.putAll and Map constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><p>4.2.1 hash方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hashCode右移16位，正好是32bit的一半。与自己本身做异或操作（相同为0，不同为1）。就是为了混合哈希值的高位和地位，增加低位的随机性。并且混合后的值也变相保持了高位的特征。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-1-新增-put与putVal-："><a href="#4-2-1-新增-put与putVal-：" class="headerlink" title="4.2.1 新增(put与putVal)："></a>4.2.1 新增(put与putVal)：</h3><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 key，value 大概的步骤如下：</p><ol><li>空数组有无初始化，没有的话初始化；</li><li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li><li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li><li>如果是链表，递归循环，把新元素追加到队尾；</li><li>如果是红黑树，调用红黑树新增的方法；</li><li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li><li>判断是否需要扩容，需要扩容进行扩容，结束。</li></ol><p>我们来画一张示意图来描述下：</p><p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114448.jpg" alt="图片描述" style="zoom:67%;"></p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参 hash：通过 hash 算法计算出来的值。</span></span><br><span class="line"><span class="comment">// 入参 onlyIfAbsent：false 表示即使 key 已经存在了，仍然会用新值覆盖原来的值，默认为 false</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// n 表示数组的长度，i 为数组索引下标，p 为 i 下标位置的 Node 值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果数组为空，使用 resize 方法初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果当前索引位置有值的处理方法，即我们常说的如何解决 hash 冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e 当前节点的临时变量</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果 key 的 hash 和值都相等，直接把当前下标位置的 Node 值赋值给临时变量</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是红黑树，使用红黑树的方式新增</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 是个链表，把新节点放到链表的尾端</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// e = p.next 表示从头开始，遍历链表</span></span><br><span class="line">                <span class="comment">// p.next == null 表明 p 是链表的尾节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 把新节点放到链表的尾部 </span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 当链表的长度大于等于 8 时，链表转红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 链表遍历过程中，发现有元素和新增的元素相等，结束循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//更改循环的当前元素，使 p 在遍历过程中，一直往后移动。</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明新节点的新增位置已经找到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// 当 onlyIfAbsent 为 false 时，才会覆盖值 </span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录 HashMap 的数据结构发生了变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果 HashMap 的实际大小大于扩容的门槛，开始扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-链表的新增"><a href="#4-2-2-链表的新增" class="headerlink" title="4.2.2 链表的新增"></a>4.2.2 链表的新增</h3><p>链表的新增比较简单，就是把当前节点追加到链表的尾部，和 LinkedList 的追加实现一样的。</p><p>当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组大小小于 64 时，只会触发扩容，不会转化成红黑树，</p><p><strong>为什么是8</strong></p><blockquote><p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p><p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各个长度的命中概率为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; * <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line">&gt; * <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line">&gt; * <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line">&gt; * <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line">&gt; * <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line">&gt; * <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line">&gt; * <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line">&gt; * <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line">&gt; * <span class="number">8</span>:    <span class="number">0.00000006</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写代码，使用 HashMap 时，几乎不会碰到链表转化成红黑树的情况，毕竟概念只有千万分之一。</p></blockquote><h3 id="4-2-2-红黑树新增节点过程"><a href="#4-2-2-红黑树新增节点过程" class="headerlink" title="4.2.2 红黑树新增节点过程"></a>4.2.2 红黑树新增节点过程</h3><ol><li><p>首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种：</p><p>1.1. 如果节点没有实现 Comparable 接口，使用 equals 进行判断；</p><p>1.2. 如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。</p></li><li><p>新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大；</p></li><li><p>自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点；</p></li><li><p>把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系；</p></li><li><p>进行着色和旋转，结束</p></li></ol><h3 id="4-2-3-resize（）-扩容并重新计算大小"><a href="#4-2-3-resize（）-扩容并重新计算大小" class="headerlink" title="4.2.3 resize（）:扩容并重新计算大小"></a>4.2.3 resize（）:扩容并重新计算大小</h3><p>当HashMap容量大小不够时，就需要扩容，调用的就是resize()方法，下面对resize进行分析。</p><p>先看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// 原索引存放的引用</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// 原索引+oldCap存放的引用</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                       <span class="comment">/*</span></span><br><span class="line"><span class="comment">                       取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作</span></span><br><span class="line"><span class="comment">                     （也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。</span></span><br><span class="line"><span class="comment">                      */</span></span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e; <span class="comment">// 头插法</span></span><br><span class="line">                            loTail = e; <span class="comment">// 头插法</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解释</p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114503.jpg)" alt="img" title="" class="">                <p>img</p>            </figure><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114509.jpg" alt="img" title="" class="">                <p>img</p>            </figure><p>对index计算的解释</p><p>1.如果旧表数组index只有一个元素，则直接计算新值<code>newTab[e.hash &amp; (newCap - 1)] = e;</code></p><p>2.如果旧表数组index是链表，则执行一下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;                      <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">&gt;                          <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">&gt;                              loHead = e;</span><br><span class="line">&gt;                          <span class="keyword">else</span></span><br><span class="line">&gt;                              loTail.next = e; <span class="comment">// 头插法</span></span><br><span class="line">&gt;                          loTail = e; <span class="comment">// 头插法</span></span><br><span class="line">&gt;                      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 原索引+oldCap</span></span><br><span class="line">&gt;                          <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">&gt;                              hiHead = e;</span><br><span class="line">&gt;                          <span class="keyword">else</span></span><br><span class="line">&gt;                              hiTail.next = e;</span><br><span class="line">&gt;                          hiTail = e;</span><br><span class="line">&gt;                      &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>为什么是e.hash &amp; oldCap？</p><p>(e.hash &amp; oldCap) 得到的是 元素的在数组中的位置是否需要移动,示例如下<br>示例1：<br>e.hash=10 0000 1010<br>oldCap=16 0001 0000<br>     &amp;   =0     0000 0000       比较高位的第一位 0<br>结论：元素位置在扩容后数组中的位置没有发生改变</p><p>示例2：<br>e.hash=17 0001 0001<br>oldCap=16 0001 0000<br>     &amp;   =1     0001 0000      比较高位的第一位   1<br>结论：元素位置在扩容后数组中的位置发生了改变，新的下标位置是原下标位置+原数组长度</p></blockquote><h1 id="5-ConcurrentHashMap"><a href="#5-ConcurrentHashMap" class="headerlink" title="5 ConcurrentHashMap"></a>5 ConcurrentHashMap</h1><p>当我们碰到线程不安全场景下，需要使用 Map 的时候，我们第一个想到的 API 估计就是 ConcurrentHashMap，ConcurrentHashMap 内部封装了锁和各种数据结构来保证访问 Map 是线程安全的，接下来我们一一来看下，和 HashMap 相比，多了哪些数据结构，又是如何保证线程安全的。</p><h2 id="5-1-结构"><a href="#5-1-结构" class="headerlink" title="5.1 结构"></a>5.1 结构</h2><p>虽然 ConcurrentHashMap 的底层数据结构，和方法的实现细节和 HashMap 大体一致，但两者在类结构上却没有任何关联，我们看下 ConcurrentHashMap 的类图：<br><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114518.png" alt="图片描述" title="" class="">                <p>图片描述</p>            </figure><br>看 ConcurrentHashMap 源码，我们会发现很多方法和代码和 HashMap 很相似，有的同学可能会问，为什么不继承 HashMap 呢？继承的确是个好办法，但尴尬的是，ConcurrentHashMap 都是在方法中间进行一些加锁操作，也就是说加锁把方法切割了，继承就很难解决这个问题。</p><h3 id="5-1-1-两者的相同之处："><a href="#5-1-1-两者的相同之处：" class="headerlink" title="5.1.1 两者的相同之处："></a>5.1.1 两者的相同之处：</h3><ol><li>数组、链表结构几乎相同，所以底层对数据结构的操作思路是相同的（只是思路相同，底层实现不同）；</li><li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都是相同的，HashMap 有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap 时，无需关心两者之间的兼容问题。</li></ol><h3 id="5-1-2-不同之处："><a href="#5-1-2-不同之处：" class="headerlink" title="5.1.2 不同之处："></a>5.1.2 不同之处：</h3><ol><li>红黑树结构略有不同，HashMap 的红黑树中的节点叫做 TreeNode，TreeNode 不仅仅有属性，还维护着红黑树的结构，比如说查找，新增等等；ConcurrentHashMap 中红黑树被拆分成两块，TreeNode 仅仅维护的属性和查找功能，新增了 TreeBin，来维护红黑树结构，并负责根节点的加锁和解锁；</li><li>新增 ForwardingNode （转移）节点，扩容的时候会使用到，通过使用该节点，来保证扩容时的线程安全。</li></ol><p>如下图所示：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114526" alt="img" title="" class="">                <p>img</p>            </figure><h2 id="5-2-类注释"><a href="#5-2-类注释" class="headerlink" title="5.2 类注释"></a>5.2 类注释</h2><p>我们从类注释上大概可以得到如下信息：</p><ol><li>所有的操作都是线程安全的，我们在使用时，无需再加锁；</li><li>多个线程同时进行 put、remove 等操作时并不会阻塞，可以同时进行，和 HashTable 不同，HashTable 在操作时，会锁住整个 Map；</li><li>迭代过程中，即使 Map 结构被修改，也不会抛 ConcurrentModificationException 异常；</li><li>除了数组 + 链表 + 红黑树的基本结构外，新增了转移节点，是为了保证扩容时的线程安全的节点；</li><li>提供了很多 Stream 流式方法，比如说：forEach、search、reduce 等等。</li></ol><p>从类注释中，我们可以看出 ConcurrentHashMap 和 HashMap 相比，新增了转移节点的数据结构，至于底层如何实现线程安全，转移节点的具体细节，暂且看不出来，接下来我们细看源码</p><h2 id="5-3-属性"><a href="#5-3-属性" class="headerlink" title="5.3 属性"></a>5.3 属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7249069246763182397L</span>;</span><br><span class="line">    <span class="comment">// 表的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认表的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 最大数组大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 默认并发数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 装载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 转化为红黑树的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 由红黑树转化为链表的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 转化为红黑树的表的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 每次进行转移的最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 生成sizeCtl所使用的bit位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 进行扩容所允许的最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 记录sizeCtl中的大小所需要进行的偏移位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;    </span><br><span class="line">    <span class="comment">// 一系列的标识</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">/** Number of CPUS, to place bounds on some sizings */</span></span><br><span class="line">    <span class="comment">// 获取可用的CPU个数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">/** For serialization compatibility. */</span></span><br><span class="line">    <span class="comment">// 进行序列化的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">"segments"</span>, Segment[].class),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">"segmentMask"</span>, Integer.TYPE),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">"segmentShift"</span>, Integer.TYPE)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">// 下一个表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base counter value, used mainly when there is no contention,</span></span><br><span class="line"><span class="comment">     * but also as a fallback during table initialization</span></span><br><span class="line"><span class="comment">     * races. Updated via CAS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 基本计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">     * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">     * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">     * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">     * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">     * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 对表初始化和扩容控制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next table index (plus one) to split while resizing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 扩容下另一个表的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 旋转锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// counterCell表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// views</span></span><br><span class="line">    <span class="comment">// 视图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">            SIZECTL = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"sizeCtl"</span>));</span><br><span class="line">            TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"transferIndex"</span>));</span><br><span class="line">            BASECOUNT = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"baseCount"</span>));</span><br><span class="line">            CELLSBUSY = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"cellsBusy"</span>));</span><br><span class="line">            Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">            CELLVALUE = U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">            Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">            ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">            <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">            <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"data type scale not a power of two"</span>);</span><br><span class="line">            ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-方法"><a href="#5-4-方法" class="headerlink" title="5.4 方法"></a>5.4 方法</h2><h3 id="5-4-1-新增元素（putVal）"><a href="#5-4-1-新增元素（putVal）" class="headerlink" title="5.4.1 新增元素（putVal）"></a>5.4.1 新增元素（putVal）</h3><p>put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。</p><p>　　① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②</p><p>　　② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③</p><p>　　③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④</p><p>　　④ 若该结点的的hash值为<strong>MOVED，则对该桶中的结点进行转移（协助转换）</strong>，否则，进入步骤⑤</p><p>　　⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥</p><p>　　⑥ 若<strong>binCount</strong>值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// 键或值为空，抛出异常</span></span><br><span class="line">        <span class="comment">// 键的hash值经过计算获得hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 表为空或者表的长度为0</span></span><br><span class="line">                <span class="comment">// 初始化表</span></span><br><span class="line">                tab = initTable();<span class="comment">//里面使用sizeCtl控制多线程争用问题，cas修改sizeCtl</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123; <span class="comment">// 表不为空并且表的长度大于0，并且该桶不为空</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>))) <span class="comment">// 比较并且交换值，如tab的第i项为空则用新生成的node替换</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// 该结点的hash值为MOVED</span></span><br><span class="line">                <span class="comment">// 进行结点的转移（在扩容的过程中）</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 加锁同步</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 找到table表下标为i的节点</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 该table表中该结点的hash值大于0</span></span><br><span class="line">                            <span class="comment">// binCount赋值为1</span></span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123; <span class="comment">// 结点的hash值相等并且key也相等</span></span><br><span class="line">                                    <span class="comment">// 保存该结点的val值</span></span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent) <span class="comment">// 进行判断</span></span><br><span class="line">                                        <span class="comment">// 将指定的value保存至结点，即进行了结点值的更新</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 保存当前结点</span></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 当前结点的下一个结点为空，即为最后一个结点</span></span><br><span class="line">                                    <span class="comment">// 新生一个结点并且赋值给next域</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="comment">// 退出循环</span></span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 结点为红黑树结点类型</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            <span class="comment">// binCount赋值为2</span></span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123; <span class="comment">// 将hash、key、value放入红黑树</span></span><br><span class="line">                                <span class="comment">// 保存结点的val</span></span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent) <span class="comment">// 判断</span></span><br><span class="line">                                    <span class="comment">// 赋值结点value值</span></span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; <span class="comment">// binCount不为0</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) <span class="comment">// 如果binCount大于等于转化为红黑树的阈值</span></span><br><span class="line">                        <span class="comment">// 进行转化</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) <span class="comment">// 旧值不为空</span></span><br><span class="line">                        <span class="comment">// 返回旧值</span></span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加binCount的数量</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>我想有基础的同学知道在jdk1.7中是采用Segment + HashEntry + ReentrantLock的方式进行实现的，而1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。</p><ul><li><p>JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而<strong>JDK1.8锁的粒度就是HashEntry（首节点）</strong></p></li><li><p>JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了</p></li><li><p>JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</p></li></ul></blockquote><h3 id="5-4-2-扩容及协助扩容"><a href="#5-4-2-扩容及协助扩容" class="headerlink" title="5.4.2 扩容及协助扩容"></a>5.4.2 扩容及协助扩容</h3><p>当put的时候，有下面这样一句代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该结点的hash值为MOVED</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) </span><br><span class="line"><span class="comment">// 进行结点的转移（在扩容的过程中）</span></span><br><span class="line">tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure><p>所以，每个线程都会去帮助正在扩容的map去扩容——协助扩容。</p><p>通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable，扩容后的数组长度为原来的两倍，但是容量是原来的1.5。</p><p>节点从table移动到nextTable，大体思想是遍历、复制的过程。</p><ol><li>首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd。</li><li><p>如果f == null，则在table中的i位置放入fwd，这个过程是采用Unsafe.compareAndSwapObjectf方法实现的，很巧妙的实现了节点的并发移动。</p></li><li><p>如果f是链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上，移动完成，采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。</p></li><li><p>如果f是TreeBin节点，也做一个反序处理，并判断是否需要untreeify，把处理的结果分别放在nextTable的i和i+n的位置上，移动完成，同样采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。</p></li></ol><p>遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍 ，扩容完成。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A node inserted at head of bins during transfer operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">        outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> eh; K ek;</span><br><span class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                        <span class="keyword">continue</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>大家平时都特别喜欢用map这个集合，但是有一个问题得注意一下：jdk1.7HashMap与jdk1.8concurrenthashmap出现的死循环问题（map.computeIfAbsent这个函数，有兴趣的可以去看下源码，有机会为大家解说一波）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在1.8中ConcurrentHashMap的get操作全程不需要加锁，这也是它比其他并发集合比如hashtable、用Collections.synchronizedMap()包装的hashmap;安全效率高的原因之一。</li><li>get操作全程不需要加锁是因为Node的成员val是用volatile修饰的和数组用volatile修饰没有关系。</li><li>数组用volatile修饰主要是保证在数组扩容的时候保证可见性。</li></ul><p>以上就是我对集合类的一些看法，大家有什么问题，及时提出更正！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java集合源码分析&quot;&gt;&lt;a href=&quot;#java集合源码分析&quot; class=&quot;headerlink&quot; title=&quot;java集合源码分析&quot;&gt;&lt;/a&gt;java集合源码分析&lt;/h1&gt;&lt;p&gt;大家平时在用java写代码的时候，使用的数据结构最多的就是java自己封装好的集合类。但是当我们使用这些封装好的集合类的时候，不了解底层原理，或多或少就会碰到由于不知道底层原理，导致开发时忽略的细节，造成开发甚至是生产方面的BUG。防微杜渐，产品的质量是计划出来的，未雨绸缪的。所以，下面就java常用集合专题，揭开java集合的神秘面纱。包括ArrayList；LinkedList；HashSet；HashMap；线程安全的ConcurrentHashMap。我会将个人理解与源代码结合，将个人解读写在源代码注释中，边看源码边学习。&lt;/p&gt;
&lt;h1 id=&quot;1-ArrayList&quot;&gt;&lt;a href=&quot;#1-ArrayList&quot; class=&quot;headerlink&quot; title=&quot;1 ArrayList&quot;&gt;&lt;/a&gt;1 ArrayList&lt;/h1&gt;&lt;h2 id=&quot;1-1-整体架构&quot;&gt;&lt;a href=&quot;#1-1-整体架构&quot; class=&quot;headerlink&quot; title=&quot;1.1 整体架构&quot;&gt;&lt;/a&gt;1.1 整体架构&lt;/h2&gt;&lt;p&gt;ArrayList 整体架构比较简单，就是一个数组结构，比较简单，如下图：&lt;/p&gt;
&lt;figure class=&quot;image-box&quot;&gt;
                &lt;img src=&quot;https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114356.png&quot; alt=&quot;图片描述&quot; title=&quot;&quot; class=&quot;&quot;&gt;
                &lt;p&gt;图片描述&lt;/p&gt;
            &lt;/figure&gt;
&lt;p&gt;图中展示是长度为 10 的数组，从 1 开始计数，index 表示数组的下标，从 0 开始计数，elementData 表示数组本身，源码中除了这两个概念，还有以下三个基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；&lt;/li&gt;
&lt;li&gt;size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；&lt;/li&gt;
&lt;li&gt;modCount 统计当前数组被修改的版本次数，数组结构有变动，就会 +1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是源码：&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/tags/java/"/>
    
      <category term="集合" scheme="http://www.sjsmile.cn/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>spring的一些问题</title>
    <link href="http://www.sjsmile.cn/2020/09/24/java/spring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://www.sjsmile.cn/2020/09/24/java/spring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</id>
    <published>2020-09-24T14:13:34.000Z</published>
    <updated>2020-09-24T14:15:06.269Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是三级缓存"><a href="#什么是三级缓存" class="headerlink" title="什么是三级缓存"></a>什么是三级缓存</h1><ol><li>第一级缓存：单例缓存池singletonObjects。</li><li>第二级缓存：早期提前暴露的对象缓存earlySingletonObjects。（属性还没有值对象也没有被初始化）</li><li>第三级缓存：singletonFactories单例对象工厂缓存。</li></ol><p>三级缓存详解：<a href="http://mp.weixin.qq.com/s?__biz=Mzg2MjEwMjI1Mg==&amp;mid=2247494504&amp;idx=1&amp;sn=12da3bdc73d03bafb6c3de586f828b2f&amp;chksm=ce0e5cebf979d5fd61cc6f5fef26f83436a3799aaf79872fa475ca11f8821f6a723b448dd232&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">根据 Spring 源码写一个带有三级缓存的 IOC</a></p><a id="more"></a><h1 id="Spring如何解决循环依赖问题"><a href="#Spring如何解决循环依赖问题" class="headerlink" title="Spring如何解决循环依赖问题"></a>Spring如何解决循环依赖问题</h1><p>Spring使用了三级缓存解决了循环依赖的问题。在populateBean()给属性赋值阶段里面Spring会解析你的属性，并且赋值，当发现，A对象里面依赖了B，此时又会走getBean方法，但这个时候，你去缓存中是可以拿的到的。因为我们在对createBeanInstance对象创建完成以后已经放入了缓存当中，所以创建B的时候发现依赖A，直接就从缓存中去拿，此时B创建完，A也创建完，一共执行了4次。至此Bean的创建完成，最后将创建好的Bean放入单例缓存池中。</p><p>BeanFactory和ApplicationContext的区别</p><ol><li>BeanFactory是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能。</li><li>ApplicationContext应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能。如国际化，访问资源，载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，消息发送、响应机制，AOP等。</li><li>BeanFactory在启动的时候不会去实例化Bean，中有从容器中拿Bean的时候才会去实例化。ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化</li></ol><h1 id="动态代理的实现方式，AOP的实现方式"><a href="#动态代理的实现方式，AOP的实现方式" class="headerlink" title="动态代理的实现方式，AOP的实现方式"></a>动态代理的实现方式，AOP的实现方式</h1><ol><li>JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</li><li>CGlib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li><li>区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。</li></ol><h1 id="Transactional错误使用失效场景"><a href="#Transactional错误使用失效场景" class="headerlink" title="@Transactional错误使用失效场景"></a>@Transactional错误使用失效场景</h1><ol><li>@Transactional 在private上：当标记在protected、private、package-visible方法上时，不会产生错误，但也不会表现出为它指定的事务配置。可以认为它作为一个普通的方法参与到一个public方法的事务中。</li><li>@Transactional 的事务传播方式配置错误。</li><li>@Transactional 注解属性 rollbackFor 设置错误：Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。</li><li>同一个类中方法调用，导致@Transactional失效：由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</li><li>异常被 catch 捕获导致@Transactional失效。</li><li>数据库引擎不支持事务。</li></ol><h1 id="Spring的的事务传播机制"><a href="#Spring的的事务传播机制" class="headerlink" title="Spring的的事务传播机制"></a>Spring的的事务传播机制</h1><ol><li>REQUIRED（默认，常用）：支持使用当前事务，如果当前事务不存在，创建一个新事务。eg:方法B用REQUIRED修饰，方法A调用方法B，如果方法A当前没有事务，方法B就新建一个事务（若还有C则B和C在各自的事务中独立执行），如果方法A有事务，方法B就加入到这个事务中，当成一个事务。</li><li>SUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。</li><li>MANDATORY：强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。</li><li>REQUIRES_NEW（常用）：创建一个新事务，如果当前事务存在，把当前事务挂起。eg:方法B用REQUIRES_NEW修饰，方法A调用方法B，不管方法A上有没有事务方法B都新建一个事务，在该事务执行。</li><li>NOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起。</li><li>NEVER：无事务执行，如果当前有事务则抛出Exception。</li><li>NESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</li></ol><h1 id="Spring中Bean的生命周期"><a href="#Spring中Bean的生命周期" class="headerlink" title="Spring中Bean的生命周期"></a>Spring中Bean的生命周期</h1><ol><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ol><h1 id="Spring的后置处理器"><a href="#Spring的后置处理器" class="headerlink" title="Spring的后置处理器"></a>Spring的后置处理器</h1><ol><li>BeanPostProcessor：Bean的后置处理器，主要在bean初始化前后工作。（before和after两个回调中间只处理了init-method）</li><li>InstantiationAwareBeanPostProcessor：继承于BeanPostProcessor，主要在实例化bean前后工作（TargetSource的AOP创建代理对象就是通过该接口实现）</li><li>BeanFactoryPostProcessor：Bean工厂的后置处理器，在bean定义(bean definitions)加载完成后，bean尚未初始化前执行。</li><li>BeanDefinitionRegistryPostProcessor：继承于BeanFactoryPostProcessor。其自定义的方法postProcessBeanDefinitionRegistry会在bean定义(bean definitions)将要加载，bean尚未初始化前真执行，即在BeanFactoryPostProcessor的postProcessBeanFactory方法前被调用。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是三级缓存&quot;&gt;&lt;a href=&quot;#什么是三级缓存&quot; class=&quot;headerlink&quot; title=&quot;什么是三级缓存&quot;&gt;&lt;/a&gt;什么是三级缓存&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;第一级缓存：单例缓存池singletonObjects。&lt;/li&gt;
&lt;li&gt;第二级缓存：早期提前暴露的对象缓存earlySingletonObjects。（属性还没有值对象也没有被初始化）&lt;/li&gt;
&lt;li&gt;第三级缓存：singletonFactories单例对象工厂缓存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三级缓存详解：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjEwMjI1Mg==&amp;amp;mid=2247494504&amp;amp;idx=1&amp;amp;sn=12da3bdc73d03bafb6c3de586f828b2f&amp;amp;chksm=ce0e5cebf979d5fd61cc6f5fef26f83436a3799aaf79872fa475ca11f8821f6a723b448dd232&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;根据 Spring 源码写一个带有三级缓存的 IOC&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/tags/java/"/>
    
      <category term="spring" scheme="http://www.sjsmile.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>HashMap详解</title>
    <link href="http://www.sjsmile.cn/2020/09/24/java/HashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.sjsmile.cn/2020/09/24/java/HashMap%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-09-24T12:59:56.000Z</published>
    <updated>2020-10-04T03:50:20.394Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>HashMap是基于哈希表实现的,每一个元素是一个key-value对,其内部通过单链表解决冲突问题,容量不足(超过了阀值)时,同样会自动增长.</p><p>HashMap是非线程安全的,只适用于单线程环境,多线程环境可以采用并发包下的concurrentHashMap</p><p>HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆</p><p>HashMap是基于哈希表的Map接口的非同步实现.此实现提供所有可选的映射操作,并允许使用null值和null键.此类不保证映射的顺序,特别是它不保证该顺序恒久不变.</p><p>Java8中又对此类底层实现进行了优化，比如引入了红黑树的结构以解决哈希碰撞</p><a id="more"></a><h3 id="2-HashMap的数据结构"><a href="#2-HashMap的数据结构" class="headerlink" title="2 HashMap的数据结构"></a>2 HashMap的数据结构</h3><p>在Java中,最基本的结构就是两种,一个是数组,另外一个是模拟指针(引用),所有的数据结构都可以用这两个基本结构来构造,HashMap也不例外. HashMap实际上是一个”链表散列”的数据结构,即数组和链表的结合体.<figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114618" alt="img" title="" class="">                <p>img</p>            </figure></p><p>HashMap的主结构类似于一个数组,添加值时通过key确定储存位置.<br>每个位置是一个Entry的数据结构,该结构可组成链表.<br>当发生冲突时,相同hash值的键值对会组成链表.<br>这种数组+链表的组合形式大部分情况下都能有不错的性能效果,Java6、7就是这样设计的. 然而,在极端情况下,一组（比如经过精心设计的）键值对都发生了冲突，这时的哈希结构就会退化成一个链表，使HashMap性能急剧下降.</p><p>所以在Java8中,HashMap的结构实现变为数组+链表+红黑树<figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114625.jpg" alt="img" title="" class="">                <p>img</p>            </figure></p><p>可以看出,HashMap底层就是一个数组结构<br>数组中的每一项又是一个链表<br>当新建一个HashMap时,就会初始化一个数组.</p><h3 id="3-三大集合与迭代子"><a href="#3-三大集合与迭代子" class="headerlink" title="3 三大集合与迭代子"></a>3 三大集合与迭代子</h3><p>HashMap使用三大集合和三种迭代子来轮询其Key、Value和Entry对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            map.put(i, <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;(<span class="keyword">char</span>) (<span class="string">'A'</span>+ i)&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"======keySet======="</span>);</span><br><span class="line">        Set set = map.keySet();</span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"======values======="</span>);</span><br><span class="line">        Collection values = map.values();</span><br><span class="line">        Iterator stringIterator=values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (stringIterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(stringIterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"======entrySet======="</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4 源码分析"></a>4 源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量16,且实际容量是2的整数幂 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//最大容量(传入容量过大将被这个值替换)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认加载因子为0.75(当表达到3/4满时,才会再散列),这个因子在时间和空间代价之间达到了平衡.更高的因子可以降低表所需的空间,但是会增加查找代价,而查找是最频繁操作</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">//桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 &gt;= 8时，则将链表转换成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">   <span class="comment">// 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt;= 6时，则将 红黑树转换成链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">   <span class="comment">//最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）</span></span><br></pre></td></tr></table></figure><p>因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要<br>链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短</p><p>还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换<br>假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了避免扩容/树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line">    <span class="comment">// 小于该值时使用的是扩容哦!!!</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储数据的Node数组,长度是2的幂.    </span></span><br><span class="line">    <span class="comment">// HashMap采用链表法解决冲突，每一个Node本质上是一个单向链表 </span></span><br><span class="line">    <span class="comment">//HashMap底层存储的数据结构,是一个Node数组.上面得知Node类为元素维护了一个单向链表.至此,HashMap存储的数据结构也就很清晰了:维护了一个数组,每个数组又维护了一个单向链表.之所以这么设计,考虑到遇到哈希冲突的时候,同index的value值就用单向链表来维护</span></span><br><span class="line">    <span class="comment">//与 JDK 1.7 的对比（Entry类），仅仅只是换了名字</span></span><br><span class="line">    <span class="keyword">transient</span> Node[] table;</span><br><span class="line">    <span class="comment">// HashMap的底层数组中已用槽的数量 </span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） </span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子实际大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    <span class="comment">// HashMap被改变的次数 </span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 指定“容量大小”和“加载因子”的构造函数,是最基础的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY                                       </span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//负载因子须大于0</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="comment">// 设置"负载因子"                                        </span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 设置"HashMap阈值",当HashMap中存储数据的数量达到threshold时,就需将HashMap的容量加倍    </span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的tableSizeFor有何用?<br>tableSizeFor方法保证函数返回值是大于等于给定参数initialCapacity最小的2的幂次方的数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> (n = MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">a |= b 等同于 a = a|b</span><br></pre></td></tr></table></figure><p>逐行分析</p><ul><li>int n = cap - 1<br>给定的cap 减 1,为了避免参数cap本来就是2的幂次方,这样一来,经过后续操作，cap将会变成2 * cap,是不符合我们预期的</li><li>n |= n &gt;&gt;&gt; 1<br>n &gt;&gt;&gt; 1 : n无符号右移1位,即n二进制最高位的1右移一位<br>n | (n &gt;&gt;&gt; 1) 导致 n二进制的高2位值为1<br>目前n的高1~2位均为1</li><li>n |= n &gt;&gt;&gt; 2<br>n继续无符号右移2位<br>n | (n &gt;&gt;&gt; 2) 导致n二进制表示的高34位经过运算值均为1<br>目前n的高14位均为1</li><li>n |= n &gt;&gt;&gt; 4<br>n继续无符号右移4位<br>n | (n &gt;&gt;&gt; 4) 导致n二进制表示的高58位经过运算值均为1<br>目前n的高18位均为1</li><li>n |= n &gt;&gt;&gt; 8<br>n继续无符号右移8位<br>n | (n &gt;&gt;&gt; 8) 导致n二进制表示的高916位经过运算值均为1<br>目前n的高116位均为1</li></ul><p>可以看出,无论给定cap(cap &lt; MAXIMUM_CAPACITY )的值是多少,经过以上运算,其值的二进制所有位都会是1.再将其加1,这时候这个值一定是2的幂次方.<br>当然如果经过运算值大于MAXIMUM_CAPACITY,直接选用MAXIMUM_CAPACITY.</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114638" alt="img" title="" class="">                <p>img</p>            </figure><p>至此tableSizeFor如何保证cap为2的幂次方已经显而易见了,那么问题来了</p><h4 id="4-1-为什么cap要保持为2的幂次方？"><a href="#4-1-为什么cap要保持为2的幂次方？" class="headerlink" title="4.1 为什么cap要保持为2的幂次方？"></a>4.1 为什么cap要保持为2的幂次方？</h4><p>主要与HashMap中的数据存储有关.</p><p>在Java8中,HashMap中key的Hash值由Hash(key)方法计得<br><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114644.jpg" alt="img" title="" class="">                <p>img</p>            </figure></p><p>HashMap中存储数据table的index是由key的Hash值决定的.<br>在HashMap存储数据时,我们期望数据能均匀分布,以防止哈希冲突.<br>自然而然我们就会想到去用%取余操作来实现我们这一构想</p><p><em>取余(%)操作 : 如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作.</em></p><p>这也就解释了为什么一定要求cap要为2的幂次方.再来看看table的index的计算规则：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114650.jpg" alt="img" title="" class="">                <p>img</p>            </figure><p>等价于:<br><code>index = e.hash % newCap</code></p><p>采用二进制位操作&amp;,相对于%,能够提高运算效率,这就是cap的值被要求为2幂次的原因</p><figure class="image-box">                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114658.jpg)![img" title="" class="">                <p>img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114658.jpg)![img</p>            </figure><h4 id="4-2-Node类"><a href="#4-2-Node类" class="headerlink" title="4.2 Node类"></a>4.2 Node类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry e = (Map.Entry)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Node 类是HashMap中的静态内部类,实现Map.Entry接口.定义了key键、value值、next节点,也就是说元素之间构成了单向链表.</p><h4 id="4-3-TreeNode"><a href="#4-3-TreeNode" class="headerlink" title="4.3 TreeNode"></a>4.3 TreeNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span> </span>&#123;</span><br><span class="line">        TreeNode parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node next) &#123;&#125;</span><br><span class="line">        <span class="comment">// 返回当前节点的根节点  </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode <span class="title">root</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">for</span> (TreeNode r = <span class="keyword">this</span>, p;;) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)  </span><br><span class="line">                <span class="keyword">return</span> r;  </span><br><span class="line">            r = p;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>红黑树结构包含前、后、左、右节点，以及标志是否为红黑树的字段<br>此结构是Java8新加的</p><h4 id="4-4-hash方法"><a href="#4-4-hash方法" class="headerlink" title="4.4 hash方法"></a>4.4 hash方法</h4><p>Java 8中的散列值优化函数<figure class="image-box">                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">                <p>img</p>            </figure></p><p>只做一次16位右位移异或<br>key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值</p><p>理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int范围大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。<br>但问题是一个40亿长度的数组，内存是放不下的.HashMap扩容之前的数组初始大小才16,所以这个散列值是不能直接拿来用的.<br>用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标<br>源码中模运算就是把散列值和数组长度做一个”与”操作，<br><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114709.jpg" alt="img" title="" class="">                <p>img</p>            </figure></p><p>这也正好解释了为什么HashMap的数组长度要取2的整次幂<br>因为这样（数组长度-1）正好相当于一个“低位掩码”<br>“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问</p><p>以初始长度16为例，16-1=15<br>2进制表示是00000000 00000000 00001111<br>和某散列值做“与”操作如下，结果就是截取了最低的四位值<br><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114729.jpg" alt="img" title="" class="">                <p>img</p>            </figure></p><p>但这时候问题就来了,这样就算我的散列值分布再松散,要是只取最后几位的话,碰撞也会很严重</p><p>这时候“扰动函数”的价值就体现出来了<br><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114736.jpg" alt="img" title="" class="">                <p>img</p>            </figure></p><p>右位移16位，正好是32位一半，自己的高半区和低半区做异或，就是为了混合原始hashCode的高位和低位，以此来加大低位的随机性<br>而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><p>index的运算规则是<br><code>e.hash &amp; (newCap - 1)</code><br>newCap是2的幂,所以newCap - 1的高位全0</p><p>若e.hash值只用自身的hashcode,index只会和e.hash的低位做&amp;操作.这样一来,index的值就只有低位参与运算,高位毫无存在感,从而会带来哈希冲突的风险<br>所以在计算key的hashCode时,用其自身hashCode与其低16位做异或操作<br>这也就让高位参与到index的计算中来了,即降低了哈希冲突的风险又不会带来太大的性能问题</p><h4 id="4-5-Put方法"><a href="#4-5-Put方法" class="headerlink" title="4.5 Put方法"></a>4.5 Put方法</h4><figure class="image-box">                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">                <p>img</p>            </figure><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114759.jpg" alt="img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114744.jpg)![img" title="" class="">                <p>img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114744.jpg)![img</p>            </figure><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，执行resize()扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node[] tab; Node p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 步骤① tab为空则调用resize()初始化创建</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)         </span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 步骤② 计算index,并对null做处理  </span></span><br><span class="line">        <span class="comment">//tab[i = (n - 1) &amp; hash对应下标的第一个节点   </span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 无哈希冲突的情况下,将value直接封装为Node并赋值</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node e; K k;</span><br><span class="line">            <span class="comment">// 步骤③ 节点的key相同,直接覆盖节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 步骤④ 判断该链为红黑树    </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 <span class="comment">// p是红黑树类型，则调用putTreeVal方式赋值</span></span><br><span class="line">                e = ((TreeNode)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 步骤⑤ p非红黑树类型,该链为链表    </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// index 相同的情况下</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果p的next为空,将新的value值添加至链表后面</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                            <span class="comment">// 如果链表长度大于8,链表转化为红黑树,执行插入</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// key相同则跳出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;  ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//就是移动指针方便继续取 p.next</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">//根据规则选择是否覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 步骤⑥:超过最大容量,就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">// size大于加载因子,扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在构造函数中最多也只是设置了initialCapacity、loadFactor的值,并没有初始化table,table的初始化工作是在put方法中进行的.</p><h4 id="4-6-resize"><a href="#4-6-resize" class="headerlink" title="4.6 resize"></a>4.6 resize</h4><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114807.jpg" alt="img" title="" class="">                <p>img</p>            </figure><p>扩容(resize)就是重新计算容量,向HashMap对象里不停的添加元素,内部的数组无法装载更多的元素时,就需要扩大数组的长度.<br>当然Java里的数组是无法自动扩容的,方法是使用一个新的数组代替已有的容量小的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该函数有2种使用情况：1.初始化哈希表 2.当前数组容量过小，需扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">final</span> Node[] resize() &#123;</span><br><span class="line">        Node[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 针对情况2：若扩容前的数组容量超过最大值，则不再扩充</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 针对情况2：若无超过最大值，就扩充为原来的2倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">//newCap设置为oldCap的2倍并小于MAXIMUM_CAPACITY，且大于默认值, 新的threshold增加为原来的2倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 针对情况1：初始化哈希表（采用指定 or 默认值）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">// threshold&gt;0, 将threshold设置为newCap,所以要用tableSizeFor方法保证threshold是2的幂次方</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">// 默认初始化</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算新的resize上限</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// newThr为0，newThr = newCap * 0.75</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            <span class="comment">// 新生成一个table数组</span></span><br><span class="line">            Node[] newTab = (Node[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// oldTab 复制到 newTab</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="comment">// 链表只有一个节点，直接赋值</span></span><br><span class="line">                       <span class="comment">//为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">// e为红黑树的情况</span></span><br><span class="line">                        ((TreeNode)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order链表优化重hash的代码块</span></span><br><span class="line">                        Node loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 原索引</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114831.jpg" alt="img" title="" class="">                <p>img</p>            </figure><h4 id="4-7-remove方法"><a href="#4-7-remove方法" class="headerlink" title="4.7 remove方法"></a>4.7 remove方法</h4><p>remove(key) 方法 和 remove(key, value) 方法都是通过调用removeNode的方法来实现删除元素的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node[] tab; Node p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// index 元素只有一个元素</span></span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// index处是一个红黑树</span></span><br><span class="line">                    node = ((TreeNode)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// index处是一个链表，遍历链表返回node</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分不同情形删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-8-get"><a href="#4-8-get" class="headerlink" title="4.8 get"></a>4.8 get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 函数原型</span></span><br><span class="line"><span class="comment">   * 作用：根据键key，向HashMap获取对应的值</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   map.get(key)；</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 源码分析</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node e;</span><br><span class="line">    <span class="comment">// 1\. 计算需获取数据的hash值</span></span><br><span class="line">    <span class="comment">// 2\. 通过getNode（）获取所查询的数据 -&gt;&gt;分析1</span></span><br><span class="line">    <span class="comment">// 3\. 获取后，判断数据是否为空</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1：getNode(hash(key), key))</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node[] tab; Node first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 1\. 计算存放在数组table中的位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 4\. 通过该函数，依次在数组、红黑树、链表中查找（通过equals（）判断）</span></span><br><span class="line">        <span class="comment">// a. 先在数组中找，若存在，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// b. 若数组中没有，则到红黑树中寻找</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// c. 若红黑树中也没有，则通过遍历，到链表中寻找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>在JDK1.7及以前的版本中，HashMap里是没有红黑树的实现的，在JDK1.8中加入了红黑树是为了防止哈希表碰撞攻击，当链表链长度为8时，及时转成红黑树，提高map的效率</em></p><p>如果某个桶中的记录过大的话（当前是TREEIFY_THRESHOLD = 8），HashMap会动态的使用一个专门的treemap实现来替换掉它。这样做的结果会更好，是O(logn)，而不是糟糕的O(n)。它是如何工作的？前面产生冲突的那些KEY对应的记录只是简单的追加到一个链表后面，这些记录只能通过遍历来进行查找。但是超过这个阈值后HashMap开始将列表升级成一个二叉树，使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入。这对HashMap的key来说并不是必须的，不过如果实现了当然最好。如果没有实现这个接口，在出现严重的哈希碰撞的时候，你就并别指望能获得性能提升了。</p><p>这个性能提升有什么用处？比方说恶意的程序，如果它知道我们用的是哈希算法，它可能会发送大量的请求，导致产生严重的哈希碰撞。然后不停的访问这些key就能显著的影响服务器的性能，这样就形成了一次拒绝服务攻击（DoS）。JDK 8中从O(n)到O(logn)的飞跃，可以有效地防止类似的攻击，同时也让HashMap性能的可预测性稍微增强了一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 源码分析：resize(2 * table.length)</span></span><br><span class="line"><span class="comment">   * 作用：当容量不足时（容量 &gt; 阈值），则扩容（扩到2倍）</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 1\. 保存旧数组（old table） </span></span><br><span class="line">    Entry[] oldTable = table;  </span><br><span class="line">    <span class="comment">// 2\. 保存旧容量（old capacity ），即数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length; </span><br><span class="line">    <span class="comment">// 3\. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出    </span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">        threshold = Integer.MAX_VALUE;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 4\. 根据新容量（2倍容量）新建1个数组，即新table  </span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  </span><br><span class="line">    <span class="comment">// 5\. （重点分析）将旧数组上的数据（键值对）转移到新table中，从而完成扩容 -&gt;&gt;分析1.1 </span></span><br><span class="line">    transfer(newTable); </span><br><span class="line">    <span class="comment">// 6\. 新数组table引用到HashMap的table属性上</span></span><br><span class="line">    table = newTable;  </span><br><span class="line">    <span class="comment">// 7\. 重新设置阈值  </span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor); </span><br><span class="line">&#125; </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 分析1.1：transfer(newTable); </span></span><br><span class="line"><span class="comment">   * 作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容</span></span><br><span class="line"><span class="comment">   * 过程：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1\. src引用了旧数组</span></span><br><span class="line">      Entry[] src = table; </span><br><span class="line">      <span class="comment">// 2\. 获取新数组的大小 = 获取新容量大小                 </span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="comment">// 3\. 通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">          <span class="comment">// 3.1 取得旧数组的每个元素  </span></span><br><span class="line">          Entry e = src[j];           </span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 3.2 释放旧数组的对象引用（for循环后，旧数组不再引用任何对象）</span></span><br><span class="line">              src[j] = <span class="keyword">null</span>; </span><br><span class="line">              <span class="keyword">do</span> &#123; </span><br><span class="line">                  <span class="comment">// 3.3 遍历 以该数组元素为首 的链表</span></span><br><span class="line">                  <span class="comment">// 注：转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开</span></span><br><span class="line">                  Entry next = e.next; </span><br><span class="line">                 <span class="comment">// 3.3 重新计算每个元素的存储位置</span></span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                 <span class="comment">// 3.4 将元素放在数组上：采用单链表的头插入方式 = 在链表头上存放数据 = 将数组位置的原有数据放在后1个指针、将需放入的数据放到数组位置中</span></span><br><span class="line">                 <span class="comment">// 即 扩容后，可能出现逆序：按旧链表的正序遍历链表、在新链表的头部依次插入</span></span><br><span class="line">                 e.next = newTable[i]; </span><br><span class="line">                 newTable[i] = e;  </span><br><span class="line">                 <span class="comment">// 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点</span></span><br><span class="line">                 e = next;             </span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">             <span class="comment">// 如此不断循环，直到遍历完数组上的所有数据元素</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面可看出：在扩容resize（）过程中，在将旧数组上的数据 转移到 新数组上时，转移数据操作 = 按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况</p><p><strong>设重新计算存储位置后不变，即扩容前 = 1-&gt;2-&gt;3，扩容后 = 3-&gt;2-&gt;1</strong></p><p>此时若并发执行 put 操作，一旦出现扩容情况，则 容易出现 环形链表，从而在获取数据、遍历链表时 形成死循环（Infinite Loop），即死锁<br><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114931" alt="img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)![img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114856.jpg)![img" title="" class="">                <p>img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)![img](https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114856.jpg)![img</p>            </figure></p><h3 id="单线程rehash"><a href="#单线程rehash" class="headerlink" title="单线程rehash"></a>单线程rehash</h3><p>单线程情况下，rehash无问题<figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114944.jpg" alt="img" title="" class="">                <p>img</p>            </figure></p><h3 id="多线程并发下的rehash"><a href="#多线程并发下的rehash" class="headerlink" title="多线程并发下的rehash"></a>多线程并发下的rehash</h3><p>这里假设有两个线程同时执行了put操作并引发了rehash，执行了transfer方法，并假设线程一进入transfer方法并执行完next = e.next后，因为线程调度所分配时间片用完而“暂停”，此时线程二完成了transfer方法的执行。此时状态如下。<br><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004114952.jpg" alt="img" title="" class="">                <p>img</p>            </figure></p><p>接着线程1被唤醒，继续执行第一轮循环的剩余部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[<span class="number">1</span>] = <span class="keyword">null</span></span><br><span class="line">newTable[<span class="number">1</span>] = e = key(<span class="number">5</span>)</span><br><span class="line">e = next = key(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>结果如下图所示<figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004115001.jpg" alt="img" title="" class="">                <p>img</p>            </figure></p><p>接着执行下一轮循环，结果状态图如下所示<figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/20201004115011" alt="img" title="" class="">                <p>img</p>            </figure></p><p>继续下一轮循环，结果状态图如下所示<figure class="image-box">                <img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img" title="" class="">                <p>img</p>            </figure></p><p>此时循环链表形成，并且key(11)无法加入到线程1的新数组。在下一次访问该链表时会出现死循环。</p><h3 id="Fast-fail"><a href="#Fast-fail" class="headerlink" title="Fast-fail"></a>Fast-fail</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>在使用迭代器的过程中如果HashMap被修改，那么ConcurrentModificationException将被抛出，也即Fast-fail策略。</p><p>当HashMap的iterator()方法被调用时，会构造并返回一个新的EntryIterator对象，并将EntryIterator的expectedModCount设置为HashMap的modCount（该变量记录了HashMap被修改的次数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">  expectedModCount = modCount;</span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">  Entry[] t = table;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在通过该Iterator的next方法访问下一个Entry时，它会先检查自己的expectedModCount与HashMap的modCount是否相等，如果不相等，说明HashMap被修改，直接抛出ConcurrentModificationException。该Iterator的remove方法也会做类似的检查。该异常的抛出意在提醒用户及早意识到线程安全问题。</p><h3 id="线程安全解决方案"><a href="#线程安全解决方案" class="headerlink" title="线程安全解决方案"></a>线程安全解决方案</h3><p>单线程条件下，为避免出现ConcurrentModificationException，需要保证只通过HashMap本身或者只通过Iterator去修改数据，不能在Iterator使用结束之前使用HashMap本身的方法修改数据。因为通过Iterator删除数据时，HashMap的modCount和Iterator的expectedModCount都会自增，不影响二者的相等性。如果是增加数据，只能通过HashMap本身的方法完成，此时如果要继续遍历数据，需要重新调用iterator()方法从而重新构造出一个新的Iterator，使得新Iterator的expectedModCount与更新后的HashMap的modCount相等。</p><p>多线程条件下，可使用Collections.synchronizedMap方法构造出一个同步Map，或者直接使用线程安全的ConcurrentHashMap。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h3&gt;&lt;p&gt;HashMap是基于哈希表实现的,每一个元素是一个key-value对,其内部通过单链表解决冲突问题,容量不足(超过了阀值)时,同样会自动增长.&lt;/p&gt;
&lt;p&gt;HashMap是非线程安全的,只适用于单线程环境,多线程环境可以采用并发包下的concurrentHashMap&lt;/p&gt;
&lt;p&gt;HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆&lt;/p&gt;
&lt;p&gt;HashMap是基于哈希表的Map接口的非同步实现.此实现提供所有可选的映射操作,并允许使用null值和null键.此类不保证映射的顺序,特别是它不保证该顺序恒久不变.&lt;/p&gt;
&lt;p&gt;Java8中又对此类底层实现进行了优化，比如引入了红黑树的结构以解决哈希碰撞&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/tags/java/"/>
    
      <category term="HashMap" scheme="http://www.sjsmile.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>每个程序员都应该懂点cURL</title>
    <link href="http://www.sjsmile.cn/2020/09/06/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E6%87%82%E7%82%B9cURL/"/>
    <id>http://www.sjsmile.cn/2020/09/06/%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E6%87%82%E7%82%B9cURL/</id>
    <published>2020-09-06T11:50:19.000Z</published>
    <updated>2020-09-06T12:19:04.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>cURL 是常用的命令行工具，它的名字就是客户端（client）的 URL 工具的意思，如果熟练的话，完全可以取代 Postman 这一类的图形界面工具，但是多数情况可以用 cURL 快速的验证一下请求的正确性，所以一些基本用法我们还是值得学习的。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li><p>发起 GET 请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>指定 User-Agent 发起 GET 请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -A 'Mozilla/5.0' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>自定义 Header</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H 'User-Agent:Mozilla/5.0' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>发送 Cookies</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -b 'gt=octocat' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure><p>这个命令等同于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H 'Cookies:gt=octocat' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>发送 POST 请求，携带 username 参数，-d 命令会自带 <code>Content-Type : application/x-www-form-urlencoded</code> 的请求类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -d'username=july' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>设置 Referer 为 <code>https://google.com</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -e 'https://google.com' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><ul><li><p>上传图片</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F 'file=@photo.png;type=image/png' https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>打印 Response 返回的内容，包括 Header</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>打印 request 请求的信息，包括 Header</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>跳过 SSL 检测。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -k https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>模拟弱网请求，10K/s 请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --limit-rate 10k https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>输出通信的整个过程，用于调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v https://api.github.com/users/octocat</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cURL 是常用的命令行工具，它的名字就是客户端（client）的 URL 工具的意思，如果熟练的话，完全可以取代 Postman 这一类的图形界面工具，但是多数情况可以用 cURL 快速的验证一下请求的正确性，所以一些基本用法我们还是值得学习的。&lt;/p&gt;
&lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发起 GET 请求&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl https://api.github.com/users/octocat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;指定 User-Agent 发起 GET 请求&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl -A &#39;Mozilla/5.0&#39; https://api.github.com/users/octocat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://www.sjsmile.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="http" scheme="http://www.sjsmile.cn/categories/%E7%BD%91%E7%BB%9C/http/"/>
    
    
      <category term="http" scheme="http://www.sjsmile.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>为什么String的hashCode选择31作为乘子?</title>
    <link href="http://www.sjsmile.cn/2020/09/06/java/%E4%B8%BA%E4%BB%80%E4%B9%88String%E7%9A%84hashCode%E9%80%89%E6%8B%A931%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/"/>
    <id>http://www.sjsmile.cn/2020/09/06/java/%E4%B8%BA%E4%BB%80%E4%B9%88String%E7%9A%84hashCode%E9%80%89%E6%8B%A931%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/</id>
    <published>2020-09-06T11:34:47.000Z</published>
    <updated>2020-09-06T11:47:12.480Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> String hashCode 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 hashCode 方法核心的计算逻辑只有三行，也就是代码中的 for 循环。我们可以由上面的 for 循环推导出一个计算公式，hashCode 方法注释中已经给出。如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span><br></pre></td></tr></table></figure><p>这里说明一下，上面的 s 数组即源码中的 val 数组，是 String 内部维护的一个 char 类型数组。这里我来简单推导一下这个公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设 n=3</span><br><span class="line">i=0 -&gt; h = 31 * 0 + val[0]</span><br><span class="line">i=1 -&gt; h = 31 * (31 * 0 + val[0]) + val[1]</span><br><span class="line">i=2 -&gt; h = 31 * (31 * (31 * 0 + val[0]) + val[1]) + val[2]</span><br><span class="line">       h = 31*31*31*0 + 31*31*val[0] + 31*val[1] + val[2]</span><br><span class="line">       h = 31^(n-1)*val[0] + 31^(n-2)*val[1] + val[2]</span><br></pre></td></tr></table></figure><p>上面的公式包括公式的推导并不是本文的重点，大家了解了解即可。接下来来说说本文的重点，即选择31的理由。从网上的资料来看，一般有如下两个原因：</p><p>第一 31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。另外一些相近的质数，比如37、41、43等等，也都是不错的选择。那么为啥偏偏选中了31呢？请看第二个原因。</p><p>第二 31可以被 JVM 优化，<code>31 * i = (i &lt;&lt; 5) - i</code>。</p><p>上面两个原因中，第一个需要解释一下，第二个比较简单，就不说了。下面我来解释第一个理由。一般在设计哈希算法时，会选择一个特殊的质数。至于为啥选择质数，我想应该是可以降低哈希算法的冲突率。至于原因，这个就要问数学家了，我几乎可以忽略的数学水平解释不了这个原因。上面说到，31是一个不大不小的质数，是优选乘子。那为啥同是质数的2和101（或者更大的质数）就不是优选乘子呢，分析如下。</p><p>这里先分析质数2。首先，假设<code>n = 6</code>，然后把质数2和 n 带入上面的计算公式。并仅计算公式中次数最高的那一项，结果是<code>2^5 = 32</code>，是不是很小。所以这里可以断定，当字符串长度不是很长时，用质数2做为乘子算出的哈希值，数值不会很大。也就是说，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升。</p><p>上面说了，质数2做为乘子会导致哈希值分布在一个较小区间内，那么如果用一个较大的大质数101会产生什么样的结果呢？根据上面的分析，我想大家应该可以猜出结果了。就是不用再担心哈希值会分布在一个小的区间内了，因为<code>101^5 = 10,510,100,501</code>。但是要注意的是，这个计算结果太大了。如果用 int 类型表示哈希值，结果会溢出，最终导致数值信息丢失。尽管数值信息丢失并不一定会导致冲突率上升，但是我们暂且先认为质数101（或者更大的质数）也不是很好的选择。最后，我们再来看看质数31的计算结果：<code>31^5 = 28629151</code>，结果值相对于<code>32</code>和<code>10,510,100,501</code>来说。是不是很nice，不大不小。</p><p>上面用了比较简陋的数学手段证明了数字31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。</p><p>接下来我会用详细的实验来验证上面的结论，不过在验证前，我们先看看 Stack Overflow 上关于这个问题的讨论，Why does Java’s hashCode() in String use 31 as a multiplier? （地址：<a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier）。其中排名第一的答案引用了《Effective" target="_blank" rel="noopener">https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier）。其中排名第一的答案引用了《Effective</a> Java》中的一段话，这里也引用一下：</p><blockquote><p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: <code>31 * i == (i &lt;&lt; 5) - i</code>. Modern VMs do this sort of optimization automatically.</p></blockquote><p>简单翻译一下：</p><blockquote><p>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：<code>31 * i == (i &lt;&lt; 5) - i</code>，现代的 Java 虚拟机可以自动的完成这个优化。</p></blockquote><p>排名第二的答案设这样说的：</p><blockquote><p>As Goodrich and Tamassia point out, If you take over 50,000 English words (formed as the union of the word lists provided in two variants of Unix), using the constants 31, 33, 37, 39, and 41 will produce less than 7 collisions in each case. Knowing this, it should come as no surprise that many Java implementations choose one of these constants.</p></blockquote><p>这段话也翻译一下：</p><blockquote><p>正如 Goodrich 和 Tamassia 指出的那样，如果你对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个，所以在上面几个常数中，常数 31 被 Java 实现所选用也就不足为奇了。</p></blockquote><p>上面的两个答案完美的解释了 Java 源码中选用数字 31 的原因。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>经过上面的分析与实践，我想大家应该明白了 String hashCode 方法中选择使用数字31作为乘子的原因了。本文本质是一篇简单的科普文而已，并没有银弹。如果大家读完后觉得又涨知识了，那这篇文章的目的就达到了。最后，本篇文章的配图画的还是很辛苦的，所以如果大家觉得文章不错，不妨就给个赞吧，就当是对我的鼓励了。</p><p>另外，如果文章中有不妥或者错误的地方，也欢迎指出来。</p><p>来源：<a href="http://blog.ouyangsihai.cn/" target="_blank" rel="noopener">http://blog.ouyangsihai.cn/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; String hashCode 方法源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; h = hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (h == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; value.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; val[] = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; value.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            h = &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt; * h + val[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        hash = h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际上 hashCode 方法核心的计算逻辑只有三行，也就是代码中的 for 循环。我们可以由上面的 for 循环推导出一个计算公式，hashCode 方法注释中已经给出。如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>看完让你彻底理解 WebSocket 原理</title>
    <link href="http://www.sjsmile.cn/2020/08/02/%E7%9C%8B%E5%AE%8C%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3-WebSocket-%E5%8E%9F%E7%90%86/"/>
    <id>http://www.sjsmile.cn/2020/08/02/%E7%9C%8B%E5%AE%8C%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3-WebSocket-%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-02T06:40:00.000Z</published>
    <updated>2020-09-06T11:46:52.449Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载:<a href="https://www.cnblogs.com/nnngu/p/9347635.html" target="_blank" rel="noopener">点击查看原文</a></p></blockquote><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>最近有同学问我有没有做过在线咨询功能。同时，公司也刚好让我接手一个 IM 项目。所以今天抽时间记录一下最近学习的内容。</p><p>本文主要剖析了 WebSocket 的原理，以及附上一个完整的聊天室实战 Demo （包含前端和后端，代码下载链接在文末）。</p><h2 id="2、WebSocket-与-HTTP"><a href="#2、WebSocket-与-HTTP" class="headerlink" title="2、WebSocket 与 HTTP"></a>2、WebSocket 与 HTTP</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。现在所有浏览器都已经支持了。WebSocket 的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。</p><p>HTTP 有 1.1 和 1.0 之说，也就是所谓的 keep-alive ，把多个 HTTP 请求合并为一个，但是 Websocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器，所以在握手阶段使用了 HTTP 。</p><p>下面一张图说明了 HTTP 与 WebSocket 的主要区别：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596350538206.webp" alt="" title="" class="">                <p></p>            </figure><a id="more"></a><p>WebSocket 的其他特点：</p><ul><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信。</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li></ul><h2 id="3、WebSocket-是什么样的协议，具体有什么优点"><a href="#3、WebSocket-是什么样的协议，具体有什么优点" class="headerlink" title="3、WebSocket 是什么样的协议，具体有什么优点"></a>3、WebSocket 是什么样的协议，具体有什么优点</h2><p>首先，WebSocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说。简单的举个例子吧，用目前应用比较广泛的 PHP 生命周期来解释。</p><p>HTTP 的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。</p><p>在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response， 在 HTTP 中永远是这样，也就是说一个 Request 只能有一个 Response。而且这个 Response 也是被动的，不能主动发起。</p><p>你 BB 了这么多，跟 WebSocket 有什么关系呢？好吧，我正准备说 WebSocket 呢。</p><p>首先 WebSocket 是基于 HTTP 协议的，或者说借用了 HTTP 协议来完成一部分握手。</p><p>首先我们来看个典型的 WebSocket 握手</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>熟悉 HTTP 的童鞋可能发现了，这段类似 HTTP 协议的握手请求中，多了这么几个东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>这个就是 WebSocket 的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的请求要用 WebSocket 协议，快点帮我找到对应的助理处理~而不是那个老土的 HTTP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><p>首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠我，我要验证你是不是真的是 WebSocket 助理。</p><p>然后， Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~</p><p>最后， Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft （协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用同一个版本：服务员，我要的是13岁的噢→_→</p><p>然后服务器会返回下列东西，表示已经接受到请求， 成功建立 WebSocket 啦！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><p>这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure><p>依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mozillasocket，lurnarsocket 或者 shitsocket。</p><p>然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧。</p><p>后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。</p><p>至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了。</p><h2 id="4、WebSocket-的作用"><a href="#4、WebSocket-的作用" class="headerlink" title="4、WebSocket 的作用"></a>4、WebSocket 的作用</h2><p>在讲 WebSocket之前，我就顺带着讲下 ajax轮询 和 long poll 的原理。</p><h3 id="4-1、ajax轮询"><a href="#4-1、ajax轮询" class="headerlink" title="4-1、ajax轮询"></a>4-1、ajax轮询</h3><p>ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</p><p><strong>场景再现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line"></span><br><span class="line">服务端：没有（Response）</span><br><span class="line"></span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line"></span><br><span class="line">服务端：没有。。（Response）</span><br><span class="line"></span><br><span class="line">客户端：啦啦啦，有没有新信息(Request)</span><br><span class="line"></span><br><span class="line">服务端：你好烦啊，没有啊。。（Response）</span><br><span class="line"></span><br><span class="line">客户端：啦啦啦，有没有新消息（Request）</span><br><span class="line"></span><br><span class="line">服务端：好啦好啦，有啦给你。（Response）</span><br><span class="line"></span><br><span class="line">客户端：啦啦啦，有没有新消息（Request）</span><br><span class="line"></span><br><span class="line">服务端：。。。。。没。。。。没。。。没有（Response） —- loop</span><br></pre></td></tr></table></figure><h3 id="4-2、long-poll"><a href="#4-2、long-poll" class="headerlink" title="4-2、long poll"></a>4-2、long poll</h3><p>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起请求后，如果没消息，就一直不返回 Response 给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</p><p><strong>场景再现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）</span><br><span class="line"></span><br><span class="line">服务端：额。。 等待到有消息的时候。。来 给你（Response）</span><br><span class="line"></span><br><span class="line">客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop</span><br></pre></td></tr></table></figure><p><strong>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。</strong></p><p>何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。</p><p>从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。</p><p>ajax轮询 需要服务器有很快的处理速度和资源。long poll 需要有很高的并发，也就是说同时接待客户的能力。</p><p>所以 ajax轮询 和 long poll 都有可能发生这种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">客户端：啦啦啦啦，有新信息么？</span><br><span class="line"></span><br><span class="line">服务端：正忙，请稍后再试（503 Server Unavailable）</span><br><span class="line"></span><br><span class="line">客户端：。。。。好吧，啦啦啦，有新信息么？</span><br><span class="line"></span><br><span class="line">服务端：正忙，请稍后再试（503 Server Unavailable）</span><br></pre></td></tr></table></figure><h3 id="4-3、WebSocket"><a href="#4-3、WebSocket" class="headerlink" title="4-3、WebSocket"></a>4-3、WebSocket</h3><p>通过上面这两个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。</p><p>一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。</p><p>哦对了，忘记说了 HTTP 还是一个无状态协议。通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。</p><p>所以在这种情况下出现了 WebSocket 。他解决了 HTTP 的这几个难题。首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。所以上面的情景可以做如下修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request）</span><br><span class="line"></span><br><span class="line">服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched）</span><br><span class="line"></span><br><span class="line">客户端：麻烦你有信息的时候推送给我噢。。</span><br><span class="line"></span><br><span class="line">服务端：ok，有的时候会告诉你的。</span><br><span class="line"></span><br><span class="line">服务端：balabalabalabala</span><br><span class="line"></span><br><span class="line">服务端：balabalabalabala</span><br><span class="line"></span><br><span class="line">服务端：哈哈哈哈哈啊哈哈哈哈</span><br><span class="line"></span><br><span class="line">服务端：笑死我了哈哈哈哈哈哈哈</span><br></pre></td></tr></table></figure><p>这样，只需要经过一次 HTTP 请求，就可以做到源源不断的信息传送了。</p><h2 id="5、实战代码"><a href="#5、实战代码" class="headerlink" title="5、实战代码"></a>5、实战代码</h2><p>本文的更新源 托管于GitHub</p><p>参考文档：</p><blockquote><p><a href="http://php.net/manual/zh/ref.sockets.php" target="_blank" rel="noopener">http://php.net/manual/zh/ref.sockets.php</a> <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</a></p></blockquote><p>前端代码：<a href="https://github.com/nnngu/WebSocketDemo-js" target="_blank" rel="noopener">https://github.com/nnngu/WebSocketDemo-js</a><br>后端代码：<a href="https://github.com/nnngu/WebSocketDemo-php" target="_blank" rel="noopener">https://github.com/nnngu/WebSocketDemo-php</a></p><p>运行步骤：</p><ol><li>在终端打开 <code>WebSocketDemo-php</code> 目录，执行 <code>php -q server.php</code></li><li>用浏览器访问 <code>WebSocketDemo-js</code> 目录里面的 <code>index.html</code></li></ol><p>运行截图：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596350538215.webp" alt="" title="" class="">                <p></p>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载:&lt;a href=&quot;https://www.cnblogs.com/nnngu/p/9347635.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;最近有同学问我有没有做过在线咨询功能。同时，公司也刚好让我接手一个 IM 项目。所以今天抽时间记录一下最近学习的内容。&lt;/p&gt;
&lt;p&gt;本文主要剖析了 WebSocket 的原理，以及附上一个完整的聊天室实战 Demo （包含前端和后端，代码下载链接在文末）。&lt;/p&gt;
&lt;h2 id=&quot;2、WebSocket-与-HTTP&quot;&gt;&lt;a href=&quot;#2、WebSocket-与-HTTP&quot; class=&quot;headerlink&quot; title=&quot;2、WebSocket 与 HTTP&quot;&gt;&lt;/a&gt;2、WebSocket 与 HTTP&lt;/h2&gt;&lt;p&gt;WebSocket 协议在2008年诞生，2011年成为国际标准。现在所有浏览器都已经支持了。WebSocket 的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。&lt;/p&gt;
&lt;p&gt;HTTP 有 1.1 和 1.0 之说，也就是所谓的 keep-alive ，把多个 HTTP 请求合并为一个，但是 Websocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器，所以在握手阶段使用了 HTTP 。&lt;/p&gt;
&lt;p&gt;下面一张图说明了 HTTP 与 WebSocket 的主要区别：&lt;/p&gt;
&lt;figure class=&quot;image-box&quot;&gt;
                &lt;img src=&quot;https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596350538206.webp&quot; alt=&quot;&quot; title=&quot;&quot; class=&quot;&quot;&gt;
                &lt;p&gt;&lt;/p&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
      <category term="网络" scheme="http://www.sjsmile.cn/categories/java/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="WebSocket" scheme="http://www.sjsmile.cn/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>最简单的 6 种防止数据重复提交的方法！</title>
    <link href="http://www.sjsmile.cn/2020/08/02/java/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-6-%E7%A7%8D%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%81/"/>
    <id>http://www.sjsmile.cn/2020/08/02/java/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-6-%E7%A7%8D%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%81/</id>
    <published>2020-08-02T06:30:10.000Z</published>
    <updated>2020-08-02T06:50:50.272Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载:<a href="https://mp.weixin.qq.com/s/kOADZRd5hI1H-7_zuXJsAw" target="_blank" rel="noopener">点击查看原文</a></p></blockquote><h2 id="模拟用户场景"><a href="#模拟用户场景" class="headerlink" title="模拟用户场景"></a>模拟用户场景</h2><p>根据朋友的反馈，大致的场景是这样的，如下图所示：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/微信图片_20200802143342.gif" alt="" title="" class="">                <p></p>            </figure><a id="more"></a><p>简化的模拟代码如下（基于 Spring Boot）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被重复请求的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是磊哥就想到：通过前、后端分别拦截的方式来解决数据重复提交的问题。</p><h2 id="前端拦截"><a href="#前端拦截" class="headerlink" title="前端拦截"></a>前端拦截</h2><p>前端拦截是指通过 HTML 页面来拦截重复请求，比如在用户点击完“提交”按钮后，我们可以把按钮设置为不可用或者隐藏状态。</p><p>执行效果如下图所示：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/微信图片_20200802143537.gif" alt="" title="" class="">                <p></p>            </figure><p>前端拦截的实现代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    function subCli()&#123;</span></span><br><span class="line"><span class="undefined">        // 按钮设置为不可用</span></span><br><span class="line"><span class="undefined">        document.getElementById("btn_sub").disabled="disabled";</span></span><br><span class="line"><span class="undefined">        document.getElementById("dv1").innerText = "按钮被点击了~";</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"margin-top: 100px;margin-left: 100px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btn_sub"</span> <span class="attr">type</span>=<span class="string">"button"</span>  <span class="attr">value</span>=<span class="string">" 提 交 "</span>  <span class="attr">onclick</span>=<span class="string">"subCli()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dv1"</span> <span class="attr">style</span>=<span class="string">"margin-top: 80px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但前端拦截有一个致命的问题，如果是懂行的程序员或非法用户可以直接绕过前端页面，通过模拟请求来重复提交请求，比如充值了 100 元，重复提交了 10 次变成了 1000 元（瞬间发现了一个致富的好办法）。</p><p>所以除了前端拦截一部分正常的误操作之外，后端的拦截也是必不可少。</p><h2 id="后端拦截"><a href="#后端拦截" class="headerlink" title="后端拦截"></a>后端拦截</h2><p>后端拦截的实现思路是在方法执行之前，先判断此业务是否已经执行过，如果执行过则不再执行，否则就正常执行。</p><p>我们将请求的业务 ID 存储在内存中，并且通过添加互斥锁来保证多线程下的程序执行安全，大体实现思路如下图所示：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/image-20200802143638247.png" alt="" title="" class="">                <p></p>            </figure><p>然而，将数据存储在内存中，最简单的方法就是使用 <code>HashMap</code> 存储，或者是使用 Guava Cache 也是同样的效果，但很显然 <code>HashMap</code> 可以更快的实现功能，所以我们先来实现一个 <code>HashMap</code> 的防重（防止重复）版本。</p><h3 id="1-基础版——HashMap"><a href="#1-基础版——HashMap" class="headerlink" title="1.基础版——HashMap"></a>1.基础版——HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通 Map 版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存 ID 集合</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; reqCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断(忽略)...</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="comment">// 重复请求判断</span></span><br><span class="line">            <span class="keyword">if</span> (reqCache.containsKey(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存储请求 ID</span></span><br><span class="line">            reqCache.put(id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果如下图所示：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/微信图片_20200802143707.gif" alt="" title="" class="">                <p></p>            </figure><p><strong>存在的问题</strong>：此实现方式有一个致命的问题，因为 <code>HashMap</code> 是无限增长的，因此它会占用越来越多的内存，并且随着 <code>HashMap</code> 数量的增加查找的速度也会降低，所以我们需要实现一个可以自动“清除”过期数据的实现方案。</p><h3 id="2-优化版——固定大小的数组"><a href="#2-优化版——固定大小的数组" class="headerlink" title="2.优化版——固定大小的数组"></a>2.优化版——固定大小的数组</h3><p>此版本解决了 <code>HashMap</code> 无限增长的问题，它使用数组加下标计数器（reqCacheCounter）的方式，实现了固定数组的循环存储。</p><p>当数组存储到最后一位时，将数组的存储下标设置 0，再从头开始存储数据，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] reqCache = <span class="keyword">new</span> String[<span class="number">100</span>]; <span class="comment">// 请求 ID 存储集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer reqCacheCounter = <span class="number">0</span>; <span class="comment">// 请求计数器（指示 ID 存储的位置）</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断(忽略)...</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="comment">// 重复请求判断</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.asList(reqCache).contains(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录请求 ID</span></span><br><span class="line">            <span class="keyword">if</span> (reqCacheCounter &gt;= reqCache.length) reqCacheCounter = <span class="number">0</span>; <span class="comment">// 重置计数器</span></span><br><span class="line">            reqCache[reqCacheCounter] = id; <span class="comment">// 将 ID 保存到缓存</span></span><br><span class="line">            reqCacheCounter++; <span class="comment">// 下标往后移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-扩展版——双重检测锁-DCL"><a href="#3-扩展版——双重检测锁-DCL" class="headerlink" title="3.扩展版——双重检测锁(DCL)"></a>3.扩展版——双重检测锁(DCL)</h3><p>上一种实现方法将判断和添加业务，都放入 <code>synchronized</code> 中进行加锁操作，这样显然性能不是很高，于是我们可以使用单例中著名的 DCL（Double Checked Locking，双重检测锁）来优化代码的执行效率，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] reqCache = <span class="keyword">new</span> String[<span class="number">100</span>]; <span class="comment">// 请求 ID 存储集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer reqCacheCounter = <span class="number">0</span>; <span class="comment">// 请求计数器（指示 ID 存储的位置）</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断(忽略)...</span></span><br><span class="line">        <span class="comment">// 重复请求判断</span></span><br><span class="line">        <span class="keyword">if</span> (Arrays.asList(reqCache).contains(id)) &#123;</span><br><span class="line">            <span class="comment">// 重复请求</span></span><br><span class="line">            System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="comment">// 双重检查锁（DCL,double checked locking）提高程序的执行效率</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.asList(reqCache).contains(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录请求 ID</span></span><br><span class="line">            <span class="keyword">if</span> (reqCacheCounter &gt;= reqCache.length) reqCacheCounter = <span class="number">0</span>; <span class="comment">// 重置计数器</span></span><br><span class="line">            reqCache[reqCacheCounter] = id; <span class="comment">// 将 ID 保存到缓存</span></span><br><span class="line">            reqCacheCounter++; <span class="comment">// 下标往后移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：DCL 适用于重复提交频繁比较高的业务场景，对于相反的业务场景下 DCL 并不适用。</p></blockquote><h3 id="4-完善版——LRUMap"><a href="#4-完善版——LRUMap" class="headerlink" title="4.完善版——LRUMap"></a>4.完善版——LRUMap</h3><p>上面的代码基本已经实现了重复数据的拦截，但显然不够简洁和优雅，比如下标计数器的声明和业务处理等，但值得庆幸的是 Apache 为我们提供了一个 commons-collections 的框架，里面有一个非常好用的数据结构 <code>LRUMap</code> 可以保存指定数量的固定的数据，并且它会按照 LRU 算法，帮你清除最不常用的数据。</p><blockquote><p>小贴士：LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的数据淘汰算法，选择最近最久未使用的数据予以淘汰。</p></blockquote><p>首先，我们先来添加 Apache commons collections 的引用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 集合工具类 apache commons collections --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-collections4 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.map.LRUMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大容量 100 个，根据 LRU 算法淘汰数据的 Map 集合</span></span><br><span class="line">    <span class="keyword">private</span> LRUMap&lt;String, Integer&gt; reqCache = <span class="keyword">new</span> LRUMap&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断(忽略)...</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            <span class="comment">// 重复请求判断</span></span><br><span class="line">            <span class="keyword">if</span> (reqCache.containsKey(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存储请求 ID</span></span><br><span class="line">            reqCache.put(id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了 <code>LRUMap</code> 之后，代码显然简洁了很多。</p><h3 id="5-最终版——封装"><a href="#5-最终版——封装" class="headerlink" title="5.最终版——封装"></a>5.最终版——封装</h3><p>以上都是方法级别的实现方案，然而在实际的业务中，我们可能有很多的方法都需要防重，那么接下来我们就来封装一个公共的方法，以供所有类使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.map.LRUMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 幂等性判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdempotentUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 LRU(Least Recently Used，最近最少使用)算法淘汰数据的 Map 集合，最大容量 100 个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LRUMap&lt;String, Integer&gt; reqCache = <span class="keyword">new</span> LRUMap&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 幂等性判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(String id, Object lockClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockClass) &#123;</span><br><span class="line">            <span class="comment">// 重复请求判断</span></span><br><span class="line">            <span class="keyword">if</span> (reqCache.containsKey(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">"请勿重复提交！！！"</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非重复请求，存储请求 ID</span></span><br><span class="line">            reqCache.put(id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.idempote.util.IdempotentUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController4</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非空判断(忽略)...</span></span><br><span class="line">        <span class="comment">// -------------- 幂等性调用（开始） --------------</span></span><br><span class="line">        <span class="keyword">if</span> (!IdempotentUtils.judge(id, <span class="keyword">this</span>.getClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"执行失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -------------- 幂等性调用（结束） --------------</span></span><br><span class="line">        <span class="comment">// 业务代码...</span></span><br><span class="line">        System.out.println(<span class="string">"添加用户ID:"</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"执行成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：一般情况下代码写到这里就结束了，但想要更简洁也是可以实现的，你可以通过自定义注解，将业务代码写到注解中，需要调用的方法只需要写一行注解就可以防止数据重复提交了，老铁们可以自行尝试一下（需要磊哥撸一篇的，评论区留言 666）。</p></blockquote><h2 id="扩展知识——LRUMap-实现原理分析"><a href="#扩展知识——LRUMap-实现原理分析" class="headerlink" title="扩展知识——LRUMap 实现原理分析"></a>扩展知识——LRUMap 实现原理分析</h2><p>既然 <code>LRUMap</code> 如此强大，我们就来看看它是如何实现的。</p><p><code>LRUMap</code> 的本质是持有头结点的环回双链表结构，它的存储结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractLinkedMap.LinkEntry entry;</span><br></pre></td></tr></table></figure><p>当调用查询方法时，会将使用的元素放在双链表 header 的前一个位置，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key, <span class="keyword">boolean</span> updateToMRU)</span> </span>&#123;</span><br><span class="line">    LinkEntry&lt;K, V&gt; entry = <span class="keyword">this</span>.getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (updateToMRU) &#123;</span><br><span class="line">            <span class="keyword">this</span>.moveToMRU(entry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">moveToMRU</span><span class="params">(LinkEntry&lt;K, V&gt; entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.after != <span class="keyword">this</span>.header) &#123;</span><br><span class="line">        ++<span class="keyword">this</span>.modCount;</span><br><span class="line">        <span class="keyword">if</span> (entry.before == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Entry.before is null. This should not occur if your keys are immutable, and you have used synchronization properly."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entry.before.after = entry.after;</span><br><span class="line">        entry.after.before = entry.before;</span><br><span class="line">        entry.after = <span class="keyword">this</span>.header;</span><br><span class="line">        entry.before = <span class="keyword">this</span>.header.before;</span><br><span class="line">        <span class="keyword">this</span>.header.before.after = entry;</span><br><span class="line">        <span class="keyword">this</span>.header.before = entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry == <span class="keyword">this</span>.header) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can't move header to MRU This should not occur if your keys are immutable, and you have used synchronization properly."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果新增元素时，容量满了就会移除 header 的后一个元素，添加源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addMapping</span><span class="params">(<span class="keyword">int</span> hashIndex, <span class="keyword">int</span> hashCode, K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断容器是否已满 </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">        LinkEntry&lt;K, V&gt; reuse = <span class="keyword">this</span>.header.after;</span><br><span class="line">        <span class="keyword">boolean</span> removeLRUEntry = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.scanUntilRemovable) &#123;</span><br><span class="line">            removeLRUEntry = <span class="keyword">this</span>.removeLRU(reuse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(reuse != <span class="keyword">this</span>.header &amp;&amp; reuse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.removeLRU(reuse)) &#123;</span><br><span class="line">                    removeLRUEntry = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                reuse = reuse.after;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reuse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Entry.after=null, header.after="</span> + <span class="keyword">this</span>.header.after + <span class="string">" header.before="</span> + <span class="keyword">this</span>.header.before + <span class="string">" key="</span> + key + <span class="string">" value="</span> + value + <span class="string">" size="</span> + <span class="keyword">this</span>.size + <span class="string">" maxSize="</span> + <span class="keyword">this</span>.maxSize + <span class="string">" This should not occur if your keys are immutable, and you have used synchronization properly."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (removeLRUEntry) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reuse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"reuse=null, header.after="</span> + <span class="keyword">this</span>.header.after + <span class="string">" header.before="</span> + <span class="keyword">this</span>.header.before + <span class="string">" key="</span> + key + <span class="string">" value="</span> + value + <span class="string">" size="</span> + <span class="keyword">this</span>.size + <span class="string">" maxSize="</span> + <span class="keyword">this</span>.maxSize + <span class="string">" This should not occur if your keys are immutable, and you have used synchronization properly."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.reuseMapping(reuse, hashIndex, hashCode, key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.addMapping(hashIndex, hashCode, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.addMapping(hashIndex, hashCode, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断容量的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size &gt;= maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容量未满就直接添加数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.addMapping(hashIndex, hashCode, key, value);</span><br></pre></td></tr></table></figure><p>如果容量满了，就调用 <code>reuseMapping</code> 方法使用 LRU 算法对数据进行清除。</p><p>综合来说：<strong><code>LRUMap</code> 的本质是持有头结点的环回双链表结构，当使用元素时，就将该元素放在双链表 <code>header</code> 的前一个位置，在新增元素时，如果容量满了就会移除 <code>header</code>的后一个元素</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲了防止数据重复提交的 6 种方法，首先是前端的拦截，通过隐藏和设置按钮的不可用来屏蔽正常操作下的重复提交。但为了避免非正常渠道的重复提交，我们又实现了 5 个版本的后端拦截：HashMap 版、固定数组版、双重检测锁的数组版、LRUMap 版和 LRUMap 的封装版。</p><h4 id="参考-amp-鸣谢"><a href="#参考-amp-鸣谢" class="headerlink" title="参考 &amp; 鸣谢"></a>参考 &amp; 鸣谢</h4><p><a href="https://blog.csdn.net/fenglllle/article/details/82659576" target="_blank" rel="noopener">https://blog.csdn.net/fenglllle/article/details/82659576</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载:&lt;a href=&quot;https://mp.weixin.qq.com/s/kOADZRd5hI1H-7_zuXJsAw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击查看原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;模拟用户场景&quot;&gt;&lt;a href=&quot;#模拟用户场景&quot; class=&quot;headerlink&quot; title=&quot;模拟用户场景&quot;&gt;&lt;/a&gt;模拟用户场景&lt;/h2&gt;&lt;p&gt;根据朋友的反馈，大致的场景是这样的，如下图所示：&lt;/p&gt;
&lt;figure class=&quot;image-box&quot;&gt;
                &lt;img src=&quot;https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/微信图片_20200802143342.gif&quot; alt=&quot;&quot; title=&quot;&quot; class=&quot;&quot;&gt;
                &lt;p&gt;&lt;/p&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis动态SQL</title>
    <link href="http://www.sjsmile.cn/2020/08/02/java/MyBatis%E5%8A%A8%E6%80%81SQL/"/>
    <id>http://www.sjsmile.cn/2020/08/02/java/MyBatis%E5%8A%A8%E6%80%81SQL/</id>
    <published>2020-08-02T06:21:53.000Z</published>
    <updated>2020-08-02T06:50:12.972Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载：<strong><em>\</em><a href="http://mp.weixin.qq.com/s?__biz=MzI2OTQ4OTQ1NQ==&amp;mid=2247486978&amp;idx=3&amp;sn=f002b9b0e5e2d2b9a7d0a97da76c1dfb&amp;chksm=eadeca42dda94354026df14ce7e323e7f60b78ee973f1ef9cc7c4fcd13da03c1fbc0497130c9&amp;token=352160940&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">点击前往，查看更多</a>**</strong></p></blockquote><p>MyBatis 令人喜欢的一大特性就是动态 SQL。在使用 JDBC 的过程中， 根据条件进行 SQL 的拼接是很麻烦且很容易出错的。MyBatis 动态 SQL 的出现， 解决了这个麻烦。</p><p>MyBatis通过 OGNL 来进行动态 SQL 的使用的。目前， 动态 SQL 支持以下几种标签：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406161.webp" alt="" title="" class="">                <p></p>            </figure><a id="more"></a><h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1 数据准备"></a>1 数据准备</h3><p>为了后面的演示， 创建了一个 Maven 项目 mybatis-dynamic, 创建了对应的数据库和表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`student`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'编号'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'电话'</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱'</span>,</span><br><span class="line">  <span class="string">`sex`</span> tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别'</span>,</span><br><span class="line">  <span class="string">`locked`</span> tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'状态(0:正常,1:锁定)'</span>,</span><br><span class="line">  <span class="string">`gmt_created`</span> datetime <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'存入数据库的时间'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'修改的时间'</span>,</span><br><span class="line">  <span class="string">`delete`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`student_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci <span class="keyword">COMMENT</span>=<span class="string">'学生表'</span>;</span><br></pre></td></tr></table></figure><p>对应的项目结构</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406167.png" alt="" title="" class="">                <p></p>            </figure><h3 id="2-if-标签"><a href="#2-if-标签" class="headerlink" title="2 if 标签"></a>2 if 标签</h3><p>if 标签是我们最常使用的。在查询、删除、更新的时候很可能会使用到。必须结合 test 属性联合使用。</p><h4 id="2-1-在-WHERE-条件中使用-if-标签"><a href="#2-1-在-WHERE-条件中使用-if-标签" class="headerlink" title="2.1 在 WHERE 条件中使用 if 标签"></a>2.1 在 WHERE 条件中使用 if 标签</h4><p>这是常见的一种现象， 我们在进行按条件查询的时候， 可能会有多种情况。</p><h5 id="2-1-1-查询条件"><a href="#2-1-1-查询条件" class="headerlink" title="2.1.1 查询条件"></a>2.1.1 查询条件</h5><p>根据输入的学生信息进行条件检索</p><ul><li>当只输入用户名时， 使用用户名进行模糊检索；</li><li>当只输入性别时， 使用性别进行完全匹配</li><li>当用户名和性别都存在时， 用这两个条件进行查询匹配查询</li></ul><h5 id="2-1-2-动态-SQL"><a href="#2-1-2-动态-SQL" class="headerlink" title="2.1.2 动态 SQL"></a>2.1.2 动态 SQL</h5><p>接口函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据输入的学生信息进行条件检索</span></span><br><span class="line"><span class="comment"> * 1. 当只输入用户名时， 使用用户名进行模糊检索；</span></span><br><span class="line"><span class="comment"> * 2. 当只输入邮箱时， 使用性别进行完全匹配</span></span><br><span class="line"><span class="comment"> * 3. 当用户名和性别都存在时， 用这两个条件进行查询匹配的用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> student</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">selectByStudentSelective</span><span class="params">(Student student)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的动态 SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByStudentSelective"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"com.homejim.mybatis.entity.Student"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">  from student</span><br><span class="line">  where 1=1</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name !=''"</span>&gt;</span></span><br><span class="line">    and name like concat('%', #&#123;name&#125;, '%')</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">    and sex=#&#123;sex&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在此 SQL 语句中， where 1=1 是多条件拼接时的小技巧， 后面的条件查询就可以都用 and 了。</p><p>同时， 我们添加了 if 标签来处理动态 SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name !=''"</span>&gt;</span></span><br><span class="line">  and name like concat('%', #&#123;name&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">  and sex=#&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此 if 标签的 test 属性值是一个符合 OGNL 的表达式， 表达式可以是 true 或 false。如果表达式返回的是数值， 则0为 false, 非 0 为 true;</p><h5 id="2-1-3-测试"><a href="#2-1-3-测试" class="headerlink" title="2.1.3 测试"></a>2.1.3 测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectByStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line">    sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    Student search = <span class="keyword">new</span> Student();</span><br><span class="line">    search.setName(<span class="string">"明"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"只有名字时的查询"</span>);</span><br><span class="line">    List&lt;Student&gt; studentsByName = studentMapper.selectByStudentSelective(search);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; studentsByName.size(); i++) &#123;</span><br><span class="line">        System.out.println(ToStringBuilder.reflectionToString(studentsByName.get(i), ToStringStyle.MULTI_LINE_STYLE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    search.setName(<span class="keyword">null</span>);</span><br><span class="line">    search.setSex((<span class="keyword">byte</span>) <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"只有性别时的查询"</span>);</span><br><span class="line">    List&lt;Student&gt; studentsBySex = studentMapper.selectByStudentSelective(search);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; studentsBySex.size(); i++) &#123;</span><br><span class="line">        System.out.println(ToStringBuilder.reflectionToString(studentsBySex.get(i), ToStringStyle.MULTI_LINE_STYLE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"姓名和性别同时存在的查询"</span>);</span><br><span class="line">    search.setName(<span class="string">"明"</span>);</span><br><span class="line">    List&lt;Student&gt; studentsByNameAndSex = studentMapper.selectByStudentSelective(search);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; studentsByNameAndSex.size(); i++) &#123;</span><br><span class="line">        System.out.println(ToStringBuilder.reflectionToString(studentsByNameAndSex.get(i), ToStringStyle.MULTI_LINE_STYLE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有名字时的查询， 发送的语句和结果</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406163.webp" alt="" title="" class="">                <p></p>            </figure><p>查询的条件只发送了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where 1=1 and name like concat('%', ?, '%')</span><br></pre></td></tr></table></figure><p>只有性别时的查询， 发送的语句和结果</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406168.png" alt="" title="" class="">                <p></p>            </figure><p>查询的条件只发送了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where 1=1 and sex=?</span><br></pre></td></tr></table></figure><p>姓名和性别同时存在的查询， 发送的语句和结果</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406174.webp" alt="" title="" class="">                <p></p>            </figure><p>查询条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where 1=1 and name like concat('%', ?, '%') and sex=?</span><br></pre></td></tr></table></figure><h4 id="2-2-在-UPDATE-更新列中使用-if-标签"><a href="#2-2-在-UPDATE-更新列中使用-if-标签" class="headerlink" title="2.2 在 UPDATE 更新列中使用 if 标签"></a>2.2 在 UPDATE 更新列中使用 if 标签</h4><p>有时候我们不希望更新所有的字段， 只更新有变化的字段。</p><h5 id="2-2-1-更新条件"><a href="#2-2-1-更新条件" class="headerlink" title="2.2.1 更新条件"></a>2.2.1 更新条件</h5><p>只更新有变化的字段， 空值不更新。</p><h5 id="2-2-1-动态-SQL"><a href="#2-2-1-动态-SQL" class="headerlink" title="2.2.1 动态 SQL"></a>2.2.1 动态 SQL</h5><p>接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新非空属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(Student record)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的 SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateByPrimaryKeySelective"</span> <span class="attr">parameterType</span>=<span class="string">"com.homejim.mybatis.entity.Student"</span>&gt;</span></span><br><span class="line">  update student</span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null"</span>&gt;</span></span><br><span class="line">      `name` = #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null"</span>&gt;</span></span><br><span class="line">      phone = #&#123;phone,jdbcType=VARCHAR&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null"</span>&gt;</span></span><br><span class="line">      email = #&#123;email,jdbcType=VARCHAR&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">      sex = #&#123;sex,jdbcType=TINYINT&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"locked != null"</span>&gt;</span></span><br><span class="line">      locked = #&#123;locked,jdbcType=TINYINT&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtCreated != null"</span>&gt;</span></span><br><span class="line">      gmt_created = #&#123;gmtCreated,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtModified != null"</span>&gt;</span></span><br><span class="line">      gmt_modified = #&#123;gmtModified,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where student_id = #&#123;studentId,jdbcType=INTEGER&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-测试"><a href="#2-2-3-测试" class="headerlink" title="2.2.3 测试"></a>2.2.3 测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateByStudentSelective</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line">    sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setStudentId(<span class="number">1</span>);</span><br><span class="line">    student.setName(<span class="string">"明明"</span>);</span><br><span class="line">    student.setPhone(<span class="string">"13838438888"</span>);</span><br><span class="line">    System.out.println(studentMapper.updateByPrimaryKeySelective(student));</span><br><span class="line"></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406177.png" alt="" title="" class="">                <p></p>            </figure><h4 id="2-3-在-INSERT-动态插入中使用-if-标签"><a href="#2-3-在-INSERT-动态插入中使用-if-标签" class="headerlink" title="2.3 在 INSERT 动态插入中使用 if 标签"></a>2.3 在 INSERT 动态插入中使用 if 标签</h4><p>我们插入数据库中的一条记录， 不是每一个字段都有值的， 而是动态变化的。在这时候使用 if 标签， 可帮我们解决这个问题。</p><h5 id="2-3-1-插入条件"><a href="#2-3-1-插入条件" class="headerlink" title="2.3.1 插入条件"></a>2.3.1 插入条件</h5><p>只有非空属性才插入。</p><h5 id="2-3-2-动态SQL"><a href="#2-3-2-动态SQL" class="headerlink" title="2.3.2 动态SQL"></a>2.3.2 动态SQL</h5><p>接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非空字段才进行插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(Student record)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertSelective"</span> <span class="attr">parameterType</span>=<span class="string">"com.homejim.mybatis.entity.Student"</span>&gt;</span></span><br><span class="line">    insert into student</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"studentId != null"</span>&gt;</span></span><br><span class="line">        student_id,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null"</span>&gt;</span></span><br><span class="line">        `name`,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null"</span>&gt;</span></span><br><span class="line">        phone,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null"</span>&gt;</span></span><br><span class="line">        email,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">        sex,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"locked != null"</span>&gt;</span></span><br><span class="line">        locked,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtCreated != null"</span>&gt;</span></span><br><span class="line">        gmt_created,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtModified != null"</span>&gt;</span></span><br><span class="line">        gmt_modified,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"values ("</span> <span class="attr">suffix</span>=<span class="string">")"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"studentId != null"</span>&gt;</span></span><br><span class="line">        #&#123;studentId,jdbcType=INTEGER&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null"</span>&gt;</span></span><br><span class="line">        #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"phone != null"</span>&gt;</span></span><br><span class="line">        #&#123;phone,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null"</span>&gt;</span></span><br><span class="line">        #&#123;email,jdbcType=VARCHAR&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"sex != null"</span>&gt;</span></span><br><span class="line">        #&#123;sex,jdbcType=TINYINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"locked != null"</span>&gt;</span></span><br><span class="line">        #&#123;locked,jdbcType=TINYINT&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtCreated != null"</span>&gt;</span></span><br><span class="line">        #&#123;gmtCreated,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gmtModified != null"</span>&gt;</span></span><br><span class="line">        #&#123;gmtModified,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 SQL 大家应该很熟悉， 毕竟是自动生成的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载：&lt;strong&gt;&lt;em&gt;\&lt;/em&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2OTQ4OTQ1NQ==&amp;amp;mid=2247486978&amp;amp;idx=3&amp;amp;sn=f002b9b0e5e2d2b9a7d0a97da76c1dfb&amp;amp;chksm=eadeca42dda94354026df14ce7e323e7f60b78ee973f1ef9cc7c4fcd13da03c1fbc0497130c9&amp;amp;token=352160940&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击前往，查看更多&lt;/a&gt;**&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MyBatis 令人喜欢的一大特性就是动态 SQL。在使用 JDBC 的过程中， 根据条件进行 SQL 的拼接是很麻烦且很容易出错的。MyBatis 动态 SQL 的出现， 解决了这个麻烦。&lt;/p&gt;
&lt;p&gt;MyBatis通过 OGNL 来进行动态 SQL 的使用的。目前， 动态 SQL 支持以下几种标签：&lt;/p&gt;
&lt;figure class=&quot;image-box&quot;&gt;
                &lt;img src=&quot;https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1596349406161.webp&quot; alt=&quot;&quot; title=&quot;&quot; class=&quot;&quot;&gt;
                &lt;p&gt;&lt;/p&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/tags/java/"/>
    
      <category term="mybatis" scheme="http://www.sjsmile.cn/tags/mybatis/"/>
    
      <category term="sql" scheme="http://www.sjsmile.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>跟上 Java 8 : 日期和时间实用技巧</title>
    <link href="http://www.sjsmile.cn/2020/07/07/java/%E8%B7%9F%E4%B8%8A-Java-8-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.sjsmile.cn/2020/07/07/java/%E8%B7%9F%E4%B8%8A-Java-8-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2020-07-07T09:08:02.000Z</published>
    <updated>2020-07-07T09:18:46.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>来源：王爵nice，</p><p>biezhi.me/2017/07/20/keep-up-with-java8-datetime.html</p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;mid=2651477193&amp;idx=3&amp;sn=db1c998f961b9d780c7d138f1dfc0ba4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">如有好文章投稿，请点击 → 这里了解详情</a></p></blockquote><p>当你开始使用Java操作日期和时间的时候，会有一些棘手。你也许会通过System.currentTimeMillis() 来返回1970年1月1日到今天的毫秒数。或者使用Date类来操作日期；当遇到加减月份、天数的时候 你又需要用到Calendar类；当需要格式化日期的时候需要使用java.text.DateFormat类。 总而言之在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库，比如: joda-time。</p><p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1594112956906.webp" alt="java8-clock"></p><a id="more"></a><h1 id="现有API存在的问题"><a href="#现有API存在的问题" class="headerlink" title="现有API存在的问题"></a><strong>现有API存在的问题</strong></h1><ul><li>线程安全: Date和Calendar不是线程安全的，你需要编写额外的代码处理线程安全问题</li><li>API设计和易用性: 由于Date和Calendar的设计不当你无法完成日常的日期操作</li><li>ZonedDate和Time: 你必须编写额外的逻辑处理时区和那些旧的逻辑</li></ul><p>好在JSR 310规范中为Java8添加了新的API， 在java.time包中，新的API纠正了过去的缺陷，</p><h1 id="新的日期API"><a href="#新的日期API" class="headerlink" title="新的日期API"></a><strong>新的日期API</strong></h1><ul><li>ZoneId: 时区ID，用来确定Instant和LocalDateTime互相转换的规则</li><li>Instant: 用来表示时间线上的一个点</li><li>LocalDate: 表示没有时区的日期, LocalDate是不可变并且线程安全的</li><li>LocalTime: 表示没有时区的时间, LocalTime是不可变并且线程安全的</li><li>LocalDateTime: 表示没有时区的日期时间, LocalDateTime是不可变并且线程安全的</li><li>Clock: 用于访问当前时刻、日期、时间，用到时区</li><li>Duration: 用秒和纳秒表示时间的数量</li></ul><p>最常用的就是LocalDate、LocalTime、LocalDateTime了，从它们的名字就可以看出是操作日期 和时间的。这些类是主要用于当时区不需要显式地指定的上下文。在本章节中我们将讨论最常用的api。</p><h2 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a><strong>LocalDate</strong></h2><p>LocalDate代表一个IOS格式(yyyy-MM-dd)的日期，可以存储 生日、纪念日等日期。 获取当前的日期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"localDate: "</span> + localDate);</span><br></pre></td></tr></table></figure><blockquote><p>localDate: 2017-07-20</p></blockquote><p>LocalDate可以指定特定的日期，调用of或parse方法返回该实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate.of(<span class="number">2017</span>, <span class="number">07</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">LocalDate.parse(<span class="string">"2017-07-20"</span>);</span><br></pre></td></tr></table></figure><p>当然它还有一些其他方法，我们一起来看看：</p><p>为今天添加一天，也就是获取明天</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate tomorrow = LocalDate.now().plusDays(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>从今天减去一个月</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate prevMonth = LocalDate.now().minus(<span class="number">1</span>, ChronoUnit.MONTHS);</span><br></pre></td></tr></table></figure><p>下面写两个例子，分别解析日期 2017-07-20，获取每周中的星期和每月中的日：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DayOfWeek thursday = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfWeek();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"周四: "</span> + thursday);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> twenty = LocalDate.parse(<span class="string">"2017-07-20"</span>).getDayOfMonth();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"twenty: "</span> + twenty);</span><br></pre></td></tr></table></figure><p>试试今年是不是闰年:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> leapYear = LocalDate.now().isLeapYear();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"是否闰年: "</span> + leapYear);</span><br></pre></td></tr></table></figure><p>判断是否在日期之前或之后:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> notBefore = LocalDate.parse(<span class="string">"2017-07-20"</span>).isBefore(LocalDate.parse(<span class="string">"2017-07-22"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"notBefore: "</span> + notBefore);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isAfter = LocalDate.parse(<span class="string">"2017-07-20"</span>).isAfter(LocalDate.parse(<span class="string">"2017-07-22"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"isAfter: "</span> + isAfter);</span><br></pre></td></tr></table></figure><p>获取这个月的第一天:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDate firstDayOfMonth = LocalDate.parse(<span class="string">"2017-07-20"</span>).with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"这个月的第一天: "</span> + firstDayOfMonth);</span><br><span class="line"></span><br><span class="line">firstDayOfMonth = firstDayOfMonth.withDayOfMonth(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"这个月的第一天: "</span> + firstDayOfMonth);</span><br></pre></td></tr></table></figure><p>判断今天是否是我的生日，例如我的生日是 2009-07-20</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDate birthday = LocalDate.of(<span class="number">2009</span>, <span class="number">07</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</span><br><span class="line"></span><br><span class="line">MonthDay today = MonthDay.from(LocalDate.now());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"今天是否是我的生日: "</span> + today.equals(birthdayMd));</span><br></pre></td></tr></table></figure><h2 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a><strong>LocalTime</strong></h2><p>LocalTime表示一个时间，而不是日期，下面介绍一下它的使用方法。</p><p>获取现在的时间，输出15:01:22.144</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now = LocalTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"现在的时间: "</span> + now);</span><br></pre></td></tr></table></figure><p>将一个字符串时间解析为LocalTime，输出15:02</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalTime nowTime = LocalTime.parse(<span class="string">"15:02"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"时间是: "</span> + nowTime);</span><br></pre></td></tr></table></figure><p>使用静态方法of创建一个时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalTime nowTime = LocalTime.of(<span class="number">15</span>, <span class="number">02</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"时间是: "</span> + nowTime);</span><br></pre></td></tr></table></figure><p>使用解析字符串的方式并添加一小时，输出16:02</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalTime nextHour = LocalTime.parse(<span class="string">"15:02"</span>).plus(<span class="number">1</span>, ChronoUnit.HOURS);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"下一个小时: "</span> + nextHour);</span><br></pre></td></tr></table></figure><p>获取时间的小时、分钟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hour = LocalTime.parse(<span class="string">"15:02"</span>).getHour();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"小时: "</span> + hour);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minute = LocalTime.parse(<span class="string">"15:02"</span>).getMinute();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"分钟: "</span> + minute);</span><br></pre></td></tr></table></figure><p>我们也可以通过之前类似的API检查一个时间是否在另一个时间之前、之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isBefore = LocalTime.parse(<span class="string">"15:02"</span>).isBefore(LocalTime.parse(<span class="string">"16:02"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isAfter = LocalTime.parse(<span class="string">"15:02"</span>).isAfter(LocalTime.parse(<span class="string">"16:02"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"isBefore: "</span> + isBefore);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"isAfter: "</span> + isAfter);</span><br></pre></td></tr></table></figure><p>输出 isBefore: true, isAfter: false。</p><p>在LocalTime类中也将每天的开始和结束作为常量供我们使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(LocalTime.MAX);</span><br><span class="line"></span><br><span class="line">System.out.println(LocalTime.MIN);</span><br></pre></td></tr></table></figure><p>输出:</p><blockquote><p>23:59:59.999999999</p><p>00:00</p></blockquote><p>LocalTime就这些了，下面我们来了解一下LocalDateTime</p><h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a><strong>LocalDateTime</strong></h2><p>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</p><p>获取当前的日期和时间:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"现在: "</span> + now);</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>现在: 2017-07-20T15:17:19.926</p></blockquote><p>下面使用静态方法和字符串的方式分别创建LocalDateTime对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.of(<span class="number">2017</span>, Month.JULY, <span class="number">20</span>, <span class="number">15</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime.parse(<span class="string">"2017-07-20T15:18:00"</span>);</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">同时`LocalDateTime`也提供了相关API来对日期和时间进行增减操作:</span><br><span class="line"></span><br><span class="line">\```java</span><br><span class="line"></span><br><span class="line">LocalDateTime tomorrow = now.plusDays(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"明天的这个时间: "</span> + tomorrow);</span><br><span class="line"></span><br><span class="line">LocalDateTime minusTowHour = now.minusHours(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"两小时前: "</span> + minusTowHour);</span><br></pre></td></tr></table></figure><p>这个类也提供一系列的get方法来获取特定单位:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Month month = now.getMonth();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"当前月份: "</span> + month);</span><br></pre></td></tr></table></figure><h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a><strong>日期格式化</strong></h2><p>在日常开发中我们用到最多的也许就是日期、时间的格式化了，那在Java8种该如何操作呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"默认格式化: "</span> + now);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"自定义格式化: "</span> + now.format(dateTimeFormatter));</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.parse(<span class="string">"2017-07-20 15:27:44"</span>, dateTimeFormatter);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"字符串转LocalDateTime: "</span> + localDateTime);</span><br></pre></td></tr></table></figure><p>也可以使用DateTimeFormatter的format方法将日期、时间格式化为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">String dateString = dateTimeFormatter.format(LocalDate.now());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"日期转字符串: "</span> + dateString);</span><br></pre></td></tr></table></figure><h2 id="日期周期"><a href="#日期周期" class="headerlink" title="日期周期"></a><strong>日期周期</strong></h2><p>Period类用于修改给定日期或获得的两个日期之间的区别。</p><p>给初始化的日期添加5天:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDate initialDate = LocalDate.parse(<span class="string">"2017-07-20"</span>);</span><br><span class="line"></span><br><span class="line">LocalDate finalDate = initialDate.plus(Period.ofDays(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"初始化日期: "</span> + initialDate);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"加日期之后: "</span> + finalDate);</span><br></pre></td></tr></table></figure><p>周期API中提供给我们可以比较两个日期的差别，像下面这样获取差距天数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> between = ChronoUnit.DAYS.between(initialDate, finalDate);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"差距天数: "</span> + between);</span><br></pre></td></tr></table></figure><p>上面的代码会返回5，当然你想获取两个日期相差多少小时也是简单的。</p><h2 id="与遗留代码转换"><a href="#与遗留代码转换" class="headerlink" title="与遗留代码转换"></a><strong>与遗留代码转换</strong></h2><p>在之前的代码中你可能出现了大量的Date类，如何将它转换为Java8种的时间类呢？</p><p>Date和Instant互相转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date date = Date.from(Instant.now());</span><br><span class="line"></span><br><span class="line">Instant instant = date.toInstant();</span><br></pre></td></tr></table></figure><p>Date转换为LocalDateTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.from(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">System.out.println(localDateTime);</span><br></pre></td></tr></table></figure><p>LocalDateTime转Date</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</span><br></pre></td></tr></table></figure><p>LocalDate转Date</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;来源：王爵nice，&lt;/p&gt;
&lt;p&gt;biezhi.me/2017/07/20/keep-up-with-java8-datetime.html&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651477193&amp;amp;idx=3&amp;amp;sn=db1c998f961b9d780c7d138f1dfc0ba4&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如有好文章投稿，请点击 → 这里了解详情&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你开始使用Java操作日期和时间的时候，会有一些棘手。你也许会通过System.currentTimeMillis() 来返回1970年1月1日到今天的毫秒数。或者使用Date类来操作日期；当遇到加减月份、天数的时候 你又需要用到Calendar类；当需要格式化日期的时候需要使用java.text.DateFormat类。 总而言之在Java中操作日期不是很方便，以至于很多开发者不得不使用第三方库，比如: joda-time。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1594112956906.webp&quot; alt=&quot;java8-clock&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java8" scheme="http://www.sjsmile.cn/tags/java8/"/>
    
      <category term="时间API" scheme="http://www.sjsmile.cn/tags/%E6%97%B6%E9%97%B4API/"/>
    
  </entry>
  
  <entry>
    <title>API接口的安全设计</title>
    <link href="http://www.sjsmile.cn/2020/06/24/java/API%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://www.sjsmile.cn/2020/06/24/java/API%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-06-24T01:02:33.000Z</published>
    <updated>2020-06-24T01:22:11.998Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载，<a href="https://mp.weixin.qq.com/s/G94Z3BC5pZxPdbFxEnCyrw" target="_blank" rel="noopener">原文地址</a></p></blockquote><p><strong>说明：在实际的业务中，难免会跟第三方系统进行数据的交互与传递，那么如何保证数据在传输过程中的安全呢（防窃取）？除了https的协议之外，能不能加上通用的一套算法以及规范来保证传输的安全性呢？</strong></p><p><strong>下面我们就来讨论下常用的一些API设计的安全方法，可能不一定是最好的，有更牛逼的实现方式，但是这篇是我自己的经验分享.</strong></p><h1 id="一：token-简介"><a href="#一：token-简介" class="headerlink" title="一：token 简介"></a>一：token 简介</h1><p>Token：访问令牌access token, 用于接口中, 用于标识接口调用者的身份、凭证，减少用户名和密码的传输次数。一般情况下客户端(接口调用方)需要先向服务器端申请一个接口调用的账号，服务器会给出一个appId和一个key, key用于参数签名使用，注意key保存到客户端，需要做一些安全处理，防止泄露。</p><p>Token的值一般是UUID，服务端生成Token后需要将token做为key，将一些和token关联的信息作为value保存到缓存服务器中(redis)，当一个请求过来后，服务器就去缓存服务器中查询这个Token是否存在，存在则调用接口，不存在返回接口错误，一般通过拦截器或者过滤器来实现，Token分为两种：</p><a id="more"></a><ul><li>API Token(接口令牌): 用于访问不需要用户登录的接口，如登录、注册、一些基本数据的获取等。获取接口令牌需要拿appId、timestamp和sign来换，sign=加密(timestamp+key)</li><li>USER Token(用户令牌): 用于访问需要用户登录之后的接口，如：获取我的基本信息、保存、修改、删除等操作。获取用户令牌需要拿用户名和密码来换</li></ul><p>关于Token的时效性：token可以是一次性的、也可以在一段时间范围内是有效的，具体使用哪种看业务需要。</p><p>一般情况下接口最好使用https协议，如果使用http协议，Token机制只是一种减少被黑的可能性，其实只能防君子不能防小人。</p><p>一般token、timestamp和sign 三个参数会在接口中会同时作为参数传递，每个参数都有各自的用途。</p><h1 id="二：timestamp-简介"><a href="#二：timestamp-简介" class="headerlink" title="二：timestamp 简介"></a>二：timestamp 简介</h1><p>timestamp: 时间戳，是客户端调用接口时对应的当前时间戳，时间戳用于防止DoS攻击。当黑客劫持了请求的url去DoS攻击，每次调用接口时接口都会判断服务器当前系统时间和接口中传的的timestamp的差值，如果这个差值超过某个设置的时间(假如5分钟)，那么这个请求将被拦截掉，如果在设置的超时时间范围内，是不能阻止DoS攻击的。timestamp机制只能减轻DoS攻击的时间，缩短攻击时间。如果黑客修改了时间戳的值可通过sign签名机制来处理。</p><h3 id="DoS"><a href="#DoS" class="headerlink" title="DoS"></a>DoS</h3><p>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。</p><p>DoS攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃，而在此攻击中并不包括侵入目标服务器或目标网络设备。这些服务资源包括网络带宽，文件系统空间容量，开放的进程或者允许的连接。这种攻击会导致资源的匮乏，无论计算机的处理速度多快、内存容量多大、网络带宽的速度多快都无法避免这种攻击带来的后果。</p><ul><li>Pingflood: 该攻击在短时间内向目的主机发送大量ping包，造成网络堵塞或主机资源耗尽。</li><li>Synflood: 该攻击以多个随机的源主机地址向目的主机发送SYN包，而在收到目的主机的SYN ACK后并不回应，这样，目的主机就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这</li></ul><p>些队列，造成了资源的大量消耗而不能向正常请求提供服务。</p><ul><li>Smurf：该攻击向一个子网的广播地址发一个带有特定请求（如ICMP回应请求）的包，并且将源地址伪装成想要攻击的主机地址。子网上所有主机都回应广播包请求而向被攻击主机发包，使该主机受到攻击。</li><li>Land-based：攻击者将一个包的源地址和目的地址都设置为目标主机的地址，然后将该包通过IP欺骗的方式发送给被攻击主机，这种包可以造成被攻击主机因试图与自己建立连接而陷入死循环，从而很大程度地降低了系统性能。</li><li>Ping of Death：根据TCP/IP的规范，一个包的长度最大为65536字节。尽管一个包的长度不能超过65536字节，但是一个包分成的多个片段的叠加却能做到。当一个主机收到了长度大于65536字节的包时，就是受到了Ping of Death攻击，该攻击会造成主机的宕机。</li><li>Teardrop：IP数据包在网络传递时，数据包可以分成更小的片段。攻击者可以通过发送两段（或者更多）数据包来实现TearDrop攻击。第一个包的偏移量为0，长度为N，第二个包的偏移量小于N。为了合并这些数据段，TCP/IP堆栈会分配超乎寻常的巨大资源，从而造成系统资源的缺乏甚至机器的重新启动。</li><li>PingSweep：使用ICMP Echo轮询多个主机。</li></ul><h1 id="三：sign-简介"><a href="#三：sign-简介" class="headerlink" title="三：sign 简介"></a>三：sign 简介</h1><p>nonce：随机值，是客户端随机生成的值，作为参数传递过来，随机值的目的是增加sign签名的多变性。随机值一般是数字和字母的组合，6位长度，随机值的组成和长度没有固定规则。</p><p>sign: 一般用于参数签名，防止参数被非法篡改，最常见的是修改金额等重要敏感参数， sign的值一般是将所有非空参数按照升续排序然后+token+key+timestamp+nonce(随机数)拼接在一起，然后使用某种加密算法进行加密，作为接口中的一个参数sign来传递，也可以将sign放到请求头中。接口在网络传输过程中如果被黑客挟持，并修改其中的参数值，然后再继续调用接口，虽然参数的值被修改了，但是因为黑客不知道sign是如何计算出来的，不知道sign都有哪些值构成，不知道以怎样的顺序拼接在一起的，最重要的是不知道签名字符串中的key是什么，所以黑客可以篡改参数的值，但没法修改sign的值，当服务器调用接口前会按照sign的规则重新计算出sign的值然后和接口传递的sign参数的值做比较，如果相等表示参数值没有被篡改，如果不等，表示参数被非法篡改了，就不执行接口了。</p><h1 id="四：防止重复提交"><a href="#四：防止重复提交" class="headerlink" title="四：防止重复提交"></a>四：防止重复提交</h1><p>对于一些重要的操作需要防止客户端重复提交的(如非幂等性重要操作)，具体办法是当请求第一次提交时将sign作为key保存到redis，并设置超时时间，超时时间和Timestamp中设置的差值相同。当同一个请求第二次访问时会先检测redis是否存在该sign，如果存在则证明重复提交了，接口就不再继续调用了。如果sign在缓存服务器中因过期时间到了，而被删除了，此时当这个url再次请求服务器时，因token的过期时间和sign的过期时间一直，sign过期也意味着token过期，那样同样的url再访问服务器会因token错误会被拦截掉，这就是为什么sign和token的过期时间要保持一致的原因。拒绝重复调用机制确保URL被别人截获了也无法使用（如抓取数据）。</p><p>对于哪些接口需要防止重复提交可以自定义个注解来标记。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p><strong>所有的安全措施都用上的话有时候难免太过复杂，在实际项目中需要根据自身情况作出裁剪，比如可以只使用签名机制就可以保证信息不会被篡改，或者定向提供服务的时候只用Token机制就可以了。如何裁剪，全看项目实际情况和对接口安全性的要求。</strong></p><h1 id="五：使用流程"><a href="#五：使用流程" class="headerlink" title="五：使用流程"></a>五：使用流程</h1><ol><li>接口调用方(客户端)向接口提供方(服务器)申请接口调用账号，申请成功后，接口提供方会给接口调用方一个appId和一个key参数</li><li>客户端携带参数appId、timestamp、sign去调用服务器端的API token，其中sign=加密(appId + timestamp + key)</li><li>客户端拿着api_token 去访问不需要登录就能访问的接口</li><li>当访问用户需要登录的接口时，客户端跳转到登录页面，通过用户名和密码调用登录接口，登录接口会返回一个usertoken, 客户端拿着usertoken 去访问需要登录才能访问的接口</li></ol><p>sign的作用是防止参数被篡改，客户端调用服务端时需要传递sign参数，服务器响应客户端时也可以返回一个sign用于客户度校验返回的值是否被非法篡改了。客户端传的sign和服务器端响应的sign算法可能会不同。</p><h1 id="六：示例代码"><a href="#六：示例代码" class="headerlink" title="六：示例代码"></a>六：示例代码</h1><h3 id="1-dependency"><a href="#1-dependency" class="headerlink" title="1. dependency"></a>1. dependency</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-RedisConfiguration"><a href="#2-RedisConfiguration" class="headerlink" title="2. RedisConfiguration"></a>2. RedisConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">jedisConnectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持存储对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">redisTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        redisTemplate.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-TokenController"><a href="#3-TokenController" class="headerlink" title="3. TokenController"></a>3. TokenController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/token"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * API Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sign</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/api_token"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiResponse&lt;AccessToken&gt; <span class="title">apiToken</span><span class="params">(String appId, @RequestHeader(<span class="string">"timestamp"</span>)</span> String timestamp, @<span class="title">RequestHeader</span><span class="params">(<span class="string">"sign"</span>)</span> String sign) </span>&#123;</span><br><span class="line">        Assert.isTrue(!StringUtils.isEmpty(appId) &amp;&amp; !StringUtils.isEmpty(timestamp) &amp;&amp; !StringUtils.isEmpty(sign), <span class="string">"参数错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> reqeustInterval = System.currentTimeMillis() - Long.valueOf(timestamp);</span><br><span class="line">        Assert.isTrue(reqeustInterval &lt; <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>, <span class="string">"请求过期，请重新请求"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据appId查询数据库获取appSecret</span></span><br><span class="line">        AppInfo appInfo = <span class="keyword">new</span> AppInfo(<span class="string">"1"</span>, <span class="string">"12345678954556"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 校验签名</span></span><br><span class="line">        String signString = timestamp + appId + appInfo.getKey();</span><br><span class="line">        String signature = MD5Util.encode(signString);</span><br><span class="line">        log.info(signature);</span><br><span class="line">        Assert.isTrue(signature.equals(sign), <span class="string">"签名错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果正确生成一个token保存到redis中，如果错误返回错误信息</span></span><br><span class="line">        AccessToken accessToken = <span class="keyword">this</span>.saveToken(<span class="number">0</span>, appInfo, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(accessToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotRepeatSubmit</span>(<span class="number">5000</span>)</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"user_token"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiResponse&lt;UserInfo&gt; <span class="title">userToken</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据用户名查询密码, 并比较密码(密码可以RSA加密一下)</span></span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(username, <span class="string">"81255cb0dca1a5f304328a70ac85dcbd"</span>, <span class="string">"111111"</span>);</span><br><span class="line">        String pwd = password + userInfo.getSalt();</span><br><span class="line">        String passwordMD5 = MD5Util.encode(pwd);</span><br><span class="line">        Assert.isTrue(passwordMD5.equals(userInfo.getPassword()), <span class="string">"密码错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 保存Token</span></span><br><span class="line">        AppInfo appInfo = <span class="keyword">new</span> AppInfo(<span class="string">"1"</span>, <span class="string">"12345678954556"</span>);</span><br><span class="line">        AccessToken accessToken = <span class="keyword">this</span>.saveToken(<span class="number">1</span>, appInfo, userInfo);</span><br><span class="line">        userInfo.setAccessToken(accessToken);</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.success(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AccessToken <span class="title">saveToken</span><span class="params">(<span class="keyword">int</span> tokenType, AppInfo appInfo,  UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        String token = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// token有效期为2小时</span></span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.setTime(<span class="keyword">new</span> Date());</span><br><span class="line">        calendar.add(Calendar.SECOND, <span class="number">7200</span>);</span><br><span class="line">        Date expireTime = calendar.getTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 保存token</span></span><br><span class="line">        ValueOperations&lt;String, TokenInfo&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">        TokenInfo tokenInfo = <span class="keyword">new</span> TokenInfo();</span><br><span class="line">        tokenInfo.setTokenType(tokenType);</span><br><span class="line">        tokenInfo.setAppInfo(appInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tokenType == <span class="number">1</span>) &#123;</span><br><span class="line">            tokenInfo.setUserInfo(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        operations.set(token, tokenInfo, <span class="number">7200</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        AccessToken accessToken = <span class="keyword">new</span> AccessToken(token, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        System.out.println(timestamp);</span><br><span class="line">        String signString = timestamp + <span class="string">"1"</span> + <span class="string">"12345678954556"</span>;</span><br><span class="line">        String sign = MD5Util.encode(signString);</span><br><span class="line">        System.out.println(sign);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">        signString = <span class="string">"password=123456&amp;username=1&amp;12345678954556"</span> + <span class="string">"ff03e64b-427b-45a7-b78b-47d9e8597d3b1529815393153sdfsdfsfs"</span> + timestamp + <span class="string">"A1scr6"</span>;</span><br><span class="line">        sign = MD5Util.encode(signString);</span><br><span class="line">        System.out.println(sign);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-WebMvcConfiguration"><a href="#4-WebMvcConfiguration" class="headerlink" title="4. WebMvcConfiguration"></a>4. WebMvcConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] excludePathPatterns  = &#123;<span class="string">"/api/token/api_token"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenInterceptor tokenInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">        registry.addInterceptor(tokenInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">"/api/**"</span>)</span><br><span class="line">                .excludePathPatterns(excludePathPatterns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span>. TokenInterceptor</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 访问的目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        String timestamp = request.getHeader(<span class="string">"timestamp"</span>);</span><br><span class="line">        <span class="comment">// 随机字符串</span></span><br><span class="line">        String nonce = request.getHeader(<span class="string">"nonce"</span>);</span><br><span class="line">        String sign = request.getHeader(<span class="string">"sign"</span>);</span><br><span class="line">        Assert.isTrue(!StringUtils.isEmpty(token) &amp;&amp; !StringUtils.isEmpty(timestamp) &amp;&amp; !StringUtils.isEmpty(sign), <span class="string">"参数错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取超时时间</span></span><br><span class="line">        NotRepeatSubmit notRepeatSubmit = ApiUtil.getNotRepeatSubmit(handler);</span><br><span class="line">        <span class="keyword">long</span> expireTime = notRepeatSubmit == <span class="keyword">null</span> ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span> : notRepeatSubmit.value();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 请求时间间隔</span></span><br><span class="line">        <span class="keyword">long</span> reqeustInterval = System.currentTimeMillis() - Long.valueOf(timestamp);</span><br><span class="line">        Assert.isTrue(reqeustInterval &lt; expireTime, <span class="string">"请求超时，请重新请求"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 校验Token是否存在</span></span><br><span class="line">        ValueOperations&lt;String, TokenInfo&gt; tokenRedis = redisTemplate.opsForValue();</span><br><span class="line">        TokenInfo tokenInfo = tokenRedis.get(token);</span><br><span class="line">        Assert.notNull(tokenInfo, <span class="string">"token错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 校验签名(将所有的参数加进来，防止别人篡改参数) 所有参数看参数名升续排序拼接成url</span></span><br><span class="line">        <span class="comment">// 请求参数 + token + timestamp + nonce</span></span><br><span class="line">        String signString = ApiUtil.concatSignString(request) + tokenInfo.getAppInfo().getKey() + token + timestamp + nonce;</span><br><span class="line">        String signature = MD5Util.encode(signString);</span><br><span class="line">        <span class="keyword">boolean</span> flag = signature.equals(sign);</span><br><span class="line">        Assert.isTrue(flag, <span class="string">"签名错误"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 拒绝重复调用(第一次访问时存储，过期时间和请求超时时间保持一致), 只有标注不允许重复提交注解的才会校验</span></span><br><span class="line">        <span class="keyword">if</span> (notRepeatSubmit != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ValueOperations&lt;String, Integer&gt; signRedis = redisTemplate.opsForValue();</span><br><span class="line">            <span class="keyword">boolean</span> exists = redisTemplate.hasKey(sign);</span><br><span class="line">            Assert.isTrue(!exists, <span class="string">"请勿重复提交"</span>);</span><br><span class="line">            signRedis.set(sign, <span class="number">0</span>, expireTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-MD5Util-—-MD5工具类，加密生成数字签名"><a href="#6-MD5Util-—-MD5工具类，加密生成数字签名" class="headerlink" title="6. MD5Util —-MD5工具类，加密生成数字签名"></a>6. MD5Util —-MD5工具类，加密生成数字签名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Util</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String hexDigits[] = &#123; <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>,</span><br><span class="line">            <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteArrayToHexString</span><span class="params">(<span class="keyword">byte</span> b[])</span> </span>&#123;</span><br><span class="line">        StringBuffer resultSb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++)</span><br><span class="line">            resultSb.append(byteToHexString(b[i]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultSb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToHexString</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = b;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            n += <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">int</span> d1 = n / <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">int</span> d2 = n % <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> hexDigits[d1] + hexDigits[d2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encode(origin, <span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String origin, String charsetname)</span> </span>&#123;</span><br><span class="line">        String resultString = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resultString = <span class="keyword">new</span> String(origin);</span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            <span class="keyword">if</span> (charsetname == <span class="keyword">null</span> || <span class="string">""</span>.equals(charsetname))</span><br><span class="line">                resultString = byteArrayToHexString(md.digest(resultString</span><br><span class="line">                        .getBytes()));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                resultString = byteArrayToHexString(md.digest(resultString</span><br><span class="line">                        .getBytes(charsetname)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-NotRepeatSubmit-—–自定义注解，防止重复提交。"><a href="#7-NotRepeatSubmit-—–自定义注解，防止重复提交。" class="headerlink" title="7. @NotRepeatSubmit  —–自定义注解，防止重复提交。"></a>7. @NotRepeatSubmit  —–自定义注解，防止重复提交。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁止重复提交</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotRepeatSubmit &#123;</span><br><span class="line">    <span class="comment">/** 过期时间，单位毫秒 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 5000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-AccessToken"><a href="#8-AccessToken" class="headerlink" title="8. AccessToken"></a>8. AccessToken</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessToken</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** token */</span></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 失效时间 */</span></span><br><span class="line">    <span class="keyword">private</span> Date expireTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-AppInfo"><a href="#9-AppInfo" class="headerlink" title="9. AppInfo"></a>9. AppInfo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** App id */</span></span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="comment">/** API 秘钥 */</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-TokenInfo"><a href="#10-TokenInfo" class="headerlink" title="10. TokenInfo"></a>10. TokenInfo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** token类型: api:0 、user:1 */</span></span><br><span class="line">    <span class="keyword">private</span> Integer tokenType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** App 信息 */</span></span><br><span class="line">    <span class="keyword">private</span> AppInfo appInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用户其他数据 */</span></span><br><span class="line">    <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-UserInfo"><a href="#11-UserInfo" class="headerlink" title="11. UserInfo"></a>11. UserInfo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 用户名 */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">/** 手机号 */</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">    <span class="comment">/** 邮箱 */</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">/** 密码 */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/** 盐 */</span></span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccessToken accessToken;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">(String username, String password, String salt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.salt = salt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-ApiCodeEnum"><a href="#12-ApiCodeEnum" class="headerlink" title="12. ApiCodeEnum"></a>12. ApiCodeEnum</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码code可以使用纯数字,使用不同区间标识一类错误，也可以使用纯字符，也可以使用前缀+编号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 错误码：ERR + 编号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以使用日志级别的前缀作为错误类型区分 Info(I) Error(E) Warning(W)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 或者以业务模块 + 错误号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * TODO 错误码设计</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Alipay 用了两个code，两个msg(https://docs.open.alipay.com/api_1/alipay.trade.pay)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ApiCodeEnum &#123;</span><br><span class="line">    SUCCESS(<span class="string">"10000"</span>, <span class="string">"success"</span>),</span><br><span class="line">    UNKNOW_ERROR(<span class="string">"ERR0001"</span>,<span class="string">"未知错误"</span>),</span><br><span class="line">    PARAMETER_ERROR(<span class="string">"ERR0002"</span>,<span class="string">"参数错误"</span>),</span><br><span class="line">    TOKEN_EXPIRE(<span class="string">"ERR0003"</span>,<span class="string">"认证过期"</span>),</span><br><span class="line">    REQUEST_TIMEOUT(<span class="string">"ERR0004"</span>,<span class="string">"请求超时"</span>),</span><br><span class="line">    SIGN_ERROR(<span class="string">"ERR0005"</span>,<span class="string">"签名错误"</span>),</span><br><span class="line">    REPEAT_SUBMIT(<span class="string">"ERR0006"</span>,<span class="string">"请不要频繁操作"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 代码 */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 结果 */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    ApiCodeEnum(String code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-ApiResult"><a href="#13-ApiResult" class="headerlink" title="13. ApiResult"></a>13. ApiResult</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 代码 */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 结果 */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-ApiUtil-——-这个参考支付宝加密的算法写的-我直接Copy过来了。"><a href="#14-ApiUtil-——-这个参考支付宝加密的算法写的-我直接Copy过来了。" class="headerlink" title="14. ApiUtil ——-这个参考支付宝加密的算法写的.我直接Copy过来了。"></a>14. ApiUtil ——-这个参考支付宝加密的算法写的.我直接Copy过来了。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按参数名升续拼接参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatSignString</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; paramterMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        request.getParameterMap().forEach((key, value) -&gt; paramterMap.put(key, value[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">// 按照key升续排序，然后拼接参数</span></span><br><span class="line">        Set&lt;String&gt; keySet = paramterMap.keySet();</span><br><span class="line">        String[] keyArray = keySet.toArray(<span class="keyword">new</span> String[keySet.size()]);</span><br><span class="line">        Arrays.sort(keyArray);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String k : keyArray) &#123;</span><br><span class="line">            <span class="comment">// 或略掉的字段</span></span><br><span class="line">            <span class="keyword">if</span> (k.equals(<span class="string">"sign"</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (paramterMap.get(k).trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 参数值为空，则不参与签名</span></span><br><span class="line">                sb.append(k).append(<span class="string">"="</span>).append(paramterMap.get(k).trim()).append(<span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatSignString</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; paramterMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.forEach((key, value) -&gt; paramterMap.put(key, value));</span><br><span class="line">        <span class="comment">// 按照key升续排序，然后拼接参数</span></span><br><span class="line">        Set&lt;String&gt; keySet = paramterMap.keySet();</span><br><span class="line">        String[] keyArray = keySet.toArray(<span class="keyword">new</span> String[keySet.size()]);</span><br><span class="line">        Arrays.sort(keyArray);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String k : keyArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (paramterMap.get(k).trim().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 参数值为空，则不参与签名</span></span><br><span class="line">                sb.append(k).append(<span class="string">"="</span>).append(paramterMap.get(k).trim()).append(<span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取方法上的<span class="doctag">@NotRepeatSubmit</span>注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NotRepeatSubmit <span class="title">getNotRepeatSubmit</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">            HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            NotRepeatSubmit annotation = method.getAnnotation(NotRepeatSubmit.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> annotation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-ApiResponse"><a href="#15-ApiResponse" class="headerlink" title="15. ApiResponse"></a>15. ApiResponse</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** 结果 */</span></span><br><span class="line">    <span class="keyword">private</span> ApiResult result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据 */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 签名 */</span></span><br><span class="line">    <span class="keyword">private</span> String sign;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse <span class="title">success</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response(ApiCodeEnum.SUCCESS.getCode(), ApiCodeEnum.SUCCESS.getMsg(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApiResponse <span class="title">error</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response(code, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ApiResponse <span class="title">response</span><span class="params">(String code, String msg, T data)</span> </span>&#123;</span><br><span class="line">        ApiResult result = <span class="keyword">new</span> ApiResult(code, msg);</span><br><span class="line">        ApiResponse response = <span class="keyword">new</span> ApiResponse();</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        response.setData(data);</span><br><span class="line"></span><br><span class="line">        String sign = signData(data);</span><br><span class="line">        response.setSign(sign);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">signData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 查询key</span></span><br><span class="line">        String key = <span class="string">"12345678954556"</span>;</span><br><span class="line">        Map&lt;String, String&gt; responseMap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            responseMap = getFields(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String urlComponent = ApiUtil.concatSignString(responseMap);</span><br><span class="line">        String signature = urlComponent + <span class="string">"key="</span> + key;</span><br><span class="line">        String sign = MD5Util.encode(signature);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 反射的对象,获取对象的字段名和值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getFields</span><span class="params">(Object data)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Field[] fields = data.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            Field field = fields[i];</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            String name = field.getName();</span><br><span class="line">            Object value = field.get(data);</span><br><span class="line">            <span class="keyword">if</span> (field.get(data) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                map.put(name, value.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七-ThreadLocal"><a href="#七-ThreadLocal" class="headerlink" title="七: ThreadLocal"></a>七: ThreadLocal</h1><p>ThreadLocal是线程内的全局上下文。就是在单个线程中，方法之间共享的内存，每个方法都可以从该上下文中获取值和修改值。</p><h5 id="实际案例："><a href="#实际案例：" class="headerlink" title="实际案例："></a>实际案例：</h5><p>在调用api时都会传一个token参数，通常会写一个拦截器来校验token是否合法，我们可以通过token找到对应的用户信息(User)，如果token合法，然后将用户信息存储到ThreadLocal中，这样无论是在controller、service、dao的哪一层都能访问到该用户的信息。作用类似于Web中的request作用域。</p><p>传统方式我们要在方法中访问某个变量，可以通过传参的形式往方法中传参，如果多个方法都要使用那么每个方法都要传参；如果使用ThreadLocal所有方法就不需要传该参数了，每个方法都可以通过ThreadLocal来访问该值。</p><ul><li>ThreadLocalUtil.set(“key”, value); 保存值</li><li>T value = ThreadLocalUtil.get(“key”); 获取值</li></ul><p>ThreadLocalUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUtil</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getThreadLocal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key,T defaultValue)</span> </span>&#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key) == <span class="keyword">null</span> ? defaultValue : (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Map&lt;String, Object&gt; keyValueMap)</span> </span>&#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        map.putAll(keyValueMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Map&lt;String,T&gt; <span class="title">fetchVarsByPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,T&gt; vars = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>( prefix == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> vars;</span><br><span class="line">        &#125;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        Set&lt;Map.Entry&gt; set = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( Map.Entry entry : set)&#123;</span><br><span class="line">            Object key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span>( key <span class="keyword">instanceof</span> String )&#123;</span><br><span class="line">                <span class="keyword">if</span>( ((String) key).startsWith(prefix) )&#123;</span><br><span class="line">                    vars.put((String)key,(T)entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( prefix == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map map = (Map)threadLocal.get();</span><br><span class="line">        Set&lt;Map.Entry&gt; set = map.entrySet();</span><br><span class="line">        List&lt;String&gt; removeKeys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( Map.Entry entry : set )&#123;</span><br><span class="line">            Object key = entry.getKey();</span><br><span class="line">            <span class="keyword">if</span>( key <span class="keyword">instanceof</span> String )&#123;</span><br><span class="line">                <span class="keyword">if</span>( ((String) key).startsWith(prefix) )&#123;</span><br><span class="line">                    removeKeys.add((String)key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( String key : removeKeys )&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结: 这个是目前第三方数据接口交互过程中常用的一些参数与使用示例，希望对大家有点帮助。</strong></p><p><strong>当然如果为了保证更加的安全，可以加上RSA,RSA2，AES等等加密方式，保证了数据的更加的安全，但是唯一的缺点是加密与解密比较耗费CPU的资源.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载，&lt;a href=&quot;https://mp.weixin.qq.com/s/G94Z3BC5pZxPdbFxEnCyrw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明：在实际的业务中，难免会跟第三方系统进行数据的交互与传递，那么如何保证数据在传输过程中的安全呢（防窃取）？除了https的协议之外，能不能加上通用的一套算法以及规范来保证传输的安全性呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面我们就来讨论下常用的一些API设计的安全方法，可能不一定是最好的，有更牛逼的实现方式，但是这篇是我自己的经验分享.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一：token-简介&quot;&gt;&lt;a href=&quot;#一：token-简介&quot; class=&quot;headerlink&quot; title=&quot;一：token 简介&quot;&gt;&lt;/a&gt;一：token 简介&lt;/h1&gt;&lt;p&gt;Token：访问令牌access token, 用于接口中, 用于标识接口调用者的身份、凭证，减少用户名和密码的传输次数。一般情况下客户端(接口调用方)需要先向服务器端申请一个接口调用的账号，服务器会给出一个appId和一个key, key用于参数签名使用，注意key保存到客户端，需要做一些安全处理，防止泄露。&lt;/p&gt;
&lt;p&gt;Token的值一般是UUID，服务端生成Token后需要将token做为key，将一些和token关联的信息作为value保存到缓存服务器中(redis)，当一个请求过来后，服务器就去缓存服务器中查询这个Token是否存在，存在则调用接口，不存在返回接口错误，一般通过拦截器或者过滤器来实现，Token分为两种：&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="Spring" scheme="http://www.sjsmile.cn/tags/Spring/"/>
    
      <category term="API" scheme="http://www.sjsmile.cn/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Streams：深入剖析Redis5.0全新数据结构</title>
    <link href="http://www.sjsmile.cn/2020/05/17/redis/Streams%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Redis5-0%E5%85%A8%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.sjsmile.cn/2020/05/17/redis/Streams%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Redis5-0%E5%85%A8%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-05-17T04:17:11.000Z</published>
    <updated>2020-05-17T04:27:21.696Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载：<a href="https://mp.weixin.qq.com/s/GpG3t_O_SxLGNklVnoOiYQ" target="_blank" rel="noopener">原文地址</a></p></blockquote><p>Redis 5.0 全新的数据类型：streams，官方把它定义为：<strong>以更抽象的方式建模日志的数据结构</strong>。Redis的streams主要是一个append only的数据结构，至少在概念上它是一种在内存中表示的抽象数据类型，只不过它们实现了更强大的操作，以克服日志文件本身的限制。</p><p>如果你了解MQ，那么可以把streams当做MQ。如果你还了解kafka，那么甚至可以把streams当做kafka。</p><p>另外，这个功能有点类似于redis以前的<strong>Pub/Sub</strong>，但是也有基本的不同：</p><ul><li><p>streams支持多个客户端（消费者）等待数据（Linux环境开多个窗口执行XREAD即可模拟），并且每个客户端得到的是完全相同的数据。</p></li><li><p>Pub/Sub是发送忘记的方式，并且不存储任何数据；而streams模式下，所有消息被无限期追加在streams中，除非用于显示执行删除（XDEL）。</p></li><li><p>streams的Consumer Groups也是Pub/Sub无法实现的控制方式。</p><a id="more"></a></li></ul><h3 id="1-streams数据结构"><a href="#1-streams数据结构" class="headerlink" title="1. streams数据结构"></a>1. streams数据结构</h3><p>streams数据结构本身非常简单，但是streams依然是Redis到目前为止最复杂的类型，其原因是实现的一些额外的功能：一系列的阻塞操作允许消费者等待生产者加入到streams的新数据。另外还有一个称为<strong>Consumer Groups</strong>的概念，这个概念最先由kafka提出，Redis有一个类似实现，和kafka的Consumer Groups的目的是一样的：允许一组客户端协调消费相同的信息流！</p><p>redis源码中定义streams结构的源码如下，由源码可知，stream的核心数据结构是radix tree：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stream</span> &#123;</span></span><br><span class="line">    rax *rax;               <span class="comment">/* The radix tree holding the stream. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> length;        <span class="comment">/* Number of elements inside this stream. */</span></span><br><span class="line">    streamID last_id;       <span class="comment">/* Zero if there are yet no items. */</span></span><br><span class="line">    rax *cgroups;           <span class="comment">/* Consumer groups dictionary: name -&gt; streamCG */</span></span><br><span class="line">&#125; stream;</span><br></pre></td></tr></table></figure><blockquote><p>源码参考：<a href="https://github.com/antirez/redis/blob/5.0.0/src/stream.h；" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/5.0.0/src/stream.h；</a></p></blockquote><p>至于redis对radix tree的实现，参考源码：<a href="https://github.com/antirez/redis/blob/5.0.0/src/rax.c" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/5.0.0/src/rax.c</a> 和 <a href="https://github.com/antirez/redis/blob/5.0.0/src/rax.h" target="_blank" rel="noopener">https://github.com/antirez/redis/blob/5.0.0/src/rax.h</a> 。网上也有很多radix tree的文章，本篇文章就不做过多的介绍了。下面给出一张从官方源码中的部分截图：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589689130577.webp" alt="radix tree" title="" class="">                <p>radix tree</p>            </figure><h3 id="2-streams基础"><a href="#2-streams基础" class="headerlink" title="2. streams基础"></a>2. streams基础</h3><p>为了理解streams的目的，以及如何使用它，我们先忽略掉所有高级特性，只把注意力放在数据结构本身，以及那些操作和访问streams的命令。这基本上也是大多数其他Redis数据类型共有的部分，例如Lists，Sets，Sorted Sets等。然而需要注意的是，Lists也有一个更复杂的阻塞式的API，例如BLPOP，BRPOP等。streams这方便的API也没什么不同，只是更复杂，更强大（更牛逼，哈）！</p><h3 id="3-streams命令"><a href="#3-streams命令" class="headerlink" title="3. streams命令"></a>3. streams命令</h3><p>废话不多说，先上手玩玩这个全新的数据类型。streams这个数据类型对应有如下13个操作命令，所有命令都以”<strong>X</strong>“开头：</p><h4 id="1-XADD"><a href="#1-XADD" class="headerlink" title="1. XADD"></a>1. XADD</h4><p><strong>用法</strong>：XADD key ID field string [field string …]<br>正如其名，这个命令就是用来添加的，给streams追加（append，前面提到过：streams主要是一个append only的数据结构）一个新的entry（和Java里的Map类似，Redis里的streams中的数据也称为entry）。</p><p><strong>key</strong>：的含义就是同一类型streams的名称；<br><strong>ID</strong>: streams中entry的唯一标识符，如果执行XADD命令时，传入星号（*），那么，ID会自动生成，且自动生成的ID会在执行XADD后返回，默认生成的ID格式为millisecondsTime+sequenceNumber，即当前毫秒级别的时间戳加上一个自增序号值，例如<code>&quot;1540013735401-0&quot;</code>。并且执行XADD时，不接受少于或等于上一次执行XADD的ID，否则会报错：<code>ERR The ID specified in XADD is equal or smaller than the target stream top item</code>；<br><strong>field&amp;string</strong>：接下来就是若干组field string。可以把它理解为表示属性的json中的key-value。例如，某一streams的key命名为userInfo，且某个用户信息为{“username”:”afei”, “password”:”123456”}，那么执行XADD命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; xadd userInfo * username afei password 123456</span><br><span class="line">"1540014082060-0"</span><br></pre></td></tr></table></figure><blockquote><p>由于命令中ID字段的值是星号，所以自定生成ID，<code>1540014082060-0</code>就是自动生成的ID。 XADD命令也支持显示指定ID，例如：<code>XADD streamname 0-2 foo bar</code>。</p></blockquote><ul><li>时钟回拨</li></ul><p>需要注意的是，ID的时间戳部分是部署Redis服务器的本地时间，如果发生时钟回拨会怎么样？如果发生始终回拨，生成的ID的时间戳部分就是回拨后的时间，然后加上这个时间的递增序列号。例如当前时间戳1540014082060，然后这时候发生了时钟回拨，且回拨5ms，那么时间戳就是1540014082055。假设以前已经生成了1540014082055-0，1540014082055-1，那么这次由于时钟回拨，生成的ID就是1540014082055-2。所以允许自动生成的ID在发生时钟回拨时少于上次的ID，但是不允许显示指定一个少于上次的ID。</p><h4 id="2-XDEL"><a href="#2-XDEL" class="headerlink" title="2. XDEL"></a>2. XDEL</h4><p><strong>用法</strong>：XDEL key ID [ID …]<br>和XADD相反，这是命令用来从streams中删除若干个entry，并且会返回<strong>实际</strong>删除数，这个删除数可能和参数ID个数不等，因为某些ID表示的消息可能不存在。执行命令如下，第二个参数ID是不存在的，所以XDEL的返回结果是1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XDEL userInfo "1540014379642-0" "1540014379642-1"</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h4 id="3-XLEN"><a href="#3-XLEN" class="headerlink" title="3. XLEN"></a>3. XLEN</h4><p><strong>用法</strong>：XLEN key<br>很好理解，这个命令就是用来返回streams中有多少个entry。执行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XLEN userInfo</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h4 id="4-streams三种查询模式"><a href="#4-streams三种查询模式" class="headerlink" title="4. streams三种查询模式"></a>4. streams三种查询模式</h4><p>redis提供了三种查询streams数据的模式：</p><ol><li><strong>范围查询</strong>：因为streams的每个entry，其默认生成的ID是基于时间且递增的；</li><li><strong>监听模式</strong>：类比linux中的tailf命令，实时接收新增加到streams中的entry（也有点像一个消息系统，事实上笔者认为它就是借鉴了kafka）；</li><li><strong>消费者组</strong>：即Consumer Groups，特殊的监听模式。从一个消费者的角度来看streams，一个streams能被分区到多个处理消息的消费者，对于任意一条消息，同一个消费者组中只有一个消费者可以处理（和kafka的消费者组完全一样）。这样还能够横向扩容消费者，从而提升处理消息的能力，而不需要只让把让一个消费者处理所有消息。</li></ol><p>接下里分别介绍这三种模式。</p><h4 id="5-XRANGE"><a href="#5-XRANGE" class="headerlink" title="5. XRANGE"></a>5. XRANGE</h4><p><strong>用法</strong>：XRANGE key start end [COUNT count]<br>这个命令属于第1种模式，即基于范围查询。这个命令用来返回streams某个顺序范围下的元素，start参数是更小的ID，end参数是更大的ID。有两个特殊的ID用符号”-“和”+”表示，符号”-“表示最小的ID，符号”+”表示最大的ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XRANGE userInfo "1540014096298-0" "1540014477236-0"</span><br><span class="line">1) 1) "1540014096298-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "root"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "666666"</span><br><span class="line">2) 1) "1540014477236-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "test"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "111111"</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">127.0.0.1:6379&gt; XRANGE userInfo - +</span><br><span class="line">1) 1) "1540014082060-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "afei"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "123456"</span><br><span class="line">2) 1) "1540014096298-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "root"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "666666"</span><br><span class="line">3) 1) "1540014477236-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "test"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "111111"</span><br><span class="line">4) 1) "1540014493402-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "u1"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "111111"</span><br></pre></td></tr></table></figure><p>XRANGE还能实现遍历某个范围区间的功能，例如我想遍历2018-10-20号新增的用户信息。首先得到2018-10-20 00:00:00对应的时间戳为1539964800000，再得到2018-10-20 23:59:59对应的时间戳为1540051199000，然后执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XRANGE userInfo 1539964800000-0  1540051199000-0 COUNT 5</span><br><span class="line">1) 1) "1540014082060-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "afei"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "123456"</span><br><span class="line">... ...</span><br><span class="line">5) 1) "1540014496505-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "u2"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "111111"</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="meta">#</span> 需要注意的是，接下来再遍历的start参数是上一次遍历结果最大的ID加1，即"1540014496505-0"加1就是"1540014496505-1"。</span><br><span class="line">127.0.0.1:6379&gt; XRANGE userInfo 1540014496505-1  1540051199000-0 COUNT 5</span><br><span class="line">1) 1) "1540014499863-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "u3"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "111111"</span><br></pre></td></tr></table></figure><h4 id="6-XREVRANGE"><a href="#6-XREVRANGE" class="headerlink" title="6. XREVRANGE"></a>6. XREVRANGE</h4><p><strong>用法</strong>：XREVRANGE key end start [COUNT count]<br>这个命令也属于第1种模式，且和XRANGE相反，返回一个逆序范围。end参数是更大的ID，start参数是更小的ID。执行示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREVRANGE userInfo "1540014477236-0" "1540014096298-0"</span><br></pre></td></tr></table></figure><h4 id="7-XREAD"><a href="#7-XREAD" class="headerlink" title="7. XREAD"></a>7. XREAD</h4><p><strong>用法</strong>：XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] ID [ID …]<br>很明显，这个命令就是用来实现第2个模式，即监听模式。其作用是返回streams中从来没有读取的，且比参数ID更大的元素。</p><p>这个命令的使用方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREAD COUNT 10 BLOCK 60000 STREAMS userInfo "1540041139268-0"</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540041264182-0"</span><br><span class="line">         2) 1) "u2"</span><br><span class="line">            2) "p2"</span><br><span class="line">(9.26s)</span><br><span class="line"><span class="meta">#</span> "1540041264182-0"这条消息时通过XADD添加的然后被XREAD监听到的消息。</span><br><span class="line">127.0.0.1:6379&gt; XREAD COUNT 2 STREAMS userInfo 0</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540014082060-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "afei"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "123456"</span><br><span class="line">      2) 1) "1540014096298-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "root"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "666666"</span><br><span class="line"><span class="meta">#</span> 这条命令实现类似XRANGE的功能。</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; XREAD BLOCK 0 STREAMS userInfo $</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540042613437-0"</span><br><span class="line">         2) 1) "u7"</span><br><span class="line">            2) "p7"</span><br><span class="line"><span class="meta">#</span> 说明BLOCK为0表示一致等待知道有新的数据，否则永远不会超时。并且ID的值我们用特殊字符`$`表示，这个特殊字符表示我们只获取最新添加的消息。</span><br></pre></td></tr></table></figure><p>此外，XREAD还支持同时监听多个streams，用法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREAD BLOCK 0 STREAMS userInfo_01 userInfo_02 userInfo_03 userInfo_04  $ $ $ $</span><br><span class="line">1) 1) "userInfo_03"</span><br><span class="line">   2) 1) 1) "1540043348287-0"</span><br><span class="line">         2) 1) "u1"</span><br><span class="line">            2) "p1"</span><br><span class="line">(3.49s)</span><br><span class="line"><span class="meta">#</span> 监听userInfo_01~userInfo_04这4个streams的新的消息。</span><br></pre></td></tr></table></figure><p>XREAD除了COUNT和BLOCK，没有其他选项了。所有XREAD是一个非常基本的命令。更多高级特性可以往下看接下来要介绍的XREADGROUP。</p><h4 id="8-XREADGROUP"><a href="#8-XREADGROUP" class="headerlink" title="8. XREADGROUP"></a>8. XREADGROUP</h4><p>用法：XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] STREAMS key [key …] ID [ID …]<br>很明显，这就是第三种模式：消费者组模式。</p><p>如果你了解kafka的消费者组，那么你就也了解了streams的消费者组。如果不了解也没关系，笔者简单解释一下，假设有三个消费者C1，C2，C3。在streams中总计有7条消息：1， 2， 3， 4， 5， 6， 7，那么消费关系如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; C1</span><br><span class="line">2 -&gt; C2</span><br><span class="line">3 -&gt; C3</span><br><span class="line">4 -&gt; C1</span><br><span class="line">5 -&gt; C2</span><br><span class="line">6 -&gt; C3</span><br><span class="line">7 -&gt; C1</span><br></pre></td></tr></table></figure><p>消费者组具备如下几个特点：</p><ol><li>同一个消息不会被投递到一个消费者组下的多个消费者，只可能是一个消费者。</li><li>同一个消费者组下，每个消费者都是唯一的，通过大小写敏感的名字区分。</li><li>消费者组中的消费者请求的消息，一定是新的，从来没有投递过的消息。</li><li>消费一个消息后，需要用命令（XACK）确认，意思是说：这条消息已经给成功处理。正因为如此，当访问streams的历史消息时，每个消费者只能看到投递给它自己的消息。</li></ol><p>消费者组抽象的想象成如下这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------------+</span><br><span class="line">| consumer_group_name: afeigroup         |</span><br><span class="line">| consumer_group_stream: somekey         |</span><br><span class="line">| last_delivered_id: 1292309234234-92    |</span><br><span class="line">|                                        |</span><br><span class="line">| consumers:                             |</span><br><span class="line">|    &quot;consumer-1&quot; with pending messages  |</span><br><span class="line">|       1292309234234-4                  |</span><br><span class="line">|       1292309234232-8                  |</span><br><span class="line">|    &quot;consumer-42&quot; with pending messages |</span><br><span class="line">|       ... (and so forth)               |</span><br><span class="line">+----------------------------------------+</span><br></pre></td></tr></table></figure><h4 id="9-XACK"><a href="#9-XACK" class="headerlink" title="9. XACK"></a>9. XACK</h4><p><strong>用法</strong>：XACK key group ID [ID …]<br>这是消费者组相关的另一个重要的命令。标记一个处理中的消息为已被正确处理，如此一来，这条消息就会被从消费者组的pending消息集合中删除，类似MQ中的ack。</p><h4 id="10-XGROUP"><a href="#10-XGROUP" class="headerlink" title="10. XGROUP"></a>10. XGROUP</h4><p><strong>用法</strong>：XGROUP [CREATE key groupname id-or-<code>$</code>] [SETID key id-or-<code>$</code>] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</p><p>这也是消费者组的一个重要命令，这个命令用来管理消费者组，例如创建，删除等。</p><p>XREADGROUP，XACK，XGROUP三种命令构成了消费者组相关的操作命令，下面是消费者组一些操作示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建一个消费者组</span><br><span class="line">127.0.0.1:6379&gt; XGROUP CREATE userInfo GRP-AFEI $</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span> 需要注意的是，目前XGROUP CREATE的streams必须是一个存在的streams，否则会报错：</span><br><span class="line">127.0.0.1:6379&gt; XGROUP CREATE userinfo GRP-AFEI $</span><br><span class="line">(error) ERR The XGROUP subcommand requires the key to exist. Note that for CREATE you may want to use the MKSTREAM option to create an empty stream automatically.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 名为zhangsan的消费者，需要注意的是streams名称userInfo后面的特殊符号`&gt;`表示这个消费者只接收从来没有被投递给其他消费者的消息，即新的消息。当然我们也可以指定具体的ID，例如指定0表示访问所有投递给该消费者的历史消息，指定1540081890919-1表示投递给该消费者且大于这个ID的历史消息：</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup zhangsan COUNT 1 BLOCK 0 STREAMS userInfo &gt;</span><br><span class="line"><span class="meta">#</span> 名为lisi的消费者：</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup lisi COUNT 1 BLOCK 0 STREAMS userInfo &gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 接下来分别添加两条信息，一条就会被zhangsan消费，另一条被lisi消费：</span><br><span class="line">127.0.0.1:6379&gt; XADD userInfo * username u102102 password p102102</span><br><span class="line">"1540081873370-0"</span><br><span class="line">127.0.0.1:6379&gt; XADD userInfo * username u102103 password p102103</span><br><span class="line">"1540081890919-0"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>现在消费者lisi有一条消息：</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup lisi COUNT 5 BLOCK 0 STREAMS userInfo 0</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540081890919-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "u102103"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "p102103"</span><br><span class="line"><span class="meta">#</span>然后通过命令ack这条消息：</span><br><span class="line">127.0.0.1:6379&gt; XACK userInfo mygroup 1540081890919-0</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span> 再看消费者lisi的pending队列，已经为空：</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup lisi COUNT 5 BLOCK 0 STREAMS userInfo 0</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) (empty list or set)</span><br></pre></td></tr></table></figure><h4 id="11-XPENDING"><a href="#11-XPENDING" class="headerlink" title="11. XPENDING"></a>11. XPENDING</h4><p>用法：XPENDING key group [start end count] [consumer]<br>返回streams中消费者组的pending消息，即消费者接收到但是还没有ack的消息，用法参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看消费者组下总计最多10条pending消息</span><br><span class="line">127.0.0.1:6379&gt; XPENDING userInfo mygroup - + 10</span><br><span class="line">1) 1) "1540083260408-0"</span><br><span class="line">   2) "zhangsan"</span><br><span class="line">   3) (integer) 183551</span><br><span class="line">   4) (integer) 1</span><br><span class="line">2) 1) "1540083266293-0"</span><br><span class="line">   2) "lisi"</span><br><span class="line">   3) (integer) 177666</span><br><span class="line">   4) (integer) 1</span><br><span class="line"><span class="meta">#</span> 查看消费者组下zhangsan这个消费者总计最多10条pending消息</span><br><span class="line">127.0.0.1:6379&gt; XPENDING userInfo mygroup - + 10 zhangsan</span><br><span class="line">1) 1) "1540083260408-0"</span><br><span class="line">   2) "zhangsan"</span><br><span class="line">   3) (integer) 187006</span><br><span class="line">   4) (integer) 1</span><br></pre></td></tr></table></figure><h4 id="12-XCLAIM"><a href="#12-XCLAIM" class="headerlink" title="12. XCLAIM"></a>12. XCLAIM</h4><p>用法：XCLAIM key group consumer min-idle-time ID [ID …] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]<br>作用是改变消费者组中消息的所有权，用法参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup zhangsan COUNT 5 BLOCK 0 STREAMS userInfo 0</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540083260408-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "u102106"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "p102106"</span><br><span class="line"><span class="meta">#</span> zhangsan本来有1条消息，现在将另一条本来属于lisi的消息的所有权转给它：</span><br><span class="line">127.0.0.1:6379&gt; XCLAIM userInfo mygroup zhangsan 360 1540083266293-0</span><br><span class="line">1) 1) "1540083266293-0"</span><br><span class="line">   2) 1) "username"</span><br><span class="line">      2) "u102107"</span><br><span class="line">      3) "password"</span><br><span class="line">      4) "p102107"</span><br><span class="line"><span class="meta">#</span> 现在zhangsan有两条消息了</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP GROUP mygroup zhangsan COUNT 5 BLOCK 0 STREAMS userInfo 0</span><br><span class="line">1) 1) "userInfo"</span><br><span class="line">   2) 1) 1) "1540083260408-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "u102106"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "p102106"</span><br><span class="line">      2) 1) "1540083266293-0"</span><br><span class="line">         2) 1) "username"</span><br><span class="line">            2) "u102107"</span><br><span class="line">            3) "password"</span><br><span class="line">            4) "p102107"</span><br></pre></td></tr></table></figure><h4 id="13-XINFO"><a href="#13-XINFO" class="headerlink" title="13. XINFO"></a>13. XINFO</h4><p><strong>用法</strong>：XINFO [CONSUMERS key groupname] [GROUPS key] [STREAM key] [HELP]<br>其作用是得到streams和消费者组的一些信息，使用参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XINFO CONSUMERS userInfo mygroup </span><br><span class="line">1) 1) "name"</span><br><span class="line">   2) "lisi"</span><br><span class="line">   3) "pending"</span><br><span class="line">   4) (integer) 0</span><br><span class="line">   5) "idle"</span><br><span class="line">   6) (integer) 201086</span><br><span class="line">2) 1) "name"</span><br><span class="line">   2) "zhangsan"</span><br><span class="line">   3) "pending"</span><br><span class="line">   4) (integer) 2</span><br><span class="line">   5) "idle"</span><br><span class="line">   6) (integer) 701954</span><br><span class="line">127.0.0.1:6379&gt; XINFO STREAM userInfo</span><br><span class="line"> 1) "length"</span><br><span class="line"> 2) (integer) 22</span><br><span class="line"> 3) "radix-tree-keys"</span><br><span class="line"> 4) (integer) 1</span><br><span class="line"> 5) "radix-tree-nodes"</span><br><span class="line"> 6) (integer) 2</span><br><span class="line"> 7) "groups"</span><br><span class="line"> 8) (integer) 2</span><br><span class="line"> 9) "last-generated-id"</span><br><span class="line">10) "1540082298051-0"</span><br><span class="line">11) "first-entry"</span><br><span class="line">12) 1) "1540014082060-0"</span><br><span class="line">    2) 1) "username"</span><br><span class="line">       2) "afei"</span><br><span class="line">       3) "password"</span><br><span class="line">       4) "123456"</span><br><span class="line">13) "last-entry"</span><br><span class="line">14) 1) "1540082298051-0"</span><br><span class="line">    2) 1) "username"</span><br><span class="line">       2) "u102105"</span><br><span class="line">       3) "password"</span><br><span class="line">       4) "p102105"</span><br></pre></td></tr></table></figure><h4 id="14-XTRIM"><a href="#14-XTRIM" class="headerlink" title="14. XTRIM"></a>14. XTRIM</h4><p><strong>用法</strong>：XTRIM key MAXLEN [~] count<br>修剪streams到一个确定的size。Trims the stream to (approximately if ‘~’ is passed) a certain size，用法参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> streams只保留10条消息，其返回结果表示被剪去多少条消息：</span><br><span class="line">127.0.0.1:6379&gt; XTRIM userInfo MAXLEN 10</span><br><span class="line">(integer) 14</span><br></pre></td></tr></table></figure><p>说明：streams目前的修剪策略比较简单，比如连根据ID范围修剪都没有实现。根据具体某一个ID删除，可以通过XDEL实现。</p><h3 id="4-持久化，复制以及消息安全性"><a href="#4-持久化，复制以及消息安全性" class="headerlink" title="4. 持久化，复制以及消息安全性"></a>4. 持久化，复制以及消息安全性</h3><p>和其他数据类型一样，streams也会异步复制到slave，并也会持久化到AOF和RDB文件中。然而，消费者组的全部状态是被传播（propagated ）到AOF，RDB和slave中。</p><p>需要注意的是，Redis的streams和消费者组使用Redis默认复制进行持久化和复制，因此：<strong>如果消息的持久性在您的应用程序中很重要，则必须将AOF与强fsync策略一起使用</strong>。<br>默认情况下，异步复制不保证能复制每一个数据添加或使用者组状态更改：在故障转移之后，可能会丢失某些内容，具体取决于slave从master接收数据的能力。</p><ul><li>长度为0的streams</li></ul><p>这是streams和其他redis数据类型的不同，其他数据类型，例如Lists，Sets等，如果所有元素都被删除，那么key也不存在。而streams允许所有entry都被删除。</p><p>存在这种不对称性的原因是因为streams可能具有关联的消费者组，并且我们不希望由于streams中不再有任何entry而丢失消费者组定义的状态。 目前，即使没有关联的消费者群体，也不会删除该streams。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载：&lt;a href=&quot;https://mp.weixin.qq.com/s/GpG3t_O_SxLGNklVnoOiYQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Redis 5.0 全新的数据类型：streams，官方把它定义为：&lt;strong&gt;以更抽象的方式建模日志的数据结构&lt;/strong&gt;。Redis的streams主要是一个append only的数据结构，至少在概念上它是一种在内存中表示的抽象数据类型，只不过它们实现了更强大的操作，以克服日志文件本身的限制。&lt;/p&gt;
&lt;p&gt;如果你了解MQ，那么可以把streams当做MQ。如果你还了解kafka，那么甚至可以把streams当做kafka。&lt;/p&gt;
&lt;p&gt;另外，这个功能有点类似于redis以前的&lt;strong&gt;Pub/Sub&lt;/strong&gt;，但是也有基本的不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;streams支持多个客户端（消费者）等待数据（Linux环境开多个窗口执行XREAD即可模拟），并且每个客户端得到的是完全相同的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pub/Sub是发送忘记的方式，并且不存储任何数据；而streams模式下，所有消息被无限期追加在streams中，除非用于显示执行删除（XDEL）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;streams的Consumer Groups也是Pub/Sub无法实现的控制方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://www.sjsmile.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.sjsmile.cn/tags/redis/"/>
    
      <category term="streams" scheme="http://www.sjsmile.cn/tags/streams/"/>
    
      <category term="redis5.0" scheme="http://www.sjsmile.cn/tags/redis5-0/"/>
    
  </entry>
  
  <entry>
    <title>Redis高级玩法：如何利用SortedSet实现多维度排序</title>
    <link href="http://www.sjsmile.cn/2020/05/17/redis/Redis%E9%AB%98%E7%BA%A7%E7%8E%A9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8SortedSet%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%B4%E5%BA%A6%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.sjsmile.cn/2020/05/17/redis/Redis%E9%AB%98%E7%BA%A7%E7%8E%A9%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8SortedSet%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%B4%E5%BA%A6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-05-17T04:13:19.000Z</published>
    <updated>2020-05-17T04:27:09.349Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载：<a href="https://mp.weixin.qq.com/s/LpHLnmtHi35SEGiArd0Mag" target="_blank" rel="noopener">原文地址</a></p></blockquote><h1 id="一、关于SortedSet"><a href="#一、关于SortedSet" class="headerlink" title="一、关于SortedSet"></a>一、关于SortedSet</h1><p>首先，我们都知道Redis的SortedSet是可以根据score进行排序的，以手机应用商店的热门榜单排序为例，根据下载量倒序排列，其简单用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd TopApp 12000000 wechat</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd TopApp 8000000 taobao 10000000 alipay</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE TopApp 0 -1</span><br><span class="line">1) "wechat"</span><br><span class="line">2) "alipay"</span><br><span class="line">3) "taobao"</span><br></pre></td></tr></table></figure><p>对SortedSet做一下简单总结：</p><ol><li>默认升序排列，即通过命令<strong>ZRANGE</strong>实现；如果要按照降序排列，需要通过命令<strong>ZREVRANGE</strong>实现；</li><li>当score即得分一样时，按照<strong>字典顺序</strong>对member进行排序，字典排序用的是二进制，它比较的是字符串的字节数组，所以实际上是比较ASCII码。</li></ol><p>简单用法介绍完后，接下来给出几种方案，介绍<strong>如何利用Redis实现多维度排序</strong>。同样的，还是以手机应用商店的热门榜单排序为例：首先按照APP的下载量倒序排序，如果下载量一样，则按照最后更新时间倒序排列。</p><a id="more"></a><h2 id="1-方案1"><a href="#1-方案1" class="headerlink" title="1. 方案1"></a>1. 方案1</h2><p>介绍的第一个方案，并不需要依赖SortedSet，它的实现非常简单，但是需要产品做简单的妥协，即不能实时更新榜单。其实现方案是：定时每隔1分钟（可以由产品确定时间间隔）通过SQL（select * from tb_apps order by download_count desc, updated_time desc limit 300）或者其他方式计算热门榜单，然后把TOP300用List结构保存到缓存中。</p><blockquote><p>说明：根据应用商店的用户行为分析，真实用户很少会预览10页以后的数据，即使有这种用户，我们也可以忽略掉。所以只需要将总计10页，即10x30=300个APP信息用List结构保存即可。分页取数据时，通过lrange命令即可轻松实现。</p></blockquote><p>这种方案虽然简单，但是非常有用。即使不能做到实时，但是并没有影响用户体验。在项目初期需要快速发布，是一个比较推荐的做法。</p><h2 id="2-方案2"><a href="#2-方案2" class="headerlink" title="2. 方案2"></a>2. 方案2</h2><p>方案2就是本文重点介绍的利用SortedSet实现多维度排序。</p><p>介绍方案之前，我们再看一下SortedSet排序因子score，<strong>它是一个双精度64位的浮点型数字字符串。+inf和-inf都是有效值</strong>，能包括的整数范围是-(2^53) 到 +(2^53)，或者说是-9007199254740992 到 9007199254740992。</p><p>那么，我们如何实现多维度排序呢？答案是<strong>构造一个特殊的score</strong>。以本文案例为例，排序影响因子是下载量和更新时间，那么我们可以构造一个这样特殊的浮点类型的score：<strong>整数部分就是下载量，小数部分就是最后更新时间戳</strong>。</p><p>talk is cheap，show me the code。假设有5个app的下载量和最后更新时间分别如下（说明：更新时间只精确到秒）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wechat-下载量：12000000，最后更新时间：1564022201；其score为：12000000.1564022201</span><br><span class="line">qq-下载量：12000000，最后更新时间：1564022222；其score为：12000000.1564022222</span><br><span class="line">tiktok-下载量：9808900，最后更新时间：1563552267；其score为：9808900.1563552267</span><br><span class="line">taobao-下载量：11006600，最后更新时间：1564345601；其score为：11006600.1564345601</span><br><span class="line">alipay-下载量：11006600，最后更新时间：1564345600；其score为：11006600.1564345600</span><br></pre></td></tr></table></figure><p>接下来，我们通过如下命令将这5个APP用SortedSet数据类型保存到Redis中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd TopApp 12000000.1564022201 wechat 12000000.1564022222 qq 9808900.1563552267 tiktok 11006600.1564345601 taobao 11006600.1564345600 alipay</span><br></pre></td></tr></table></figure><p>保存后，我们看一下排序结果是否符合我们的预期：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrange TopApp 0 -1</span><br><span class="line">1) "qq"</span><br><span class="line">2) "wechat"</span><br><span class="line">3) "taobao"</span><br><span class="line">4) "alipay"</span><br><span class="line">5) "tiktok"</span><br></pre></td></tr></table></figure><h1 id="二、写在最后"><a href="#二、写在最后" class="headerlink" title="二、写在最后"></a>二、写在最后</h1><p>是不是很完美？</p><p>还不完美，这种讨巧的方式只能实现二维排序。如果有三维排序，四维排序呢？这里笔者提供一种实现参考，即<strong>自定义得分权重计算公式</strong>，这个公式包含所有影响排序的因子，例如：downloadCount*1000+updatedTime。这种实现无论排序维度多少都搞得定，但是需要注意的是，在具体实现时一定注意不要让score溢出。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载：&lt;a href=&quot;https://mp.weixin.qq.com/s/LpHLnmtHi35SEGiArd0Mag&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、关于SortedSet&quot;&gt;&lt;a href=&quot;#一、关于SortedSet&quot; class=&quot;headerlink&quot; title=&quot;一、关于SortedSet&quot;&gt;&lt;/a&gt;一、关于SortedSet&lt;/h1&gt;&lt;p&gt;首先，我们都知道Redis的SortedSet是可以根据score进行排序的，以手机应用商店的热门榜单排序为例，根据下载量倒序排列，其简单用法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;127.0.0.1:6379&amp;gt; zadd TopApp 12000000 wechat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(integer) 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127.0.0.1:6379&amp;gt; zadd TopApp 8000000 taobao 10000000 alipay&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(integer) 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127.0.0.1:6379&amp;gt; ZREVRANGE TopApp 0 -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1) &quot;wechat&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2) &quot;alipay&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3) &quot;taobao&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对SortedSet做一下简单总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认升序排列，即通过命令&lt;strong&gt;ZRANGE&lt;/strong&gt;实现；如果要按照降序排列，需要通过命令&lt;strong&gt;ZREVRANGE&lt;/strong&gt;实现；&lt;/li&gt;
&lt;li&gt;当score即得分一样时，按照&lt;strong&gt;字典顺序&lt;/strong&gt;对member进行排序，字典排序用的是二进制，它比较的是字符串的字节数组，所以实际上是比较ASCII码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单用法介绍完后，接下来给出几种方案，介绍&lt;strong&gt;如何利用Redis实现多维度排序&lt;/strong&gt;。同样的，还是以手机应用商店的热门榜单排序为例：首先按照APP的下载量倒序排序，如果下载量一样，则按照最后更新时间倒序排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://www.sjsmile.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.sjsmile.cn/tags/redis/"/>
    
      <category term="多维排序" scheme="http://www.sjsmile.cn/tags/%E5%A4%9A%E7%BB%B4%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis 9种数据结构以及它们的内部编码实现</title>
    <link href="http://www.sjsmile.cn/2020/05/17/redis/Redis-9%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.sjsmile.cn/2020/05/17/redis/Redis-9%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-05-17T04:02:30.000Z</published>
    <updated>2020-05-17T04:26:57.470Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载：<a href="https://mp.weixin.qq.com/s/oPDm0Jud1AuTDjtOT7BbNw" target="_blank" rel="noopener">原文地址</a></p></blockquote><p>90%的人知道Redis 5种最基本的数据结构，只有不到10%的人知道8种基本数据结构（5种基本+bitmap+GeoHash+HyperLogLog），只有不到5%的人知道9种基本数据结构（5.0最新版本数据结构Streams），只有不到1%的人掌握了所有9种基本数据结构以及8种内部编码，掌握这篇文章的知识点，让你<strong>成为面试官眼中Redis方面最靓的仔</strong>！</p><blockquote><p>说明：本文基于<strong>Redis-3.2.11</strong>版本源码进行分析。</p></blockquote><a id="more"></a><h1 id="一、5种普通数据结构"><a href="#一、5种普通数据结构" class="headerlink" title="一、5种普通数据结构"></a><strong>一、5种普通数据结构</strong></h1><p>这个没什么好说的，对Redis稍微有点了解的都知道5种最基本的数据结构：String，List，Hash，Set，Sorted Set。不过，需要注意的是，这里依然有几个高频面试题。</p><ul><li>Set和Hash的关系</li></ul><p>答案就是Set是一个特殊的value为空的Hash。Set类型操作的源码在t_set.c中。以新增一个元素为例（<code>int setTypeAdd(robj *subject, sds value)</code>），如果编码类型是<strong>OBJ_ENCODING_HT</strong>，那么新增源码的源码如下，事实上就是对dict即Hash数据结构进行操作，并且dictSetVal时value是NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (de) &#123;</span><br><span class="line">    dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">    dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们在t_hash.c中看到Hash类型新增元素时，当判断编码类型是<strong>OBJ_ENCODING_HT</strong>时，也是调用dict的方法：dictAdd(o-&gt;ptr,f,v)，dictAdd最终也是调用dictSetVal()方法，只不过v即value不为NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，Redis中Set和Hash的关系就很清楚了，当编码是OBJ_ENCODING_HT时，两者都是dict数据类型，只不过Set是value为NULL的特殊的dict。</p><ul><li>谈谈你对Sorted Set的理解</li></ul><p>Sorted Set的数据结构是一种跳表，即SkipList，如下图所示，红线是查找10的过程：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248131.webp" alt="SkipList" title="" class="">                <p>SkipList</p>            </figure><ul><li>如何借助Sorted set实现多维排序</li></ul><p>Sorted Set默认情况下只能根据一个因子score进行排序。如此一来，局限性就很大，举个栗子：热门排行榜需要按照下载量&amp;最近更新时间排序，即类似数据库中的ORDER BY download_count, update_time DESC。那这样的需求如果用Redis的Sorted Set实现呢？</p><p>事实上很简单，思路就是将涉及排序的多个维度的列通过一定的方式转换成一个特殊的列，即result = function(x, y, z)，即x，y，z是三个排序因子，例如下载量、时间等，通过自定义函数function()计算得到result，将result作为Sorted Set中的score的值，就能实现任意维度的排序需求了。</p><h1 id="二、Redis内部编码"><a href="#二、Redis内部编码" class="headerlink" title="二、Redis内部编码"></a><strong>二、Redis内部编码</strong></h1><p>我们常说的String，List，Hash，Set，Sorted Set只是对外的编码，实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis可以在合适的场景选择更合适的内部编码。</p><p>如下图所示（图片纠正：<strong>intset</strong>编码，而不是inset编码），可以看到每种数据结构都有2种以上的内部编码实现，例如String数据结构就包含了raw、int和embstr三种内部编码。同时，有些内部编码可以作为多种外部数据结构的内部实现，例如ziplist就是hash、list和zset共有的内部编码，而set的内部编码可能是hashtable或者intset：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248139.webp" alt="Redis内部编码" title="" class="">                <p>Redis内部编码</p>            </figure>Redis内部编码<br><br>Redis这样设计有两个好处：<br><br>1. 可以偷偷的改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动对外数据结构和命令。<br>2. 多种内部编码实现可以在不同场景下发挥各自的优势。例如ziplist比较节省内存，但是在列表元素比较多的情况下，性能会有所下降。这时候Redis会根据配置选项将列表类型的内部实现转换为linkedlist。<br><br>### 1. String的3种内部编码<br><br>由上图可知，String的3种内部编码分别是：int、embstr、raw。int类型很好理解，当一个key的value是整型时，Redis就将其编码为int类型（另外还有一个条件：把这个value当作字符串来看，它的长度不能超过20）。如下所示。这种编码类型为了节省内存。Redis默认会缓存10000个整型值（#define OBJ_SHARED_INTEGERS 10000），这就意味着，如果有10个不同的KEY，其value都是10000以内的值，事实上全部都是共享同一个对象：<br><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set number "7890"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding number</span><br><span class="line">"int"</span><br></pre></td></tr></table></figure><p>接下来就是ebmstr和raw两种内部编码的长度界限，请看下面的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，embstr和raw编码的长度界限是44，我们可以做如下验证。长度超过44以后，就是raw编码类型，不会有任何优化，是多长，就要消耗多少内存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name "a1234567890123456789012345678901234567890123"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line">"embstr"</span><br><span class="line">127.0.0.1:6379&gt; set name "a12345678901234567890123456789012345678901234"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line">"raw"</span><br></pre></td></tr></table></figure><p>那么为什么有embstr编码呢？它相比raw的优势在哪里？embstr编码将创建字符串对象所需的空间分配的次数从raw编码的两次降低为一次。因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能更好地利用缓存带来的优势。并且释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码对象的字符串对象需要调用两次内存释放函数。如下图所示，左边是embstr编码，右边是raw编码：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248148.webp" alt="embstr V.S. raw" title="" class="">                <p>embstr V.S. raw</p>            </figure><h3 id="2-ziplist"><a href="#2-ziplist" class="headerlink" title="2. ziplist"></a>2. ziplist</h3><p>由前面的图可知，List，Hash，Sorted Set三种对外结构，在特殊情况下的内部编码都是ziplist，那么这个ziplist有什么神奇之处呢？</p><p>以Hash为例，我们首先看一下什么条件下它的内部编码是ziplist：</p><ol><li>当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）；</li><li>所有值都小于hash-max-ziplist-value配置（默认64个字节）；</li></ol><p>如果是sorted set的话，同样需要满足两个条件：</p><ol><li>元素个数小于zset-max-ziplist-entries配置，默认128；</li><li>所有值都小于zset-max-ziplist-value配置，默认64。</li></ol><p>实际上，ziplist充分体现了Redis对于存储效率的追求。一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。而ziplist却是将表中<strong>每一项存放在前后连续的地址空间内</strong>，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p><p>ziplist的源码在ziplist.c这个文件中，其中有一段这样的描述 – The general layout of the ziplist is as follows:：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>zlbytes</strong>：表示这个ziplist占用了多少空间，或者说占了多少字节，这其中包括了zlbytes本身占用的4个字节；</li><li><strong>zltail</strong>：表示到ziplist中最后一个元素的偏移量，有了这个值，pop操作的时间复杂度就是O(1)了，即不需要遍历整个ziplist；</li><li><strong>zllen</strong>：表示ziplist中有多少个entry，即保存了多少个元素。由于这个字段占用16个字节，所以最大值是2^16-1，也就意味着，如果entry的数量超过2^16-1时，需要遍历整个ziplist才知道entry的数量；</li><li><strong>entry</strong>：真正保存的数据，有它自己的编码；</li><li><strong>zlend</strong>：专门用来表示ziplist尾部的特殊字符，占用8个字节，值固定为255，即8个字节每一位都是1。</li></ul><p>如下就是一个真实的ziplist编码，包含了2和5两个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]</span><br><span class="line">      |             |          |       |       |     |</span><br><span class="line">   zlbytes        zltail    entries   &quot;2&quot;     &quot;5&quot;   end</span><br></pre></td></tr></table></figure><h3 id="3-linkedlist"><a href="#3-linkedlist" class="headerlink" title="3. linkedlist"></a>3. linkedlist</h3><p>这是List的一种编码数据结构非常简单，就是我们非常熟悉的双向链表，对应Java中的LinkedList。</p><h3 id="4-skiplist"><a href="#4-skiplist" class="headerlink" title="4. skiplist"></a>4. skiplist</h3><p>这个前面也已经提及，就是经典的跳表数据结构。</p><h3 id="5-hashtable"><a href="#5-hashtable" class="headerlink" title="5. hashtable"></a>5. hashtable</h3><p>这个也很容易，对应Java中的HashMap。</p><h3 id="6-intset"><a href="#6-intset" class="headerlink" title="6. intset"></a>6. intset</h3><p>Set特殊内部编码，当满足下面的条件时Set的内部编码就是intset而不是hashtable：</p><ol><li>Set集合中必须是64位有符号的十进制整型；</li><li>元素个数不能超过set-max-intset-entries配置，默认512；</li></ol><p>验证如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd scores 135</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; sadd scores 128</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding scores</span><br><span class="line">"intset"</span><br></pre></td></tr></table></figure><p>那么intset编码到底是个什么东西呢？看它的源码定义如下，很明显，就是整型数组，并且是一个<strong>有序的整型数组</strong>。它在内存分配上与ziplist有些类似，是连续的一整块内存空间，而且对于大整数和小整数采取了不同的编码，尽量对内存的使用进行了优化。这样的数据结构，如果执行SISMEMBER命令，即查看某个元素是否在集合中时，事实上使用的是二分查找法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// intset编码查找方法源码（人为简化），标准的二分查找法：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure><h1 id="三、3种高级数据结构"><a href="#三、3种高级数据结构" class="headerlink" title="三、3种高级数据结构"></a><strong>三、3种高级数据结构</strong></h1><p>Redis中3种高级数据结构分别是bitmap、GEO、HyperLogLog，针对这3种数据结构，笔者之前也有文章介绍过。其中，最重要的就是<strong>bitmap</strong>。</p><h3 id="1-bitmap"><a href="#1-bitmap" class="headerlink" title="1. bitmap"></a>1. bitmap</h3><p>这个就是Redis实现的BloomFilter，BloomFilter非常简单，如下图所示，假设已经有3个元素a、b和c，分别通过3个hash算法h1()、h2()和h2()计算然后对一个bit进行赋值，接下来假设需要判断d是否已经存在，那么也需要使用3个hash算法h1()、h2()和h2()对d进行计算，然后得到3个bit的值，恰好这3个bit的值为1，这就能够说明：<strong>d可能存在集合中</strong>。再判断e，由于h1(e)算出来的bit之前的值是0，那么说明：<strong>e一定不存在集合中</strong>：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248166.webp" alt="BloomFilter" title="" class="">                <p>BloomFilter</p>            </figure>BloomFilter<br><br>需要说明的是，bitmap并不是一种真实的数据结构，它本质上是String数据结构，只不过操作的粒度变成了位，即bit。因为String类型最大长度为512MB，所以bitmap最多可以存储2^32个bit。<br><br>### 2. GEO<br><br>GEO数据结构可以在Redis中存储地理坐标，并且坐标有限制，由EPSG:900913 / EPSG:3785 / OSGEO:41001 规定如下：<br><br>1. 有效的经度从-180度到180度。<br>2. 有效的纬度从-85.05112878度到85.05112878度。<br><br>当坐标位置超出上述指定范围时，该命令将会返回一个错误。添加地理位置命令如下：<br><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span> GEOADD city 114.031040 22.324386 "shenzhen" 112.572154 22.267832 "guangzhou"</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">redis&gt;</span> GEODIST city shenzhen guangzhou</span><br><span class="line">"150265.8106"</span><br></pre></td></tr></table></figure><p>但是，需要说明的是，Geo本身不是一种数据结构，它<strong>本质上还是借助于Sorted Set（ZSET）</strong>，并且使用<strong>GeoHash</strong>技术进行填充。Redis中将经纬度使用52位的整数进行编码，放进zset中，score就是GeoHash的52位整数值。在使用Redis进行Geo查询时，其内部对应的操作其实就是zset(skiplist)的操作。通过zset的score进行排序就可以得到坐标附近的其它元素，通过将score还原成坐标值就可以得到元素的原始坐标。</p><p>总之，Redis中处理这些地理位置坐标点的思想是：二维平面坐标点 –&gt; 一维整数编码值 –&gt; zset(score为编码值) –&gt; zrangebyrank(获取score相近的元素)、zrangebyscore –&gt; 通过score(整数编码值)反解坐标点 –&gt; 附近点的地理位置坐标。</p><ul><li>GEOHASH原理</li></ul><p>使用wiki上的例子，纬度为42.6，经度为-5.6的点，转化为base32的话要如何转呢？<br>首先拿纬度来进行说明，纬度的范围为-90到90，将这个范围划为两段，则为[-90,0]、[0,90]，然后看给定的纬度在哪个范围，在前面的范围的话，就设当前位为0，后面的话值便为1.然后继续将确定的范围1分为2，继续以确定值在前段还是后段来确定bit的值。就这样慢慢的缩小范围，一般最多缩小13次就可以了(经纬度的二进制位相加最多25位，经度13位，纬度12位)。这时的中间值，将跟给定的值最相近。如下图所示：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248175.webp" alt="Geohash" title="" class="">                <p>Geohash</p>            </figure><p>第1行，纬度42.6位于[0, 90]之间，所以bit=1；第2行，纬度42.6位于[0, 45]之间，所以bit=0；第3行，纬度42.6位于[22.5, 45]之间，所以bit=1，以此类推。这样，取出图中的bit位：1011 1100 1001，同样的方法，将经度(范围-180到180)算出来为 ：0111 1100 0000 0。结果对其如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 经度</span><br><span class="line">0111 1100 0000 0</span><br><span class="line"><span class="meta">#</span> 纬度</span><br><span class="line">1011 1100 1001</span><br></pre></td></tr></table></figure><p>得到了经纬度的二进制位后，下面需要将两者进行结合：从经度、纬度的循环，每次取其二进制的一位(不足位取0)，合并为新的二进制数：01101111 11110000 01000001 0。每5位为一个十进制数，结合base32对应表映射为base32值为：ezs42。这样就完成了encode的过程。</p><h3 id="3-Streams"><a href="#3-Streams" class="headerlink" title="3. Streams"></a>3. Streams</h3><p>这是Redis5.0引入的全新数据结构，用一句话概括Streams就是Redis实现的内存版kafka。而且，Streams也有<strong>Consumer Groups</strong>的概念。通过Redis源码中对stream的定义我们可知，streams底层的数据结构是<strong>radix tree</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stream</span> &#123;</span></span><br><span class="line">    rax *rax;               <span class="comment">/* The radix tree holding the stream. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> length;        <span class="comment">/* Number of elements inside this stream. */</span></span><br><span class="line">    streamID last_id;       <span class="comment">/* Zero if there are yet no items. */</span></span><br><span class="line">    rax *cgroups;           <span class="comment">/* Consumer groups dictionary: name -&gt; streamCG */</span></span><br><span class="line">&#125; stream;</span><br></pre></td></tr></table></figure><p>那么这个radix tree长啥样呢？在Redis源码的rax.h文件中有一段这样的描述，这样看起来是不是就比较直观了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*                    (f) &quot;&quot;</span><br><span class="line">*                    /</span><br><span class="line">*                 (i o) &quot;f&quot;</span><br><span class="line">*                 /   \</span><br><span class="line">*    &quot;firs&quot;  (&quot;rst&quot;)  (o) &quot;fo&quot;</span><br><span class="line">*              /        \</span><br><span class="line">*    &quot;first&quot; []       [t   b] &quot;foo&quot;</span><br><span class="line">*                     /     \</span><br><span class="line">*           &quot;foot&quot; (&quot;er&quot;)    (&quot;ar&quot;) &quot;foob&quot;</span><br><span class="line">*                    /          \</span><br><span class="line">*          &quot;footer&quot; []          [] &quot;foobar&quot;</span><br></pre></td></tr></table></figure><p><strong>Radix Tree(基数树) 事实上就几乎相同是传统的二叉树</strong>。仅仅是在寻找方式上，以一个unsigned int类型数为例，利用这个数的每个比特位作为树节点的推断。能够这样说，比方一个数10001010101010110101010，那么依照Radix 树的插入就是在根节点，假设遇到0，就指向左节点，假设遇到1就指向右节点，在插入过程中构造树节点，在删除过程中删除树节点。如下是一个保存了7个单词的Radix Tree：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589688248187.webp" alt="radix tree" title="" class="">                <p>radix tree</p>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载：&lt;a href=&quot;https://mp.weixin.qq.com/s/oPDm0Jud1AuTDjtOT7BbNw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;90%的人知道Redis 5种最基本的数据结构，只有不到10%的人知道8种基本数据结构（5种基本+bitmap+GeoHash+HyperLogLog），只有不到5%的人知道9种基本数据结构（5.0最新版本数据结构Streams），只有不到1%的人掌握了所有9种基本数据结构以及8种内部编码，掌握这篇文章的知识点，让你&lt;strong&gt;成为面试官眼中Redis方面最靓的仔&lt;/strong&gt;！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：本文基于&lt;strong&gt;Redis-3.2.11&lt;/strong&gt;版本源码进行分析。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://www.sjsmile.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.sjsmile.cn/tags/redis/"/>
    
      <category term="缓存" scheme="http://www.sjsmile.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 集成邮件服务以及邮件发送的几种方式</title>
    <link href="http://www.sjsmile.cn/2020/05/17/java/SpringBoot-%E9%9B%86%E6%88%90%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.sjsmile.cn/2020/05/17/java/SpringBoot-%E9%9B%86%E6%88%90%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2020-05-17T03:53:58.000Z</published>
    <updated>2020-05-17T04:37:49.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载：<a href="https://mp.weixin.qq.com/s/SxdiqaFqHyK5hNcJz1uoAQ" target="_blank" rel="noopener">原文地址</a></p></blockquote><h1 id="一、SMTP协议简介"><a href="#一、SMTP协议简介" class="headerlink" title="一、SMTP协议简介"></a>一、SMTP协议简介</h1><p>  SMTP是一种提供可靠且有效的<strong>电子邮件传输</strong>的协议。SMTP是建立在<strong>FTP</strong>文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能<strong>跨越网络传输邮件</strong>，即“SMTP邮件中继”。使用SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。</p><p> 简单来说：我们使用的这些邮件发送功能，他们之间都有一个专门的电子邮件的服务器，类似于邮局，你将邮件发给邮局，邮局又会根据你的邮寄地址发送给相应的邮局，然后接收方去邮局取邮件。而邮件服务器呢，就是互联网之间的一个邮局，不同的网络之间也能实现电子邮件的发送。</p><p> Spring框架在java邮件服务的基础上进行了封装，SpringBoot在Spring的基础上对邮件服务进一步的封装，让SpringBoot发送邮件更为便利，灵活。</p> <a id="more"></a><h1 id="二、开启SMTP服务并获取授权码"><a href="#二、开启SMTP服务并获取授权码" class="headerlink" title="二、开启SMTP服务并获取授权码"></a>二、开启SMTP服务并获取授权码</h1><p> 这里我们以<strong>QQ邮箱</strong>为例，要想在SpringBoot发送QQ邮件必须先打开QQ邮箱的SMTP功能，默认是关闭的，具体操作如下。进入邮箱→设置→账户，然后找到下面这个： </p><p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589687793545.webp" alt="img"></p><p> 将第一个开启，这里我已经开启了，就不用再开启了，至于那个POP3协议,这是一种从邮件服务器上读取邮件的协议，通过POP3协议，收信人不需要参与到与邮件服务器之间的邮件读取过程，简化了用户操作. 收信人可以“离线”地进行邮件处理，很方便地接收，阅读邮件。</p><p> 然后我们开启之后还需要获取一个授权码，这个授权码我们后面编写邮件配置需要用到。获取授权码可能需要验证身份什么的。将授权码保存下来。 </p><p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589687793565.webp" alt="img"></p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="三、依赖导入与配置说明"><a href="#三、依赖导入与配置说明" class="headerlink" title="三、依赖导入与配置说明"></a>三、依赖导入与配置说明</h1><p> <strong>依赖导入</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 为了方便测试我们也需要将<strong>starter-web</strong>的依赖导入进来。</p><p> <strong>配置文件</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  mail:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">qzstudynote@qq.com</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">zxcvbnmkj</span></span><br><span class="line"><span class="attr">    properties:</span></span><br><span class="line"><span class="attr">      mail:</span></span><br><span class="line"><span class="attr">        smtp:</span></span><br><span class="line"><span class="attr">          socketFactory:</span></span><br><span class="line"><span class="attr">            class:</span> <span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line"><span class="comment">##         ssl:</span></span><br><span class="line"><span class="comment">##           enable :true</span></span><br><span class="line"><span class="attr">    default-encoding:</span> <span class="string">utf-8</span></span><br></pre></td></tr></table></figure><p> <strong>配置说明</strong>：</p><ul><li>host就是你的邮件服务器地址,</li><li>username就是你的邮箱账号，带上后缀</li><li>password就是你刚刚复制的授权码，我这里是乱写的；</li><li>default-encoding 设置邮件的编码为utf-8；</li><li>properties：额外的配置，这里我写了两个，只用其中一个就行了，开启ssl加密，保证安全连接。</li></ul><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h1 id="四、邮件发送"><a href="#四、邮件发送" class="headerlink" title="四、邮件发送"></a>四、邮件发送</h1><h2 id="1-简单邮件发送"><a href="#1-简单邮件发送" class="headerlink" title="1.简单邮件发送"></a>1.简单邮件发送</h2><p> 编写controller，或者是直接在测试模块添加测试就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSenderImpl javaMailSender;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/mail"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">        <span class="comment">//邮件设置</span></span><br><span class="line">        message.setSubject(<span class="string">"邮件主题"</span>);</span><br><span class="line">        message.setText(<span class="string">"邮件内容"</span>);</span><br><span class="line">        message.setTo(<span class="string">"xxxxxxx@139.com"</span>,<span class="string">"111111111@qq.com"</span>);</span><br><span class="line">        message.setFrom(<span class="string">"qzstudynote@qq.com"</span>);</span><br><span class="line">        javaMailSender.send(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"简单邮件发送成功！"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<strong>JavaMailSenderImpl</strong>就是一个SpringBoot中用来发送邮件的一个实现类，我们需要将它注入到bean中，以供使用。它里面有一些方法，这里只展示了简单的几个，其他的也很简单，比如说发送日期，抄送人等等。接受者可以设置多个，如上。</p><h2 id="2-带附件内容和正文带图片的邮件发送"><a href="#2-带附件内容和正文带图片的邮件发送" class="headerlink" title="2.带附件内容和正文带图片的邮件发送"></a>2.带附件内容和正文带图片的邮件发送</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/mineMail"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sendMineMail</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">     <span class="comment">//1、创建一个复杂的邮件</span></span><br><span class="line">        MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">        MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//邮件主题</span></span><br><span class="line">        helper.setSubject(<span class="string">"这是一个邮件啊"</span>);</span><br><span class="line">        <span class="comment">//文本中添加图片</span></span><br><span class="line">        helper.addInline(<span class="string">"image1"</span>,<span class="keyword">new</span> FileSystemResource(<span class="string">"D:\\images\\spring\\1.jpg"</span>));</span><br><span class="line">        <span class="comment">//邮件内容</span></span><br><span class="line">        helper.setText(<span class="string">"全栈学习笔记&lt;a href='https://www.cnblogs.com/swzx-1213/'&gt;百度一下&lt;/a&gt;    &lt;img src='cid:image1'&gt;&lt;/img&gt;"</span>,<span class="keyword">true</span>);</span><br><span class="line">        helper.setTo(<span class="string">"xxxxx@139.com"</span>);</span><br><span class="line">        helper.setFrom(<span class="string">"qzstudynote@qq.com"</span>);</span><br><span class="line">        <span class="comment">//附件添加图片</span></span><br><span class="line">        helper.addAttachment(<span class="string">"1.jpg"</span>,<span class="keyword">new</span> File(<span class="string">"D:\\images\\spring\\1.jpg"</span>));</span><br><span class="line">        <span class="comment">//附件添加word文档</span></span><br><span class="line">        helper.addAttachment(<span class="string">"哈哈哈.docx"</span>,<span class="keyword">new</span> File(<span class="string">"D:\\images\\spring\\哈哈哈.docx"</span>));</span><br><span class="line"></span><br><span class="line">        javaMailSender.send(mimeMessage);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"复杂邮件发送！"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>代码说明</strong>：</p><ul><li><p>创建一个MimeMessage 邮件，但是我们也需要创建一个工具类MimeMessageHelper，相当于代理类吧，邮件的属性配置就由这个工具类来实现。</p></li><li><p><strong>addInline()</strong>,第一个参数是一个contentId,String类型的，相当于是一个key,第二个参数是一个Resource对象，资源对象，这里我们传了一个本地的图片就用的FileSystemResource对象。当然这里是说的我们用的这个addInline方法的参数是这样，还有其他的参数类型，所谓重载。</p></li><li><p><strong>setText()</strong>，这里用到的第一个参数就是文本字符串，第二个就是是否解析文本中的html语法。</p></li><li><p><strong>addAttachment()</strong> 这个方法是用来添加附件的，附件和我们之前添加的图片不一样，附件作为一种未下载的文件，而资源文件则是直接显示到正文中。利用我自己的邮箱进行测试的截图：</p></li></ul><ul><li><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589687793569.webp" alt="img" title="" class="">                <p>img</p>            </figure></li></ul><h2 id="3-thymeleaf模板作为邮件发送"><a href="#3-thymeleaf模板作为邮件发送" class="headerlink" title="3.thymeleaf模板作为邮件发送"></a>3.thymeleaf模板作为邮件发送</h2><p> 项目中需要引入thymeleaf依赖，并且要在新建的html文件中加入：xmlns:th=”<a href="http://www.thymeleaf.org&quot;" target="_blank" rel="noopener">http://www.thymeleaf.org&quot;</a> ,不会thymeleaf的请移步之前的文章。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 这里在templates下面创建了一个email的html5文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">"这是一个链接"</span> <span class="attr">th:href</span>=<span class="string">"$&#123;link&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">"$&#123;image1&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p> controller中再添加一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/thyMail"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendThymeleafMail</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">        MimeMessageHelper messageHelper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage);</span><br><span class="line">        messageHelper.setSubject(<span class="string">"这是一个thymeleaf模板邮件"</span>);</span><br><span class="line">        messageHelper.setTo(<span class="string">"xxxxxxxx@139.com"</span>);</span><br><span class="line">        messageHelper.setFrom(<span class="string">"qzstudynote@qq.com"</span>);</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.setVariable(<span class="string">"name"</span>,<span class="string">"这是一个新建的thymeleaf模板"</span>);</span><br><span class="line">        context.setVariable(<span class="string">"link"</span>,<span class="string">"https://www.cnblogs.com/swzx-1213/"</span>);</span><br><span class="line">        context.setVariable(<span class="string">"image1"</span>,<span class="string">"https://s1.ax1x.com/2020/04/14/JShDYt.th.jpg"</span>);</span><br><span class="line">        String value = templateEngine.process(<span class="string">"email.html"</span>,context);</span><br><span class="line">        messageHelper.setText(value,<span class="keyword">true</span>);</span><br><span class="line">        javaMailSender.send(mimeMessage);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"模板邮件发送成功"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> <strong>代码说明：</strong></p><ul><li><strong>Context</strong> 属于org.thymeleaf.context这个包。</li><li><strong>context.setVariable()</strong>,第一个参数是String,第二个是Object类型。第一个参数就对应thymeleaf模板上面相同名字的参数。</li><li><strong>templateEngine.process()</strong>将指定路径的html文件转换成String类型返回。</li></ul><p> 测试： </p><p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589687793585.webp" alt="img"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p> 本文讲了基础的邮件发送原理，SMTP协议以及提到的POP3协议的概要内容。然后一起引入依赖，添加项目属性配置，最后讲解了三大类发送邮件的方式。源码获取后台回复【SpringBoot】。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载：&lt;a href=&quot;https://mp.weixin.qq.com/s/SxdiqaFqHyK5hNcJz1uoAQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、SMTP协议简介&quot;&gt;&lt;a href=&quot;#一、SMTP协议简介&quot; class=&quot;headerlink&quot; title=&quot;一、SMTP协议简介&quot;&gt;&lt;/a&gt;一、SMTP协议简介&lt;/h1&gt;&lt;p&gt;  SMTP是一种提供可靠且有效的&lt;strong&gt;电子邮件传输&lt;/strong&gt;的协议。SMTP是建立在&lt;strong&gt;FTP&lt;/strong&gt;文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能&lt;strong&gt;跨越网络传输邮件&lt;/strong&gt;，即“SMTP邮件中继”。使用SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。&lt;/p&gt;
&lt;p&gt; 简单来说：我们使用的这些邮件发送功能，他们之间都有一个专门的电子邮件的服务器，类似于邮局，你将邮件发给邮局，邮局又会根据你的邮寄地址发送给相应的邮局，然后接收方去邮局取邮件。而邮件服务器呢，就是互联网之间的一个邮局，不同的网络之间也能实现电子邮件的发送。&lt;/p&gt;
&lt;p&gt; Spring框架在java邮件服务的基础上进行了封装，SpringBoot在Spring的基础上对邮件服务进一步的封装，让SpringBoot发送邮件更为便利，灵活。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="springboot" scheme="http://www.sjsmile.cn/tags/springboot/"/>
    
      <category term="邮件" scheme="http://www.sjsmile.cn/tags/%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>30 分钟学会如何使用 Shiro</title>
    <link href="http://www.sjsmile.cn/2020/05/17/java/30-%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Shiro/"/>
    <id>http://www.sjsmile.cn/2020/05/17/java/30-%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Shiro/</id>
    <published>2020-05-17T03:17:54.000Z</published>
    <updated>2020-05-17T04:38:14.925Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>原文作者：冷豪；<a href="www.cnblogs.com/learnhow/p/5694876.html">原文地址</a></p></blockquote><h1 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a><strong>一、架构</strong></h1><p>要学习如何使用Shiro必须先从它的架构谈起，作为一款安全框架Shiro的设计相当精妙。Shiro的应用不依赖任何容器，它也可以在JavaSE下使用。但是最常用的环境还是JavaEE。下面以用户登录为例：</p><p><img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640.webp" alt="img"></p><a id="more"></a><h2 id="1、使用用户的登录信息创建令牌"><a href="#1、使用用户的登录信息创建令牌" class="headerlink" title="1、使用用户的登录信息创建令牌"></a><strong>1、使用用户的登录信息创建令牌</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br></pre></td></tr></table></figure><p>token可以理解为用户令牌，登录的过程被抽象为Shiro验证令牌是否具有合法身份以及相关权限。</p><h2 id="2、执行登陆动作"><a href="#2、执行登陆动作" class="headerlink" title="2、执行登陆动作"></a><strong>2、执行登陆动作</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SecurityUtils.setSecurityManager(securityManager); <span class="comment">// 注入SecurityManager</span></span><br><span class="line">Subject subject = SecurityUtils.getSubject(); <span class="comment">// 获取Subject单例对象</span></span><br><span class="line">subject.login(token); <span class="comment">// 登陆</span></span><br></pre></td></tr></table></figure><p>Shiro的核心部分是SecurityManager，它负责安全认证与授权。Shiro本身已经实现了所有的细节，用户可以完全把它当做一个黑盒来使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。</p><p>Subject是初学者比较难于理解的对象，很多人以为它可以等同于User，其实不然。Subject中文翻译：项目，而正确的理解也恰恰如此。它是你目前所设计的需要通过Shiro保护的项目的一个抽象概念。通过令牌（token）与项目（subject）的登陆（login）关系，Shiro保证了项目整体的安全。</p><h2 id="3、判断用户"><a href="#3、判断用户" class="headerlink" title="3、判断用户"></a><strong>3、判断用户</strong></h2><p>Shiro本身无法知道所持有令牌的用户是否合法，因为除了项目的设计人员恐怕谁都无法得知。因此Realm是整个框架中为数不多的必须由设计者自行实现的模块，当然Shiro提供了多种实现的途径，本文只介绍最常见也最重要的一种实现方式——数据库查询。</p><h2 id="4、两条重要的英文"><a href="#4、两条重要的英文" class="headerlink" title="4、两条重要的英文"></a><strong>4、两条重要的英文</strong></h2><p>我在学习Shiro的过程中遇到的第一个障碍就是这两个对象的英文名称：AuthorizationInfo，AuthenticationInfo。不用怀疑自己的眼睛，它们确实长的很像，不但长的像，就连意思都十分近似。</p><p>在解释它们前首先必须要描述一下Shiro对于安全用户的界定：和大多数操作系统一样。用户具有角色和权限两种最基本的属性。例如，我的Windows登陆名称是learnhow，它的角色是administrator，而administrator具有所有系统权限。这样learnhow自然就拥有了所有系统权限。那么其他人需要登录我的电脑怎么办，我可以开放一个guest角色，任何无法提供正确用户名与密码的未知用户都可以通过guest来登录，而系统对于guest角色开放的权限极其有限。</p><p>同理，Shiro对用户的约束也采用了这样的方式。AuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合。如此一来，当设计人员对项目中的某一个url路径设置了只允许某个角色或具有某种权限才可以访问的控制约束的时候，Shiro就可以通过以上两个对象来判断。说到这里，大家可能还比较困惑。先不要着急，继续往后看就自然会明白了。</p><h1 id="二、实现Realm"><a href="#二、实现Realm" class="headerlink" title="二、实现Realm"></a><strong>二、实现Realm</strong></h1><p>如何实现Realm是本文的重头戏，也是比较费事的部分。这里大家会接触到几个新鲜的概念：缓存机制、散列算法、加密算法。由于本文不会专门介绍这些概念，所以这里仅仅抛砖引玉的谈几点，能帮助大家更好的理解Shiro即可。</p><h2 id="1、缓存机制"><a href="#1、缓存机制" class="headerlink" title="1、缓存机制"></a><strong>1、缓存机制</strong></h2><p>Ehcache是很多Java项目中使用的缓存框架，Hibernate就是其中之一。它的本质就是将原本只能存储在内存中的数据通过算法保存到硬盘上，再根据需求依次取出。你可以把Ehcache理解为一个Map&lt;String,Object&gt;对象，通过put保存对象，再通过get取回对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;ehcache name=&quot;shirocache&quot;&gt;</span><br><span class="line">   &lt;diskStore path=&quot;java.io.tmpdir&quot; /&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;cache name=&quot;passwordRetryCache&quot;</span><br><span class="line">          maxEntriesLocalHeap=&quot;2000&quot;</span><br><span class="line">          eternal=&quot;false&quot;</span><br><span class="line">          timeToIdleSeconds=&quot;1800&quot;</span><br><span class="line">          timeToLiveSeconds=&quot;0&quot;</span><br><span class="line">          overflowToDisk=&quot;false&quot;</span><br><span class="line">          statistics=&quot;true&quot;&gt;</span><br><span class="line">   &lt;/cache&gt;</span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure><p>以上是ehcache.xml文件的基础配置，timeToLiveSeconds为缓存的最大生存时间，timeToIdleSeconds为缓存的最大空闲时间，当eternal为false时ttl和tti才可以生效。更多配置的含义大家可以去网上查询。</p><h2 id="2、散列算法与加密算法"><a href="#2、散列算法与加密算法" class="headerlink" title="2、散列算法与加密算法"></a><strong>2、散列算法与加密算法</strong></h2><p>md5是本文会使用的散列算法，加密算法本文不会涉及。散列和加密本质上都是将一个Object变成一串无意义的字符串，不同点是经过散列的对象无法复原，是一个单向的过程。例如，对密码的加密通常就是使用散列算法，因此用户如果忘记密码只能通过修改而无法获取原始密码。但是对于信息的加密则是正规的加密算法，经过加密的信息是可以通过秘钥解密和还原。</p><h2 id="3、用户注册"><a href="#3、用户注册" class="headerlink" title="3、用户注册"></a><strong>3、用户注册</strong></h2><p>请注意，虽然我们一直在谈论用户登录的安全性问题，但是说到用户登录首先就是用户注册。如何保证用户注册的信息不丢失，不泄密也是项目设计的重点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordHelper</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> RandomNumberGenerator randomNumberGenerator = <span class="keyword">new</span> SecureRandomNumberGenerator();</span><br><span class="line">   <span class="keyword">private</span> String algorithmName = <span class="string">"md5"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashIterations = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encryptPassword</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// User对象包含最基本的字段Username和Password</span></span><br><span class="line">       user.setSalt(randomNumberGenerator.nextBytes().toHex());</span><br><span class="line">       <span class="comment">// 将用户的注册密码经过散列算法替换成一个不可逆的新密码保存进数据，散列过程使用了盐</span></span><br><span class="line">       String newPassword = <span class="keyword">new</span> SimpleHash(algorithmName, user.getPassword(),</span><br><span class="line">               ByteSource.Util.bytes(user.getCredentialsSalt()), hashIterations).toHex();</span><br><span class="line">       user.setPassword(newPassword);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你不清楚什么叫加盐可以忽略散列的过程，只要明白存储在数据库中的密码是根据户注册时填写的密码所产生的一个新字符串就可以了。经过散列后的密码替换用户注册时的密码，然后将User保存进数据库。剩下的工作就丢给UserService来处理。</p><p>那么这样就带来了一个新问题，既然散列算法是无法复原的，当用户登录的时候使用当初注册时的密码，我们又应该如何判断？答案就是需要对用户密码再次以相同的算法散列运算一次，再同数据库中保存的字符串比较。</p><h2 id="4、匹配"><a href="#4、匹配" class="headerlink" title="4、匹配"></a><strong>4、匹配</strong></h2><p>CredentialsMatcher是一个接口，功能就是用来匹配用户登录使用的令牌和数据库中保存的用户信息是否匹配。当然它的功能不仅如此。本文要介绍的是这个接口的一个实现类：HashedCredentialsMatcher</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryLimitHashedCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title">HashedCredentialsMatcher</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 声明一个缓存接口，这个接口是Shiro缓存管理的一部分，它的具体实现可以通过外部容器注入</span></span><br><span class="line">   <span class="keyword">private</span> Cache&lt;String, AtomicInteger&gt; passwordRetryCache;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RetryLimitHashedCredentialsMatcher</span><span class="params">(CacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">       passwordRetryCache = cacheManager.getCache(<span class="string">"passwordRetryCache"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> </span>&#123;</span><br><span class="line">       String username = (String) token.getPrincipal();</span><br><span class="line">       AtomicInteger retryCount = passwordRetryCache.get(username);</span><br><span class="line">       <span class="keyword">if</span> (retryCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">           retryCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">           passwordRetryCache.put(username, retryCount);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 自定义一个验证过程：当用户连续输入密码错误5次以上禁止用户登录一段时间</span></span><br><span class="line">       <span class="keyword">if</span> (retryCount.incrementAndGet() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ExcessiveAttemptsException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">boolean</span> match = <span class="keyword">super</span>.doCredentialsMatch(token, info);</span><br><span class="line">       <span class="keyword">if</span> (match) &#123;</span><br><span class="line">           passwordRetryCache.remove(username);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> match;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个实现里设计人员仅仅是增加了一个不允许连续错误登录的判断。真正匹配的过程还是交给它的直接父类去完成。连续登录错误的判断依靠Ehcache缓存来实现。显然match返回true为匹配成功。</p><h2 id="5、获取用户的角色和权限信息"><a href="#5、获取用户的角色和权限信息" class="headerlink" title="5、获取用户的角色和权限信息"></a><strong>5、获取用户的角色和权限信息</strong></h2><p>说了这么多才到我们的重点Realm，如果你已经理解了Shiro对于用户匹配和注册加密的全过程，真正理解Realm的实现反而比较简单。我们还得回到上文提及的两个非常类似的对象AuthorizationInfo和AuthenticationInfo。因为Realm就是提供这两个对象的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 用户对应的角色信息与权限信息都保存在数据库中，通过UserService获取数据</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供用户信息返回权限信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">       String username = (String) principals.getPrimaryPrincipal();</span><br><span class="line">       SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">       <span class="comment">// 根据用户名查询当前用户拥有的角色</span></span><br><span class="line">       Set&lt;Role&gt; roles = userService.findRoles(username);</span><br><span class="line">       Set&lt;String&gt; roleNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">           roleNames.add(role.getRole());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将角色名称提供给info</span></span><br><span class="line">       authorizationInfo.setRoles(roleNames);</span><br><span class="line">       <span class="comment">// 根据用户名查询当前用户权限</span></span><br><span class="line">       Set&lt;Permission&gt; permissions = userService.findPermissions(username);</span><br><span class="line">       Set&lt;String&gt; permissionNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Permission permission : permissions) &#123;</span><br><span class="line">           permissionNames.add(permission.getPermission());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将权限名称提供给info</span></span><br><span class="line">       authorizationInfo.setStringPermissions(permissionNames);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 提供账户信息返回认证信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">       String username = (String) token.getPrincipal();</span><br><span class="line">       User user = userService.findByUsername(username);</span><br><span class="line">       <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 用户名不存在抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (user.getLocked() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 用户被管理员锁定抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> LockedAccountException();</span><br><span class="line">       &#125;</span><br><span class="line">       SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(user.getUsername(),</span><br><span class="line">               user.getPassword(), ByteSource.Util.bytes(user.getCredentialsSalt()), getName());</span><br><span class="line">       <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Shiro的设计思路，用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多。在数据库中需要因此建立5张表，分别是：</p><p>用户表（存储用户名，密码，盐等）</p><p>角色表（角色名称，相关描述等）</p><p>权限表（权限名称，相关描述等）</p><p>用户-角色对应中间表（以用户ID和角色ID作为联合主键）</p><p>角色-权限对应中间表（以角色ID和权限ID作为联合主键）</p><p>具体dao与service的实现本文不提供。总之结论就是，Shiro需要根据用户名和密码首先判断登录的用户是否合法，然后再对合法用户授权。而这个过程就是Realm的实现过程。</p><h2 id="6、会话"><a href="#6、会话" class="headerlink" title="6、会话"></a><strong>6、会话</strong></h2><p>用户的一次登录即为一次会话，Shiro也可以代替Tomcat等容器管理会话。目的是当用户停留在某个页面长时间无动作的时候，再次对任何链接的访问都会被重定向到登录页面要求重新输入用户名和密码而不需要程序员在Servlet中不停的判断Session中是否包含User对象。</p><p>启用Shiro会话管理的另一个用途是可以针对不同的模块采取不同的会话处理。以淘宝为例，用户注册淘宝以后可以选择记住用户名和密码。之后再次访问就无需登陆。但是如果你要访问支付宝或购物车等链接依然需要用户确认身份。当然，Shiro也可以创建使用容器提供的Session最为实现。</p><h1 id="三、与SpringMVC集成"><a href="#三、与SpringMVC集成" class="headerlink" title="三、与SpringMVC集成"></a><strong>三、与SpringMVC集成</strong></h1><p>有了注册模块和Realm模块的支持，下面就是如何与SpringMVC集成开发。有过框架集成经验的同学一定知道，所谓的集成基本都是一堆xml文件的配置，Shiro也不例外。</p><h2 id="1、配置前端过滤器"><a href="#1、配置前端过滤器" class="headerlink" title="1、配置前端过滤器"></a><strong>1、配置前端过滤器</strong></h2><p>先说一个题外话，Filter是过滤器，interceptor是拦截器。前者基于回调函数实现，必须依靠容器支持。因为需要容器装配好整条FilterChain并逐个调用。后者基于代理实现，属于AOP的范畴。</p><p>如果希望在WEB环境中使用Shiro必须首先在web.xml文件中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Shiro_Project<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.Log4jConfigListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 将Shiro的配置文件交给Spring监听器初始化 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring.xml,classpath:spring-shiro-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfigLoaction<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:log4j.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- shiro配置 开始 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- shiro配置 结束 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>熟悉Spring配置的同学可以重点看有绿字注释的部分，这里是使Shiro生效的关键。由于项目通过Spring管理，因此所有的配置原则上都是交给Spring。DelegatingFilterProxy的功能是通知Spring将所有的Filter交给ShiroFilter管理。</p><p>接着在classpath路径下配置spring-shiro-web.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">                       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">                       http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">                       http://www.springframework.org/schema/context/spring-context-3.1.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">                       http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">                       http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 缓存管理器 使用Ehcache实现 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.cache.ehcache.EhCacheManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerConfigFile"</span> <span class="attr">value</span>=<span class="string">"classpath:ehcache.xml"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 凭证匹配器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">class</span>=<span class="string">"utils.RetryLimitHashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashAlgorithmName"</span> <span class="attr">value</span>=<span class="string">"md5"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashIterations"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"storedCredentialsHexEncoded"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- Realm实现 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userRealm"</span> <span class="attr">class</span>=<span class="string">"utils.UserRealm"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">ref</span>=<span class="string">"credentialsMatcher"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"userRealm"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- Shiro的Web过滤器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">               /authc/admin = roles[admin]</span><br><span class="line">               /authc/** = authc</span><br><span class="line">               /** = anon</span><br><span class="line">           <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意filterChainDefinitions过滤器中对于路径的配置是有顺序的，当找到匹配的条目之后容器不会再继续寻找。因此带有通配符的路径要放在后面。三条配置的含义是：</p><p> /authc/admin需要用户有用admin权限</p><p>/authc/**用户必须登录才能访问</p><p>/**其他所有路径任何人都可以访问</p><p>说了这么多，大家一定关心在Spring中引入Shiro之后到底如何编写登录代码呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>&#123;</span><br><span class="line">       UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           subject.login(token);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">           <span class="comment">// 捕获密码错误异常</span></span><br><span class="line">           ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">           mv.addObject(<span class="string">"message"</span>, <span class="string">"password error!"</span>);</span><br><span class="line">           <span class="keyword">return</span> mv;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">           <span class="comment">// 捕获未知用户名异常</span></span><br><span class="line">           ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">           mv.addObject(<span class="string">"message"</span>, <span class="string">"username error!"</span>);</span><br><span class="line">           <span class="keyword">return</span> mv;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ExcessiveAttemptsException eae) &#123;</span><br><span class="line">           <span class="comment">// 捕获错误登录过多的异常</span></span><br><span class="line">           ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">           mv.addObject(<span class="string">"message"</span>, <span class="string">"times error"</span>);</span><br><span class="line">           <span class="keyword">return</span> mv;</span><br><span class="line">       &#125;</span><br><span class="line">       User user = userService.findByUsername(username);</span><br><span class="line">       subject.getSession().setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"success"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录完成以后，当前用户信息被保存进Session。这个Session是通过Shiro管理的会话对象，要获取依然必须通过Shiro。传统的Session中不存在User对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"authc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthcController</span> </span>&#123;</span><br><span class="line">   <span class="comment">// /authc/** = authc 任何通过表单登录的用户都可以访问</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"anyuser"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">anyuser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       User user = (User) subject.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">       System.out.println(user);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"inner"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// /authc/admin = user[admin] 只有具备admin角色的用户才可以访问，否则请求将被重定向至登录界面</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"admin"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">admin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Subject subject = SecurityUtils.getSubject();</span><br><span class="line">       User user = (User) subject.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">       System.out.println(user);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"inner"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本篇内容大多总结自张开涛的《跟我学Shiro》原文地址：</p><p><a href="http://jinnianshilongnian.iteye.com/blog/2018936" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/2018936</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文作者：冷豪；&lt;a href=&quot;www.cnblogs.com/learnhow/p/5694876.html&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、架构&quot;&gt;&lt;a href=&quot;#一、架构&quot; class=&quot;headerlink&quot; title=&quot;一、架构&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、架构&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;要学习如何使用Shiro必须先从它的架构谈起，作为一款安全框架Shiro的设计相当精妙。Shiro的应用不依赖任何容器，它也可以在JavaSE下使用。但是最常用的环境还是JavaEE。下面以用户登录为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640.webp&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.sjsmile.cn/tags/java/"/>
    
      <category term="shiro" scheme="http://www.sjsmile.cn/tags/shiro/"/>
    
      <category term="安全" scheme="http://www.sjsmile.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Kafka 和 ZooKeeper 的分布式消息队列</title>
    <link href="http://www.sjsmile.cn/2020/05/16/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Kafka-%E5%92%8C-ZooKeeper-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://www.sjsmile.cn/2020/05/16/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Kafka-%E5%92%8C-ZooKeeper-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2020-05-16T11:35:10.000Z</published>
    <updated>2020-05-16T11:48:46.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247491550&amp;idx=3&amp;sn=0d6aa438a6cc4ea208c84f1f0379b3b2&amp;chksm=e82bfecfdf5c77d9620dc76961be083c59d78ed95f95161f9ccc68e60340576776fc4f1295bb&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1589620106744&amp;sharer_shareid=40612a9bc90b8d55689c1d82b8ad1cd7&amp;key=4c5479cb7e07b2ac11eb878bf4bbe77475b5ddbee6605609ce3b505a9e2e871c999eebda374f3a655a6b5e103c88704ae7d5cc939580c8cad9181cbbbd53b95978296a1f1b100deda5c4487082d627b8&amp;ascene=1&amp;uin=MTc0MjQ2ODA2OQ%3D%3D&amp;devicetype=Windows+10+x64&amp;version=6209007b&amp;lang=zh_CN&amp;exportkey=ATBs42KokFLoegR4uWL%2BLkk%3D&amp;pass_ticket=2jrmEmmI%2FRKlJnUXJvlSHbMpD7YmNlp77%2FbnqdknS92wQ%2FpqE2jV1X8ub0m%2Bygwf" target="_blank" rel="noopener">原文地址</a></p></blockquote><h3 id="1-Kafka-总体架构"><a href="#1-Kafka-总体架构" class="headerlink" title="1. Kafka 总体架构"></a>1. Kafka 总体架构</h3><p>基于 Kafka-ZooKeeper 的分布式消息队列系统总体架构如下：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937051.png" alt="img" title="" class="">                <p>img</p>            </figure><a id="more"></a><p>如上图所示，一个典型的 Kafka 体系架构包括若干 Producer（消息生产者），若干 broker（作为 Kafka 节点的服务器），若干 Consumer（Group），以及一个 ZooKeeper 集群。Kafka通过 ZooKeeper 管理集群配置、选举 Leader 以及在 consumer group 发生变化时进行 Rebalance（即消费者负载均衡，在下一课介绍）。Producer 使用 push（推）模式将消息发布到 broker，Consumer 使用 pull（拉）模式从 broker 订阅并消费消息。</p><p>上图仅描摹了一个总体架构，并没有对作为 Kafka 节点的 broker 进行深入刻画，事实上，它的内部细节相当复杂，如下图所示，Kafka 节点涉及 Topic、Partition 两个重要概念。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937072.png" alt="img" title="" class="">                <p>img</p>            </figure><p>在 Kafka 架构中，有几个术语：</p><ul><li><strong>Producer</strong>：生产者，即消息发送者，push 消息到 Kafka 集群中的 broker（就是 server）中；</li><li><strong>Broker</strong>：Kafka 集群由多个 Kafka 实例（server） 组成，每个实例构成一个 broker，说白了就是服务器；</li><li><strong>Topic</strong>：producer 向 kafka 集群 push 的消息会被归于某一类别，即Topic，这本质上只是一个逻辑概念，面向的对象是 producer 和 consumer，producer 只需要关注将消息 push 到哪一个 Topic 中，而 consumer 只需要关心自己订阅了哪个 Topic；</li><li><strong>Partition</strong>：每一个 Topic 又被分为多个 Partitions，即物理分区；出于负载均衡的考虑，同一个 Topic 的 Partitions 分别存储于 Kafka 集群的多个 broker 上；而为了提高可靠性，这些 Partitions 可以由 Kafka 机制中的 replicas 来设置备份的数量；如上面的框架图所示，每个 partition 都存在两个备份；</li><li><strong>Consumer</strong>：消费者，从 Kafka 集群的 broker 中 pull 消息、消费消息；</li><li><strong>Consumer group</strong>：high-level consumer API 中，每个 consumer 都属于一个 consumer-group，每条消息只能被 consumer-group 中的一个 Consumer 消费，但可以被多个 consumer-group 消费；</li><li><strong>replicas</strong>：partition 的副本，保障 partition 的高可用；</li><li><strong>leader</strong>：replicas 中的一个角色， producer 和 consumer 只跟 leader 交互；</li><li><strong>follower</strong>：replicas 中的一个角色，从 leader 中复制数据，作为副本，一旦 leader 挂掉，会从它的 followers 中选举出一个新的 leader 继续提供服务；</li><li><strong>controller</strong>：Kafka 集群中的其中一个服务器，用来进行 leader election 以及 各种 failover；</li><li><strong>ZooKeeper</strong>：Kafka 通过 ZooKeeper 来存储集群的 meta 信息等，文中将详述。</li></ul><h4 id="1-1-Topic-amp-Partition"><a href="#1-1-Topic-amp-Partition" class="headerlink" title="1.1 Topic &amp; Partition"></a>1.1 Topic &amp; Partition</h4><p>一个 topic 可以认为是一类消息，每个 topic 将被分成多个 partition，每个 partition 在存储层面是 append log 文件。任何发布到此 partition 的消息都会被追加到log文件的尾部，每条消息在文件中的位置称为 offset（偏移量），offset 为一个 long 型的数字，它唯一标记一条消息。Kafka 机制中，producer push 来的消息是追加（append）到 partition 中的，这是一种顺序写磁盘的机制，效率远高于随机写内存，如下示意图：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937084.png" alt="img" title="" class="">                <p>img</p>            </figure><h4 id="1-2-Kafka-为什么要将-Topic-进行分区？"><a href="#1-2-Kafka-为什么要将-Topic-进行分区？" class="headerlink" title="1.2 Kafka 为什么要将 Topic 进行分区？"></a>1.2 Kafka 为什么要将 Topic 进行分区？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简而言之：负载均衡 + 水平扩展。</span><br></pre></td></tr></table></figure><p>前已述及，Topic 只是逻辑概念，面向的是 producer 和 consumer；而 Partition 则是物理概念。可以想象，如果 Topic 不进行分区，而将 Topic 内的消息存储于一个 broker，那么关于该 Topic 的所有读写请求都将由这一个 broker 处理，吞吐量很容易陷入瓶颈，这显然是不符合高吞吐量应用场景的。有了 Partition 概念以后，假设一个 Topic 被分为 10 个 Partitions，Kafka 会根据一定的算法将 10 个 Partition 尽可能均匀的分布到不同的 broker（服务器）上，当 producer 发布消息时，producer 客户端可以采用 <code>random</code>、<code>key-hash</code> 及 <code>轮询</code> 等算法选定目标 partition，若不指定，Kafka 也将根据一定算法将其置于某一分区上。Partiton 机制可以极大的提高吞吐量，并且使得系统具备良好的水平扩展能力。</p><p>在创建 topic 时可以在 <code>$KAFKA_HOME/config/server.properties</code> 中指定这个 partition 的数量（如下所示），当然可以在 topic 创建之后去修改 partition 的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># The default number of log partitions per topic. More partitions allow greater# parallelism for consumption, but this will also result in more files across# the brokers.num.partitions=3</span><br></pre></td></tr></table></figure><p>在发送一条消息时，可以指定这个消息的 key，producer 根据这个 key 和 partition 机制来判断这个消息发送到哪个partition。partition 机制可以通过指定 producer 的 partition.class 这一参数来指定（即支持自定义），该 class 必须实现 kafka.producer.Partitioner 接口。</p><p>有关 topic 与 partition 的更多细节，可以参考下面的“Kafka 文件存储机制”这一节。</p><h3 id="2-Kafka-高可靠性实现基础解读"><a href="#2-Kafka-高可靠性实现基础解读" class="headerlink" title="2. Kafka 高可靠性实现基础解读"></a>2. Kafka 高可靠性实现基础解读</h3><p>谈及可靠性，最常规、最有效的策略就是 “副本（replication）机制” ，Kafka 实现高可靠性同样采用了该策略。通过调节副本相关参数，可使 Kafka 在性能和可靠性之间取得平衡。本节先从 Kafka 文件存储机制入手，从最底层了解 Kafka 的存储细节，进而对消息的存储有个微观的认知。之后通过介绍 Kafka 的复制原理和同步方式来阐述宏观层面的概念。最后介绍 ISR，HW 和 leader 选举。</p><h4 id="2-1-Kafka-文件存储机制"><a href="#2-1-Kafka-文件存储机制" class="headerlink" title="2.1 Kafka 文件存储机制"></a>2.1 Kafka 文件存储机制</h4><p>Kafka 中消息是以 topic 进行分类的，生产者通过 topic 向 Kafka broker 发送消息，消费者通过 topic 读取数据。然而 topic 在物理层面又能以 partition 为分组，一个 topic 可以分成若干个 partition。事实上，partition 并不是最终的存储粒度，partition 还可以细分为 segment，一个 partition 物理上由多个 segment 组成，那么这些 segment 又是什么呢？</p><p>为了便于说明问题，假设这里只有一个 Kafka 集群，且这个集群只有一个 Kafka broker，即只有一台物理机。在这个 Kafka broker 中配置 <code>log.dirs=/tmp/kafka-logs</code>，以此来设置 Kafka 消息文件存储目录；与此同时，通过命令创建一个 topic：mytopic_test，partition 的数量配置为 4（创建 topic 的命令请见上一课）。之后，可以在 <code>/tmp/kafka-logs</code> 目录中可以看到生成了 4 个目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-0</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-1</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-2</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-3</span><br></pre></td></tr></table></figure><p>在 Kafka 文件存储中，同一个 topic 下有多个不同的 partition，每个 partiton 为一个目录，partition 的名称规则为：topic 名称 + 有序序号，第一个序号从 0 开始计，最大的序号为 partition 数量减 1，partition 是实际物理上的概念，而 topic 是逻辑上的概念。</p><p><strong>问题 1：为什么不能以 partition 作为存储单位？</strong></p><p>上面提到 partition 还可以细分为 segment，这个 segment 又是什么？如果就以 partition 为最小存储单位，可以想象，当 Kafka producer 不断发送消息，必然会引起 partition 文件的无限扩张，将对消息文件的维护以及已消费的消息的清理带来严重的影响，因此，需以 segment 为单位将 partition 进一步细分。每个 partition（目录）相当于一个巨型文件被平均分配到多个大小相等的 segment（段）数据文件中（每个 segment 文件中消息数量不一定相等）这种特性也方便 old segment 的删除，即方便已被消费的消息的清理，提高磁盘的利用率。每个 partition 只需要支持顺序读写就行，segment 的文件生命周期由服务端配置参数（log.segment.bytes，log.roll.{ms,hours} 等若干参数）决定。</p><p><strong>问题 2：segment 的工作原理是怎样的？</strong></p><p>segment 文件由两部分组成，分别为 “.index” 文件和 “.log” 文件，分别表示为 segment 索引文件和数据文件。这两个文件的命令规则为：partition 全局的第一个 segment 从 0 开始，后续每个 segment 文件名为上一个 segment 文件最后一条消息的 offset 值，数值大小为 64 位，20 位数字字符长度，没有数字用 0 填充，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000.index</span><br><span class="line">00000000000000000000.log</span><br><span class="line">00000000000000170410.index</span><br><span class="line">00000000000000170410.log</span><br><span class="line">00000000000000239430.index</span><br><span class="line">00000000000000239430.log</span><br></pre></td></tr></table></figure><p>以上面的 segment 文件为例，展示出 segment：00000000000000170410 的 “.index” 文件和 “.log” 文件的对应的关系，如下图：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937106.png" alt="img" title="" class="">                <p>img</p>            </figure><p>如上图，“.index” 索引文件存储大量的元数据，“.log” 数据文件存储大量的消息，索引文件中的元数据指向对应数据文件中 message 的物理偏移地址。其中以 “.index” 索引文件中的元数据 [3, 348] 为例，在 “.log” 数据文件表示第 3 个消息，即在全局 partition 中表示 170410+3=170413 个消息，该消息的物理偏移地址为 348。</p><p><strong>问题 3：如何从 partition 中通过 offset 查找 message 呢？</strong></p><p>以上图为例，读取 offset=170418 的消息，首先查找 segment 文件，其中 00000000000000000000.index 为最开始的文件，第二个文件为 00000000000000170410.index（起始偏移为 170410+1=170411），而第三个文件为 00000000000000239430.index（起始偏移为 239430+1=239431），所以这个 offset=170418 就落到了第二个文件之中。其它后续文件可以依次类推，以其偏移量命名并排列这些文件，然后根据二分查找法就可以快速定位到具体文件位置。其次根据 00000000000000170410.index 文件中的 [8,1325] 定位到 00000000000000170410.log 文件中的 1325 的位置进行读取。</p><p>要是读取 offset=170418 的消息，从 00000000000000170410.log 文件中的 1325 的位置进行读取，那么，如何确定何时读完本条消息呢？（否则就读到下一条消息的内容了）</p><p>这个问题由消息的物理结构解决，消息都具有固定的物理结构，包括：offset（8 Bytes）、消息体的大小（4 Bytes）、crc32（4 Bytes）、magic（1 Byte）、attributes（1 Byte）、key length（4 Bytes）、key（K Bytes）、payload（N Bytes）等等字段，可以确定一条消息的大小，即读取到哪里截止。</p><h4 id="2-2-复制原理和同步方式"><a href="#2-2-复制原理和同步方式" class="headerlink" title="2.2 复制原理和同步方式"></a>2.2 复制原理和同步方式</h4><p>Kafka 中 topic 的每个 partition 有一个预写式的日志文件，虽然 partition 可以继续细分为若干个 segment 文件，但是对于上层应用来说，仍然可以将 partition 看成最小的存储单元（一个有多个 segment 文件拼接的 “巨型” 文件），每个 partition 都由一些列有序的、不可变的消息组成，这些消息被连续的追加到 partition 中。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937116.png" alt="img" title="" class="">                <p>img</p>            </figure><p>上图中有两个新名词：HW 和 LEO。这里先介绍下 LEO，LogEndOffset 的缩写，表示每个 partition 的 log 最后一条 Message 的位置。HW 是 HighWatermark 的缩写，是指 consumer 能够看到的此 partition 的位置，这个涉及到多副本的概念，这里先提及一下，下文再详述。</p><p>言归正传，为了提高消息的可靠性，Kafka 每个 topic 的 partition 有 N 个副本（replicas），其中 N（大于等于 1）是 topic 的复制因子（replica fator）的个数。Kafka 通过多副本机制实现故障自动转移，当 Kafka 集群中出现 broker 失效时，副本机制可保证服务可用。对于任何一个 partition，它的 N 个 replicas 中，其中一个 replica 为 leader，其他都为 follower，leader 负责处理 partition 的所有读写请求，follower 则负责被动地去复制 leader 上的数据。如下图所示，Kafka 集群中有 4 个 broker，某 topic 有 3 个 partition，且复制因子即副本个数也为 3：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937131.png" alt="img" title="" class="">                <p>img</p>            </figure><p>如果 leader 所在的 broker 发生故障或宕机，对应 partition 将因无 leader 而不能处理客户端请求，这时副本的作用就体现出来了：一个新 leader 将从 follower 中被选举出来并继续处理客户端的请求。</p><p><strong>如何确保新选举出的 leader 是优选呢？</strong></p><p>一个 partition 有多个副本（replicas），为了提高可靠性，这些副本分散在不同的 broker 上，由于带宽、读写性能、网络延迟等因素，同一时刻，这些副本的状态通常是不一致的：即 followers 与 leader 的状态不一致。那么，如何保证新选举出的 leader 是优选呢？Kafka 机制中，leader 将负责维护和跟踪一个 ISR（In-Sync Replicas）列表，即同步副本队列，这个列表里面的副本与 leader 保持同步，状态一致。如果新的 leader 从 ISR 列表中的副本中选出，那么就可以保证新 leader 为优选。当然，这不是唯一的策略，下文将继续解读。</p><h4 id="2-3-同步副本-ISR"><a href="#2-3-同步副本-ISR" class="headerlink" title="2.3 同步副本 ISR"></a>2.3 同步副本 ISR</h4><p>上一节中讲到了同步副本队列 ISR（In-Sync Replicas）。虽然副本极大的增强了可用性，但是副本数量对 Kafka 的吞吐率有一定影响。默认情况下 Kafka 的 replica 数量为 1，即每个 partition 都只有唯一的 leader，无 follower，没有容灾能力。为了确保消息的可靠性，生产环境中，通常将其值（由 broker 的参数 offsets.topic.replication.factor 指定）大小设置为大于 1，比如 3。所有的副本（replicas）统称为 Assigned Replicas，即 AR。ISR 是 AR 中的一个子集，由 leader 维护 ISR 列表，follower 从 leader 同步数据有一些延迟（由参数 replica.lag.time.max.ms 设置超时阈值），超过阈值的 follower 将被剔除出 ISR， 存入 OSR（Outof-Sync Replicas）列表，新加入的 follower 也会先存放在 OSR 中。AR=ISR+OSR。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：ISR中包括：leader + 与leader保持同步的followers。</span><br></pre></td></tr></table></figure><p>上面一节还涉及到一个概念，即 HW。HW 俗称高水位，HighWatermark 的缩写，取一个 partition 对应的 ISR 中最小的 LEO 作为 HW，consumer 最多只能消费到 HW 所在的位置。另外每个 replica 都有 HW，leader 和 follower 各自负责更新自己的 HW 的状态。对于 leader 新写入的消息，consumer 不能立刻消费，leader 会等待该消息被所有 ISR 中的 replicas 同步后更新 HW，此时消息才能被 consumer 消费。这样就保证了如果 leader 所在的 broker 失效，该消息仍然可以从新选举的 leader 中获取。对于来自内部 broker 的读取请求，没有 HW 的限制。</p><p>下图详细的说明了当 producer 生产消息至 broker 后，ISR 以及 HW 和 LEO 的流转过程：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937149.png" alt="img" title="" class="">                <p>img</p>            </figure><p>由此可见，Kafka 的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的 follower 都复制完，这条消息才会被 commit，这种复制方式受限于复制最慢的 follower，会极大的影响吞吐率。而异步复制方式下，follower 异步的从 leader 复制数据，数据只要被 leader 写入 log 就被认为已经 commit，这种情况下如果 follower 都还没有复制完，落后于 leader 时，突然 leader 宕机，则会丢失数据，降低可靠性。而 Kafka 使用 ISR 的策略则在可靠性和吞吐率方面取得了较好的平衡。</p><p>Kafka 的 ISR 的管理最终都会反馈到 ZooKeeper 节点上，具体位置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/brokers/topics/[topic]/partitions/[partition]/state</span><br></pre></td></tr></table></figure><p>目前，有两个地方会对这个 ZooKeeper 的节点进行维护。</p><ol><li>Controller 来维护：Kafka 集群中的其中一个 Broker 会被选举为 Controller，主要负责 Partition 管理和副本状态管理，也会执行类似于重分配 partition 之类的管理任务。在符合某些特定条件下，Controller 下的 LeaderSelector 会选举新的 leader，ISR 和新的 <code>leader_epoch</code> 及 <code>controller_epoch</code> 写入 ZooKeeper 的相关节点中。同时发起 LeaderAndIsrRequest 通知所有的 replicas。</li><li>leader 来维护：leader 有单独的线程定期检测 ISR 中 follower 是否脱离 ISR，如果发现 ISR 变化，则会将新的 ISR 的信息返回到 ZooKeeper 的相关节点中。</li></ol><h4 id="2-4-数据可靠性和持久性保证"><a href="#2-4-数据可靠性和持久性保证" class="headerlink" title="2.4 数据可靠性和持久性保证"></a>2.4 数据可靠性和持久性保证</h4><p>当 producer 向 leader 发送数据时，可以通过 request.required.acks 参数来设置数据可靠性的级别：</p><p><strong>1. request.required.acks = 1</strong></p><p>这是默认情况，即：producer 发送数据到 leader，leader 写本地日志成功，返回客户端成功；此时 ISR 中的其它副本还没有来得及拉取该消息，如果此时 leader 宕机了，那么此次发送的消息就会丢失。</p><p><strong>2. request.required.acks = 0</strong></p><p>producer 不停向leader发送数据，而不需要 leader 反馈成功消息，这种情况下数据传输效率最高，但是数据可靠性确是最低的。可能在发送过程中丢失数据，可能在 leader 宕机时丢失数据。</p><p><strong>3. request.required.acks = -1（all）</strong></p><p>producer 发送数据给 leader，leader 收到数据后要等到 ISR 列表中的所有副本都同步数据完成后（强一致性），才向生产者返回成功消息，如果一直收不到成功消息，则认为发送数据失败会自动重发数据。这是可靠性最高的方案，当然，性能也会受到一定影响。</p><p><strong>注意：参数 min.insync.replicas</strong></p><p>如果要提高数据的可靠性，在设置 request.required.acks=-1 的同时，还需参数 min.insync.replicas 配合，如此才能发挥最大的功效。min.insync.replicas 这个参数用于设定 ISR 中的最小副本数，默认值为1，当且仅当 request.required.acks 参数设置为-1时，此参数才生效。当 ISR 中的副本数少于 min.insync.replicas 配置的数量时，客户端会返回异常：<code>org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required</code>。不难理解，如果 min.insync.replicas 设置为 2，当 ISR 中实际副本数为 1 时（只有leader），将无法保证可靠性，此时拒绝客户端的写请求以防止消息丢失。</p><h4 id="2-5-深入解读-HW-机制"><a href="#2-5-深入解读-HW-机制" class="headerlink" title="2.5 深入解读 HW 机制"></a>2.5 深入解读 HW 机制</h4><p>考虑这样一种场景：acks=-1，部分 ISR 副本完成同步，此时leader挂掉，如下图所示：follower1 同步了消息 4、5，follower2 同步了消息 4，与此同时 follower2 被选举为 leader，那么此时 follower1 中的多出的消息 5 该做如何处理呢？</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937156.png" alt="img" title="" class="">                <p>img</p>            </figure><p>这里就需要 HW 的协同配合了。如前所述，一个 partition 中的 ISR 列表中，leader 的 HW 是所有 ISR 列表里副本中最小的那个的 LEO。类似于木桶原理，水位取决于最低那块短板。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937175.png" alt="img" title="" class="">                <p>img</p>            </figure><p>如上图，某个 topic 的某 partition 有三个副本，分别为 A、B、C。A 作为 leader 肯定是 LEO 最高，B 紧随其后，C 机器由于配置比较低，网络比较差，故而同步最慢。这个时候 A 机器宕机，这时候如果 B 成为 leader，假如没有 HW，在 A 重新恢复之后会做同步（makeFollower) 操作，在宕机时 log 文件之后直接做追加操作，而假如 B 的 LEO 已经达到了 A 的 LEO，会产生数据不一致的情况，所以使用 HW 来避免这种情况。A 在做同步操作的时候，先将 log 文件截断到之前自己的 HW 的位置，即 3，之后再从 B 中拉取消息进行同步。</p><p>如果失败的 follower 恢复过来，它首先将自己的 log 文件截断到上次 checkpointed 时刻的 HW 的位置，之后再从 leader 中同步消息。leader 挂掉会重新选举，新的 leader 会发送 “指令” 让其余的 follower 截断至自身的 HW 的位置然后再拉取新的消息。</p><p>当 ISR 中的个副本的 LEO 不一致时，如果此时 leader 挂掉，选举新的 leader 时并不是按照 LEO 的高低进行选举，而是按照 ISR 中的顺序选举。</p><h4 id="2-6-Leader-选举"><a href="#2-6-Leader-选举" class="headerlink" title="2.6 Leader 选举"></a>2.6 Leader 选举</h4><p>为了保证可靠性，对于任意一条消息，只有它被 ISR 中的所有 follower 都从 leader 复制过去才会被认为已提交，并返回信息给 producer。如此，可以避免因部分数据被写进 leader，而尚未被任何 follower 复制就宕机的情况下而造成数据丢失。对于 producer 而言，它可以选择是否等待消息 commit，这可以通过参数 request.required.acks 来设置。这种机制可以确保：只要 ISR 中有一个或者以上的 follower，一条被 commit 的消息就不会丢失。</p><p><strong>问题 1：如何在保证可靠性的前提下避免吞吐量下降？</strong></p><p>有一个很重要的问题是当 leader 宕机了，怎样在 follower 中选举出新的 leader，因为 follower 可能落后很多或者直接 crash 了，所以必须确保选择 “最新” 的 follower 作为新的 leader。一个基本的原则就是，如果 leader 挂掉，新的 leader 必须拥有原来的 leader 已经 commit 的所有消息，这不就是 ISR 中副本的特征吗？</p><p>但是，存在一个问题，ISR 列表维持多大的规模合适呢？换言之，leader 在一个消息被 commit 前需要等待多少个 follower 确认呢？等待 follower 的数量越多，与 leader 保持同步的 follower 就越多，可靠性就越高，但这也会造成吞吐率的下降。</p><p><strong>少数服从多数的选举原则</strong></p><p>一种常用的选举 leader 的策略是 “少数服从多数” ，不过，Kafka 并不是采用这种方式。这种模式下，如果有 2f+1 个副本，那么在 commit 之前必须保证有 f+1 个 replica 复制完消息，同时为了保证能正确选举出新的 leader，失败的副本数不能超过 f 个。这种方式有个很大的优势，系统的延迟取决于最快的几台机器，也就是说比如副本数为 3，那么延迟就取决于最快的那个 follower 而不是最慢的那个。</p><p>“少数服从多数” 的策略也有一些劣势，为了保证 leader 选举的正常进行，它所能容忍的失败的 follower 数比较少，如果要容忍 1 个 follower 挂掉，那么至少要 3 个以上的副本，如果要容忍 2 个 follower 挂掉，必须要有 5 个以上的副本。也就是说，在生产环境下为了保证较高的容错率，必须要有大量的副本，而大量的副本又会在大数据量下导致性能的急剧下降。这种算法更多用在 ZooKeeper 这种共享集群配置的系统中，而很少在需要大量数据的系统中使用。</p><p><strong>Kafka 选举 leader 的策略是怎样的？</strong></p><p>实际上，leader 选举的算法非常多，比如 ZooKeeper 的 Zab、Raft 以及 Viewstamped Replication。而 Kafka 所使用的 leader 选举算法更像是微软的 PacificA 算法。</p><p>Kafka 在 ZooKeeper 中为每一个 partition 动态的维护了一个 ISR，这个 ISR 里的所有 replica 都与 leader 保持同步，只有 ISR 里的成员才能有被选为 leader 的可能（通过参数配置：<code>unclean.leader.election.enable=false</code>）。在这种模式下，对于 f+1 个副本，一个 Kafka topic 能在保证不丢失已经 commit 消息的前提下容忍 f 个副本的失败，在大多数使用场景下，这种模式是十分有利的。事实上，对于任意一条消息，只有它被 ISR 中的所有 follower 都从 leader 复制过去才会被认为已提交，并返回信息给 producer，从而保证可靠性。但与 “少数服从多数” 策略不同的是，Kafka ISR 列表中副本的数量不需要超过副本总数的一半，即不需要满足 “多数派” 原则，通常，ISR 列表副本数大于等于 2 即可，如此，便在可靠性和吞吐量方面取得平衡。</p><p><strong>极端情况下的 leader 选举策略</strong></p><p>前已述及，当 ISR 中至少有一个 follower 时（ISR 包括 leader），Kafka 可以确保已经 commit 的消息不丢失，但如果某一个 partition 的所有 replica 都挂了，自然就无法保证数据不丢失了。这种情况下如何进行 leader 选举呢？通常有两种方案：</p><ol><li>等待 ISR 中任意一个 replica 恢复过来，并且选它作为 leader；</li><li>选择第一个恢复过来的 replica（并不一定是在 ISR 中）作为leader。</li></ol><p>如何选择呢？这就需要在可用性和一致性当中作出抉择。如果一定要等待 ISR 中的 replica 恢复过来，不可用的时间就可能会相对较长。而且如果 ISR 中所有的 replica 都无法恢复了，或者数据丢失了，这个 partition 将永远不可用。</p><p>选择第一个恢复过来的 replica 作为 leader，如果这个 replica 不是 ISR 中的 replica，那么，它可能并不具备所有已经 commit 的消息，从而造成消息丢失。默认情况下，Kafka 采用第二种策略，即 <code>unclean.leader.election.enable=true</code>，也可以将此参数设置为 false 来启用第一种策略。</p><p><code>unclean.leader.election.enable</code> 这个参数对于 leader 的选举、系统的可用性以及数据的可靠性都有至关重要的影响。生产环境中应慎重权衡。</p><h3 id="3-Kafka-架构中-ZooKeeper-以怎样的形式存在？"><a href="#3-Kafka-架构中-ZooKeeper-以怎样的形式存在？" class="headerlink" title="3. Kafka 架构中 ZooKeeper 以怎样的形式存在？"></a>3. Kafka 架构中 ZooKeeper 以怎样的形式存在？</h3><p>ZooKeeper 是一个分布式的、开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现。分布式应用程序可以基于它实现统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。在基于 Kafka 的分布式消息队列中，ZooKeeper 的作用有：broker 注册、topic 注册、producer 和 consumer 负载均衡、维护 partition 与 consumer 的关系、记录消息消费的进度以及 consumer 注册等。</p><h4 id="3-1-broker-在-ZooKeeper-中的注册"><a href="#3-1-broker-在-ZooKeeper-中的注册" class="headerlink" title="3.1 broker 在 ZooKeeper 中的注册"></a>3.1 broker 在 ZooKeeper 中的注册</h4><ul><li>为了记录 broker 的注册信息，在 ZooKeeper 上，专门创建了属于 Kafka 的一个节点，其路径为 /brokers；</li><li>Kafka 的每个 broker 启动时，都会到 ZooKeeper 中进行注册，告诉 ZooKeeper 其 broker.id，在整个集群中，broker.id 应该全局唯一，并在 ZooKeeper 上创建其属于自己的节点，其节点路径为 <code>/brokers/ids/{broker.id}</code>；</li><li>创建完节点后，Kafka 会将该 broker 的 broker.name 及端口号记录到该节点；</li><li>另外，该 broker 节点属性为临时节点，当 broker 会话失效时，ZooKeeper 会删除该节点，这样，我们就可以很方便的监控到broker 节点的变化，及时调整负载均衡等。</li></ul><h4 id="3-2-Topic-在-ZooKeeper-中的注册"><a href="#3-2-Topic-在-ZooKeeper-中的注册" class="headerlink" title="3.2 Topic 在 ZooKeeper 中的注册"></a>3.2 Topic 在 ZooKeeper 中的注册</h4><p>在 Kafka 中，所有 topic 与 broker 的对应关系都由 ZooKeeper 进行维护，在 ZooKeeper 中，建立专门的节点来记录这些信息，其节点路径为 <code>/brokers/topics/{topic_name}</code>。前面说过，为了保障数据的可靠性，每个 Topic 的 Partitions 实际上是存在备份的，并且备份的数量由 Kafka 机制中的 replicas 来控制。那么问题来了：如下图所示，假设某个 TopicA 被分为 2 个 Partitions，并且存在两个备份，由于这 2 个 Partitions（1-2）被分布在不同的 broker 上，同一个 partiton 与其备份不能（也不应该）存储于同一个 broker 上。以 Partition1 为例，假设它被存储于 broker2，其对应的备份分别存储于 broker1 和 broker4，有了备份，可靠性得到保障，但数据一致性却是个问题。</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937185.png" alt="img" title="" class="">                <p>img</p>            </figure><p>为了保障数据的一致性，ZooKeeper 机制得以引入。基于 ZooKeeper，Kafka 为每一个 partition 找一个节点作为 leader，其余备份作为 follower；接续上图的例子，就 TopicA 的 partition1 而言，如果位于 broker2（Kafka 节点）上的 partition1 为 leader，那么位于 broker1 和 broker4 上面的 partition1 就充当 follower，则有下图：</p><figure class="image-box">                <img src="https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937191.png" alt="img" title="" class="">                <p>img</p>            </figure><p>基于上图的架构，当 producer push 的消息写入 partition（分区) 时，作为 leader 的 broker（Kafka 节点） 会将消息写入自己的分区，同时还会将此消息复制到各个 follower，实现同步。如果，某个follower 挂掉，leader 会再找一个替代并同步消息；如果 leader 挂了，follower 们会选举出一个新的 leader 替代，继续业务，这些都是由 ZooKeeper 完成的。</p><h4 id="3-3-consumer-在-ZooKeeper-中的注册"><a href="#3-3-consumer-在-ZooKeeper-中的注册" class="headerlink" title="3.3 consumer 在 ZooKeeper 中的注册"></a>3.3 consumer 在 ZooKeeper 中的注册</h4><p><strong>注册新的消费者分组</strong></p><p>当新的消费者组注册到 ZooKeeper 中时，ZooKeeper 会创建专用的节点来保存相关信息，其节点路径为 <code>ls/consumers/{group_id}</code>，其节点下有三个子节点，分别为 <code>[ids, owners, offsets]</code>。</p><ul><li>ids 节点：记录该消费组中当前正在消费的消费者；</li><li>owners 节点：记录该消费组消费的 topic 信息；</li><li>offsets 节点：记录每个 topic 的每个分区的 offset。</li></ul><p><strong>注册新的消费者</strong></p><p>当新的消费者注册到 Kafka 中时，会在 <code>/consumers/{group_id}/ids</code> 节点下创建临时子节点，并记录相关信息。</p><p><strong>监听消费者分组中消费者的变化</strong></p><p>每个消费者都要关注其所属消费者组中消费者数目的变化，即监听 <code>/consumers/{group_id}/ids</code> 下子节点的变化。一单发现消费者新增或减少，就会触发消费者的负载均衡。</p><h4 id="3-4-Producers-负载均衡"><a href="#3-4-Producers-负载均衡" class="headerlink" title="3.4 Producers 负载均衡"></a>3.4 Producers 负载均衡</h4><p>对于同一个 topic 的不同 partition，Kafka会尽力将这些 partition 分布到不同的 broker 服务器上，这种均衡策略实际上是基于 ZooKeeper 实现的。在一个 broker 启动时，会首先完成 broker 的注册过程，并注册一些诸如 “有哪些可订阅的 topic” 之类的元数据信息。producers 启动后也要到 ZooKeeper 下注册，创建一个临时节点来监听 broker 服务器列表的变化。由于在 ZooKeeper 下 broker 创建的也是临时节点，当 brokers 发生变化时，producers 可以得到相关的通知，从改变自己的 broker list。其它的诸如 topic 的变化以及broker 和 topic 的关系变化，也是通过 ZooKeeper 的这种 Watcher 监听实现的。</p><p>在生产中，必须指定 topic；但是对于 partition，有两种指定方式：</p><ul><li>明确指定 partition(0-N)，则数据被发送到指定 partition；</li><li>设置为 <code>RD_KAFKA_PARTITION_UA</code>，则 Kafka 会回调 partitioner 进行均衡选取，partitioner 方法需要自己实现。可以轮询或者传入 key 进行 hash。未实现则采用默认的随机方法 <code>rd_kafka_msg_partitioner_random</code> 随机选择。</li></ul><h4 id="3-5-Consumer-负载均衡"><a href="#3-5-Consumer-负载均衡" class="headerlink" title="3.5 Consumer 负载均衡"></a>3.5 Consumer 负载均衡</h4><p>Kafka 保证同一 consumer group 中只有一个 consumer 可消费某条消息，实际上，Kafka 保证的是稳定状态下每一个 consumer 实例只会消费某一个或多个特定的数据，而某个 partition 的数据只会被某一个特定的 consumer 实例所消费。这样设计的劣势是无法让同一个 consumer group 里的 consumer 均匀消费数据，优势是每个 consumer 不用都跟大量的 broker 通信，减少通信开销，同时也降低了分配难度，实现也更简单。另外，因为同一个 partition 里的数据是有序的，这种设计可以保证每个 partition 里的数据也是有序被消费。</p><p><strong>consumer 数量不等于 partition 数量</strong></p><p>如果某 consumer group 中 consumer 数量少于 partition 数量，则至少有一个 consumer 会消费多个 partition 的数据；如果 consumer 的数量与 partition 数量相同，则正好一个 consumer 消费一个 partition 的数据，而如果 consumer 的数量多于 partition 的数量时，会有部分 consumer 无法消费该 topic 下任何一条消息。</p><p><strong>借助 ZooKeeper 实现负载均衡</strong></p><p>关于负载均衡，对于某些低级别的 API，consumer 消费时必须指定 topic 和 partition，这显然不是一种友好的均衡策略。基于高级别的 API，consumer 消费时只需制定 topic，借助 ZooKeeper 可以根据 partition 的数量和 consumer 的数量做到均衡的动态配置。</p><p>consumers 在启动时会到 ZooKeeper 下以自己的 conusmer-id 创建临时节点 <code>/consumer/[group-id]/ids/[conusmer-id]</code>，并对 <code>/consumer/[group-id]/ids</code> 注册监听事件，当消费者发生变化时，同一 group 的其余消费者会得到通知。当然，消费者还要监听 broker 列表的变化。librdkafka 通常会将 partition 进行排序后，根据消费者列表，进行轮流的分配。</p><h4 id="3-6-记录消费进度-Offset"><a href="#3-6-记录消费进度-Offset" class="headerlink" title="3.6 记录消费进度 Offset"></a>3.6 记录消费进度 Offset</h4><p>在 consumer 对指定消息 partition 的消息进行消费的过程中，需要定时地将 partition 消息的消费进度 Offset 记录到 ZooKeeper上，以便在该 consumer 进行重启或者其它 consumer 重新接管该消息分区的消息消费权后，能够从之前的进度开始继续进行消息消费。Offset 在 ZooKeeper 中由一个专门节点进行记录，其节点路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#节点内容就是Offset的值。/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</span><br></pre></td></tr></table></figure><p>PS：Kafka 已推荐将 consumer 的 Offset 信息保存在 Kafka 内部的 topic 中，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__consumer_offsets(/brokers/topics/__consumer_offsets)</span><br></pre></td></tr></table></figure><p>并且默认提供了 <code>kafka_consumer_groups.sh</code> 脚本供用户查看consumer 信息（命令：<code>sh kafka-consumer-groups.sh –bootstrap-server * –describe –group *</code>）。在当前版本中，offset 存储方式要么存储在本地文件中，要么存储在 broker 端，具体的存储方式取决 <code>offset.store.method</code> 的配置，默认是存储在 broker 端。</p><h4 id="3-7-记录-Partition-与-Consumer-的关系"><a href="#3-7-记录-Partition-与-Consumer-的关系" class="headerlink" title="3.7 记录 Partition 与 Consumer 的关系"></a>3.7 记录 Partition 与 Consumer 的关系</h4><p>consumer group 下有多个 consumer（消费者），对于每个消费者组（consumer group），Kafka都会为其分配一个全局唯一的 group ID，group 内部的所有消费者共享该 ID。订阅的 topic 下的每个分区只能分配给某个 group 下的一个consumer（当然该分区还可以被分配给其它 group）。同时，Kafka 为每个消费者分配一个 consumer ID，通常采用 <code>hostname:UUID</code> 形式表示。</p><p>在Kafka中，规定了每个 partition 只能被同组的一个消费者进行消费，因此，需要在 ZooKeeper 上记录下 partition 与 consumer 之间的关系，每个 consumer 一旦确定了对一个 partition 的消费权力，需要将其 consumer ID 写入到 ZooKeeper 对应消息分区的临时节点上，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]</span><br></pre></td></tr></table></figure><p>其中，[<code>broker_id-partition_id</code>] 就是一个消息分区的标识，节点内容就是该消息分区 消费者的 consumer ID。</p><h3 id="4-全程解析（Producer-kafka-consumer）"><a href="#4-全程解析（Producer-kafka-consumer）" class="headerlink" title="4. 全程解析（Producer-kafka-consumer）"></a>4. 全程解析（Producer-kafka-consumer）</h3><h4 id="4-1-producer-发布消息"><a href="#4-1-producer-发布消息" class="headerlink" title="4.1 producer 发布消息"></a>4.1 producer 发布消息</h4><p>producer 采用 push 模式将消息发布到 broker，每条消息都被 append 到 patition 中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障 kafka 吞吐率）。producer 发送消息到 broker 时，会根据分区算法选择将其存储到哪一个 partition。</p><p><strong>其路由机制为：</strong></p><ol><li>指定了 patition，则直接使用；</li><li>未指定 patition 但指定 key，通过对 key 进行 hash 选出一个 patition；</li><li>patition 和 key 都未指定，使用轮询选出一个 patition。</li></ol><p><strong>写入流程：</strong></p><ol><li>producer 先从 ZooKeeper 的 “/brokers/…/state” 节点找到该 partition 的leader；</li><li>producer 将消息发送给该 leader；</li><li>leader 将消息写入本地 log；</li><li>followers 从 leader pull 消息，写入本地 log 后 leader 发送 ACK；</li><li>leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset） 并向 producer 发送 ACK；</li></ol><h4 id="4-2-Broker-存储消息"><a href="#4-2-Broker-存储消息" class="headerlink" title="4.2 Broker 存储消息"></a>4.2 Broker 存储消息</h4><p>物理上把 topic 分成一个或多个 patition，每个 patition 物理上对应一个文件夹（该文件夹存储该 patition 的所有消息和索引文件）</p><h4 id="4-3-Consumer-消费消息"><a href="#4-3-Consumer-消费消息" class="headerlink" title="4.3 Consumer 消费消息"></a>4.3 Consumer 消费消息</h4><p>high-level consumer API 提供了 consumer group 的语义，一个消息只能被 group 内的一个 consumer 所消费，且 consumer 消费消息时不关注 offset，最后一个 offset 由 ZooKeeper 保存（下次消费时，该group 中的consumer将从offset记录的位置开始消费）。</p><p><strong>注意：</strong></p><ol><li>如果消费线程大于 patition 数量，则有些线程将收不到消息；</li><li>如果 patition 数量大于消费线程数，则有些线程多收到多个 patition 的消息；</li><li>如果一个线程消费多个 patition，则无法保证你收到的消息的顺序，而一个 patition 内的消息是有序的。</li></ol><p><strong>consumer 采用 pull 模式从 broker 中读取数据。</strong></p><p>push 模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p><p>对于 Kafka 而言，pull 模式更合适，它可简化 broker 的设计，consumer 可自主控制消费消息的速率，同时 consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;amp;mid=2247491550&amp;amp;idx=3&amp;amp;sn=0d6aa438a6cc4ea208c84f1f0379b3b2&amp;amp;chksm=e82bfecfdf5c77d9620dc76961be083c59d78ed95f95161f9ccc68e60340576776fc4f1295bb&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1589620106744&amp;amp;sharer_shareid=40612a9bc90b8d55689c1d82b8ad1cd7&amp;amp;key=4c5479cb7e07b2ac11eb878bf4bbe77475b5ddbee6605609ce3b505a9e2e871c999eebda374f3a655a6b5e103c88704ae7d5cc939580c8cad9181cbbbd53b95978296a1f1b100deda5c4487082d627b8&amp;amp;ascene=1&amp;amp;uin=MTc0MjQ2ODA2OQ%3D%3D&amp;amp;devicetype=Windows+10+x64&amp;amp;version=6209007b&amp;amp;lang=zh_CN&amp;amp;exportkey=ATBs42KokFLoegR4uWL%2BLkk%3D&amp;amp;pass_ticket=2jrmEmmI%2FRKlJnUXJvlSHbMpD7YmNlp77%2FbnqdknS92wQ%2FpqE2jV1X8ub0m%2Bygwf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-Kafka-总体架构&quot;&gt;&lt;a href=&quot;#1-Kafka-总体架构&quot; class=&quot;headerlink&quot; title=&quot;1. Kafka 总体架构&quot;&gt;&lt;/a&gt;1. Kafka 总体架构&lt;/h3&gt;&lt;p&gt;基于 Kafka-ZooKeeper 的分布式消息队列系统总体架构如下：&lt;/p&gt;
&lt;figure class=&quot;image-box&quot;&gt;
                &lt;img src=&quot;https://gitee.com/sjsmi1e/image-bed/raw/master/markdown_images/640-1589628937051.png&quot; alt=&quot;img&quot; title=&quot;&quot; class=&quot;&quot;&gt;
                &lt;p&gt;img&lt;/p&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="消息队列" scheme="http://www.sjsmile.cn/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Kafka" scheme="http://www.sjsmile.cn/tags/Kafka/"/>
    
      <category term="ZooKeeper" scheme="http://www.sjsmile.cn/tags/ZooKeeper/"/>
    
      <category term="分布式消息队列" scheme="http://www.sjsmile.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
